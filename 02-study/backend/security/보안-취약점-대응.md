---
tags:
  - study
  - spring
  - security
  - vulnerability
  - owasp
created: 2025-02-08
---

# 보안 취약점 대응

## 한 줄 요약
> 웹 애플리케이션의 주요 보안 취약점(SQL Injection, XSS, CSRF 등)을 이해하고 Spring Security와 Spring Boot의 기본 방어 메커니즘을 활용하여 OWASP Top 10 공격으로부터 시스템을 보호한다.

## 상세 설명

### 보안 취약점이란?
- **OWASP Top 10**: 가장 위험한 웹 취약점 목록
- **공격 벡터**: SQL Injection, XSS, CSRF 등
- **방어 필수**: 금융, 개인정보 다루는 시스템

### OWASP Top 10 (2021)

| 순위 | 취약점 | 설명 |
|-----|-------|------|
| 1 | **Broken Access Control** | 인가 결함 |
| 2 | **Cryptographic Failures** | 암호화 실패 |
| 3 | **Injection** | SQL Injection, XSS 등 |
| 4 | **Insecure Design** | 불안전한 설계 |
| 5 | **Security Misconfiguration** | 보안 설정 오류 |
| 6 | **Vulnerable Components** | 취약한 라이브러리 |
| 7 | **Authentication Failures** | 인증 결함 |
| 8 | **Data Integrity Failures** | 데이터 무결성 실패 |
| 9 | **Security Logging Failures** | 로깅 실패 |
| 10 | **SSRF** | 서버 측 요청 위조 |

## 코드 예시

```java
// 1. SQL Injection 방어
// ❌ 취약한 코드 (동적 쿼리)
@Repository
public class UserRepository {
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
        // username = "admin' OR '1'='1" → 모든 사용자 조회!
        return jdbcTemplate.queryForObject(sql, new UserRowMapper());
    }
}

// ✅ PreparedStatement 사용
@Repository
public class UserRepository {
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), username);
        // 파라미터 자동 이스케이프
    }
}

// ✅ JPA/JPQL (파라미터 바인딩)
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 메서드 쿼리 (자동 파라미터 바인딩)
    Optional<User> findByUsername(String username);
    
    // JPQL (Named Parameter)
    @Query("SELECT u FROM User u WHERE u.username = :username")
    Optional<User> findByUsernameJpql(@Param("username") String username);
    
    // Native Query (파라미터 바인딩)
    @Query(value = "SELECT * FROM users WHERE username = ?1", nativeQuery = true)
    Optional<User> findByUsernameNative(String username);
}

// 2. XSS (Cross-Site Scripting) 방어
// ❌ 취약한 코드 (HTML 이스케이프 없음)
@GetMapping("/comment")
public String showComment(@RequestParam String text, Model model) {
    model.addAttribute("comment", text);
    // text = "<script>alert('XSS')</script>"
    return "comment";  // 그대로 렌더링 → XSS 공격!
}

// Thymeleaf (안전)
// <p th:text="${comment}"></p>  → 자동 이스케이프
// <p th:utext="${comment}"></p> → 이스케이프 안 함 (위험!)

// ✅ Spring Boot의 자동 이스케이프 활용
@Configuration
public class WebConfig {
    // Thymeleaf는 기본적으로 th:text가 HTML 이스케이프
    // JSP는 <c:out> 사용
}

// ✅ REST API는 JSON 응답 (자동 이스케이프)
@RestController
public class CommentController {
    
    @GetMapping("/api/comments")
    public List<CommentDto> getComments() {
        return commentService.findAll();
        // JSON 변환 시 자동 이스케이프
    }
}

// ✅ 사용자 입력 검증 및 필터링
@Component
public class XssFilter {
    
    private static final Pattern[] XSS_PATTERNS = {
        Pattern.compile("<script>(.*?)</script>", Pattern.CASE_INSENSITIVE),
        Pattern.compile("javascript:", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onerror=", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onload=", Pattern.CASE_INSENSITIVE)
    };
    
    public String sanitize(String input) {
        if (input == null) {
            return null;
        }
        
        String result = input;
        for (Pattern pattern : XSS_PATTERNS) {
            result = pattern.matcher(result).replaceAll("");
        }
        
        return result;
    }
}

// 3. CSRF (Cross-Site Request Forgery) 방어
// ✅ Spring Security의 기본 CSRF 보호 (활성화)
@Configuration
@EnableWebSecurity
public class CsrfConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                // 기본 활성화 (세션 기반)
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
        
        return http.build();
    }
}

// Thymeleaf 폼에서 자동 CSRF 토큰 추가
// <form th:action="@{/login}" method="post">
//   <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
// </form>

// ✅ REST API는 CSRF 비활성화 (Stateless)
@Configuration
public class RestApiSecurityConfig {
    
    @Bean
    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher("/api/**")
            .csrf(csrf -> csrf.disable())  // JWT 사용 시
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );
        
        return http.build();
    }
}

// ✅ 특정 경로만 CSRF 제외
http.csrf(csrf -> csrf
    .ignoringRequestMatchers("/api/public/**")
);

// 4. Session Fixation 방어
@Configuration
public class SessionSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .sessionManagement(session -> session
                .sessionFixation().changeSessionId()  // 기본값 (권장)
                // 로그인 성공 시 세션 ID 변경
            );
        
        return http.build();
    }
}

// 5. 세션 하이재킹 방어
@Configuration
public class SessionConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .sessionManagement(session -> session
                .maximumSessions(1)  // 동시 세션 1개만 허용
                .maxSessionsPreventsLogin(true)  // 새 로그인 차단
                .expiredUrl("/login?expired=true")
            );
        
        return http.build();
    }
}

// application.yml
// server:
//   servlet:
//     session:
//       timeout: 30m  # 세션 타임아웃
//       cookie:
//         http-only: true  # JavaScript 접근 차단
//         secure: true     # HTTPS만
//         same-site: strict  # CSRF 방어

// 6. 브루트 포스 공격 방어 (로그인 시도 횟수 제한)
@Component
@RequiredArgsConstructor
public class LoginAttemptService {
    
    private final LoadingCache<String, Integer> attemptsCache;
    
    @PostConstruct
    public void init() {
        attemptsCache = CacheBuilder.newBuilder()
                .expireAfterWrite(1, TimeUnit.DAYS)
                .build(new CacheLoader<String, Integer>() {
                    @Override
                    public Integer load(String key) {
                        return 0;
                    }
                });
    }
    
    public void loginSucceeded(String key) {
        attemptsCache.invalidate(key);
    }
    
    public void loginFailed(String key) {
        int attempts = attemptsCache.getUnchecked(key);
        attemptsCache.put(key, attempts + 1);
    }
    
    public boolean isBlocked(String key) {
        try {
            return attemptsCache.get(key) >= 5;  // 5번 실패 시 차단
        } catch (ExecutionException e) {
            return false;
        }
    }
}

@Component
@RequiredArgsConstructor
public class LoginFailureHandler implements AuthenticationFailureHandler {
    
    private final LoginAttemptService loginAttemptService;
    
    @Override
    public void onAuthenticationFailure(
            HttpServletRequest request,
            HttpServletResponse response,
            AuthenticationException exception) throws IOException {
        
        String username = request.getParameter("username");
        String ip = getClientIP(request);
        
        loginAttemptService.loginFailed(username);
        loginAttemptService.loginFailed(ip);
        
        response.sendRedirect("/login?error=true");
    }
    
    private String getClientIP(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty()) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}

// 7. 민감 정보 노출 방지
@Entity
public class User {
    
    @Column(nullable = false)
    private String username;
    
    @Column(nullable = false)
    @JsonIgnore  // JSON 응답에서 제외
    private String password;
    
    @Column
    @JsonIgnore
    private String ssn;  // 주민번호 등 민감 정보
}

@RestController
public class UserController {
    
    @GetMapping("/api/users/{id}")
    public UserDto getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        
        // DTO로 변환 (필요한 정보만 노출)
        return UserDto.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(maskEmail(user.getEmail()))  // 이메일 마스킹
                .build();
    }
    
    private String maskEmail(String email) {
        String[] parts = email.split("@");
        String masked = parts[0].substring(0, 2) + "***";
        return masked + "@" + parts[1];
    }
}

// 8. 안전한 파일 업로드
@Service
public class FileUploadService {
    
    private static final List<String> ALLOWED_EXTENSIONS = 
        Arrays.asList("jpg", "jpeg", "png", "pdf");
    
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024;  // 10MB
    
    public String uploadFile(MultipartFile file) {
        // 1. 파일 크기 검증
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("File size exceeds limit");
        }
        
        // 2. 확장자 검증
        String filename = file.getOriginalFilename();
        String extension = getExtension(filename).toLowerCase();
        
        if (!ALLOWED_EXTENSIONS.contains(extension)) {
            throw new IllegalArgumentException("Invalid file type");
        }
        
        // 3. 파일명 검증 (경로 순회 공격 방지)
        if (filename.contains("..") || filename.contains("/") || filename.contains("\\")) {
            throw new IllegalArgumentException("Invalid filename");
        }
        
        // 4. MIME 타입 검증
        String contentType = file.getContentType();
        if (!isValidContentType(contentType, extension)) {
            throw new IllegalArgumentException("Content type mismatch");
        }
        
        // 5. 안전한 파일명 생성
        String safeFilename = UUID.randomUUID() + "." + extension;
        
        // 6. 저장
        Path uploadPath = Paths.get("/uploads");
        Files.copy(file.getInputStream(), uploadPath.resolve(safeFilename));
        
        return safeFilename;
    }
    
    private boolean isValidContentType(String contentType, String extension) {
        Map<String, String> validTypes = Map.of(
            "jpg", "image/jpeg",
            "jpeg", "image/jpeg",
            "png", "image/png",
            "pdf", "application/pdf"
        );
        return validTypes.get(extension).equals(contentType);
    }
}

// 9. 보안 헤더 설정
@Configuration
public class SecurityHeadersConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers(headers -> headers
                // X-Frame-Options (클릭재킹 방지)
                .frameOptions(frame -> frame.deny())
                
                // X-Content-Type-Options (MIME 스니핑 방지)
                .contentTypeOptions(Customizer.withDefaults())
                
                // X-XSS-Protection
                .xssProtection(xss -> xss.headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK))
                
                // Strict-Transport-Security (HTTPS 강제)
                .httpStrictTransportSecurity(hsts -> hsts
                    .maxAgeInSeconds(31536000)  // 1년
                    .includeSubDomains(true)
                )
                
                // Content-Security-Policy
                .contentSecurityPolicy(csp -> csp
                    .policyDirectives("default-src 'self'; " +
                                    "script-src 'self' https://trusted.cdn.com; " +
                                    "style-src 'self' 'unsafe-inline';")
                )
            );
        
        return http.build();
    }
}

// 10. 안전한 난수 생성
@Component
public class TokenGenerator {
    
    private final SecureRandom secureRandom = new SecureRandom();
    
    // ❌ 예측 가능한 난수
    public String generateTokenWrong() {
        Random random = new Random();
        return String.valueOf(random.nextInt());  // 취약!
    }
    
    // ✅ 안전한 난수
    public String generateToken() {
        byte[] randomBytes = new byte[32];
        secureRandom.nextBytes(randomBytes);
        return Base64.getUrlEncoder().encodeToString(randomBytes);
    }
}

// 11. API Rate Limiting
@Component
public class RateLimitFilter extends OncePerRequestFilter {
    
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    
    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {
        
        String clientId = getClientId(request);
        
        RateLimiter limiter = limiters.computeIfAbsent(
            clientId,
            k -> RateLimiter.create(10.0)  // 초당 10 요청
        );
        
        if (!limiter.tryAcquire()) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write("Too many requests");
            return;
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getClientId(HttpServletRequest request) {
        // IP 또는 사용자 ID
        return request.getRemoteAddr();
    }
}

// 12. 보안 로깅
@Component
@Slf4j
public class SecurityEventListener {
    
    @EventListener
    public void onAuthenticationSuccess(AuthenticationSuccessEvent event) {
        String username = event.getAuthentication().getName();
        log.info("로그인 성공: username={}", username);
    }
    
    @EventListener
    public void onAuthenticationFailure(AbstractAuthenticationFailureEvent event) {
        String username = event.getAuthentication().getName();
        String error = event.getException().getMessage();
        log.warn("로그인 실패: username={}, error={}", username, error);
        
        // 실패 횟수가 많으면 관리자에게 알림
        // alertService.sendAlert("Multiple login failures for " + username);
    }
    
    @EventListener
    public void onAuthorizationFailure(AuthorizationDeniedEvent event) {
        Authentication auth = (Authentication) event.getAuthentication().get();
        String username = auth.getName();
        String resource = event.getAuthorizationDecision().toString();
        
        log.warn("권한 없음: username={}, resource={}", username, resource);
    }
}

// 13. 취약한 라이브러리 점검
// build.gradle
// plugins {
//     id 'org.owasp.dependencycheck' version '8.0.0'
// }

// ./gradlew dependencyCheckAnalyze

// 14. 입력 검증
@RestController
@Validated
public class ProductController {
    
    @PostMapping("/api/products")
    public ResponseEntity<Product> createProduct(
            @Valid @RequestBody ProductDto dto) {
        
        // @Valid가 자동 검증
        Product product = productService.create(dto);
        return ResponseEntity.ok(product);
    }
}

@Data
public class ProductDto {
    
    @NotBlank(message = "상품명은 필수입니다")
    @Size(min = 2, max = 100, message = "상품명은 2-100자여야 합니다")
    private String name;
    
    @NotNull(message = "가격은 필수입니다")
    @Min(value = 0, message = "가격은 0 이상이어야 합니다")
    private Integer price;
    
    @Pattern(regexp = "^[A-Z0-9]{10}$", message = "잘못된 상품 코드 형식")
    private String productCode;
}

// 15. HTTPS 강제
// application.yml
// server:
//   ssl:
//     enabled: true
//     key-store: classpath:keystore.p12
//     key-store-password: ${SSL_PASSWORD}
//     key-store-type: PKCS12

@Configuration
public class HttpsConfig {
    
    @Bean
    public TomcatServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint securityConstraint = new SecurityConstraint();
                securityConstraint.setUserConstraint("CONFIDENTIAL");
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern("/*");
                securityConstraint.addCollection(collection);
                context.addConstraint(securityConstraint);
            }
        };
        
        tomcat.addAdditionalTomcatConnectors(redirectConnector());
        return tomcat;
    }
    
    private Connector redirectConnector() {
        Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);
        connector.setScheme("http");
        connector.setPort(8080);
        connector.setSecure(false);
        connector.setRedirectPort(8443);  // HTTP → HTTPS 리다이렉트
        return connector;
    }
}
```

## 주의사항 / 함정

### 1. 동적 쿼리 사용
```java
// ❌ String 연결로 쿼리 생성
String sql = "SELECT * FROM users WHERE name = '" + name + "'";

// ✅ PreparedStatement 또는 JPA
String sql = "SELECT * FROM users WHERE name = ?";
```

### 2. 사용자 입력 검증 누락
```java
// ❌ 검증 없이 바로 사용
user.setEmail(request.getParameter("email"));

// ✅ @Valid 검증
public void updateUser(@Valid UserDto dto) { }
```

### 3. 에러 메시지에 민감 정보 포함
```java
// ❌ 상세한 에러 메시지
throw new Exception("User 'admin' not found in database 'prod_db'");

// ✅ 일반적인 에러 메시지
throw new Exception("Invalid credentials");
```

### 4. HTTPS 미사용
```
// ❌ HTTP로 민감 정보 전송
http://example.com/login

// ✅ HTTPS 사용
https://example.com/login
```

### 5. 보안 헤더 누락
```java
// ❌ 보안 헤더 설정 안 함
// X-Frame-Options, CSP 등 누락

// ✅ Spring Security 기본 헤더 활성화
http.headers(Customizer.withDefaults());
```

### 6. 세션 타임아웃 미설정
```yaml
# ❌ 세션 무제한
# 사용자가 로그아웃 안 하면 계속 유효

# ✅ 타임아웃 설정
server:
  servlet:
    session:
      timeout: 30m
```

### 7. 취약한 라이브러리 방치
```
# ❌ 오래된 버전 사용
spring-boot-starter-web:2.0.0

# ✅ 최신 버전 유지
spring-boot-starter-web:3.2.0
```

## 관련 개념
- [[Spring-Security-아키텍처]]
- [[인증-흐름-Authentication]]
- [[인가-흐름-Authorization]]
- [[비밀번호-암호화-BCrypt]]
- [[CORS-설정]]

## 면접 질문

1. **SQL Injection을 방어하는 방법은?**
   - PreparedStatement 사용
   - JPA/MyBatis의 파라미터 바인딩
   - 입력 검증

2. **XSS 공격이란 무엇인가요?**
   - 악성 스크립트 삽입 공격
   - HTML 이스케이프로 방어
   - Content-Security-Policy 헤더

3. **CSRF 공격을 설명하세요.**
   - 사용자 의도와 무관한 요청 실행
   - CSRF 토큰으로 방어
   - SameSite 쿠키

4. **Session Fixation 공격이란?**
   - 세션 ID 고정 공격
   - 로그인 시 세션 ID 변경으로 방어

5. **브루트 포스 공격 방어 방법은?**
   - 로그인 시도 횟수 제한
   - CAPTCHA
   - 계정 잠금

6. **민감 정보 노출을 방지하는 방법은?**
   - DTO 사용 (필요한 정보만 노출)
   - @JsonIgnore
   - 에러 메시지 일반화

7. **OWASP Top 10에서 가장 위험한 취약점은?**
   - Broken Access Control (인가 결함)
   - 권한 검증 누락, 불충분한 권한 체크

## 참고 자료
- OWASP Top 10
- Spring Security Reference
- https://owasp.org/www-project-top-ten/
