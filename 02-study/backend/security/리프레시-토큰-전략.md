---
tags:
  - study
  - spring
  - security
  - jwt
  - refresh-token
created: 2025-02-08
---

# 리프레시 토큰 전략

## 한 줄 요약
> 리프레시 토큰(Refresh Token)은 Access Token의 짧은 만료 시간 문제를 해결하기 위해 긴 만료 시간을 가진 토큰으로, Access Token이 만료되면 새로 발급받는 용도로 사용하여 보안과 사용자 편의성을 동시에 확보한다.

## 상세 설명

### 리프레시 토큰이란?
- **Access Token 재발급** 전용 토큰
- **긴 만료 시간**: 1주일~1개월
- **DB 저장**: 서버에서 관리 가능

### 왜 리프레시 토큰이 필요한가?
```java
// ❌ Access Token만 사용 (문제점)
// 1. 긴 만료 시간 → 탈취 시 오래 악용 가능
// 2. 짧은 만료 시간 → 자주 재로그인 필요

// ✅ Access + Refresh Token
// 1. Access Token: 짧은 만료 (1시간) → 보안 강화
// 2. Refresh Token: 긴 만료 (1주일) → 편의성 확보
```

### Access Token vs Refresh Token

| 구분 | Access Token | Refresh Token |
|-----|-------------|---------------|
| **용도** | API 요청 인증 | Access Token 재발급 |
| **만료 시간** | 짧음 (1시간) | 김 (1주일~1개월) |
| **저장 위치** | 클라이언트 (메모리) | 서버 DB |
| **탈취 시 위험** | 낮음 (짧은 만료) | 높음 (긴 만료) |
| **로테이션** | 없음 | 있음 (RTR) |

### 리프레시 토큰 전략

```
1. 로그인 성공
   ↓
2. Access Token (1시간) + Refresh Token (1주일) 발급
   ↓
3. Refresh Token은 DB에 저장
   ↓
4. API 요청 시 Access Token 사용
   ↓
5. Access Token 만료
   ↓
6. Refresh Token으로 새 Access Token 발급
   ↓
7. (선택) Refresh Token도 갱신 (RTR)
```

### RTR (Refresh Token Rotation)

- **Refresh Token도 재발급**
- **이전 Refresh Token 무효화**
- **재사용 공격 방지**

## 코드 예시

```java
// 1. RefreshToken 엔티티
@Entity
@Getter
@NoArgsConstructor
public class RefreshToken {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String token;
    
    @Column(nullable = false)
    private String username;
    
    @Column(nullable = false)
    private LocalDateTime expiryDate;
    
    public RefreshToken(String token, String username, LocalDateTime expiryDate) {
        this.token = token;
        this.username = username;
        this.expiryDate = expiryDate;
    }
    
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiryDate);
    }
}

// 2. RefreshToken Repository
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    
    Optional<RefreshToken> findByToken(String token);
    
    Optional<RefreshToken> findByUsername(String username);
    
    void deleteByUsername(String username);
    
    @Modifying
    @Query("DELETE FROM RefreshToken r WHERE r.expiryDate < :now")
    void deleteExpiredTokens(@Param("now") LocalDateTime now);
}

// 3. RefreshToken Service
@Service
@RequiredArgsConstructor
@Transactional
public class RefreshTokenService {
    
    private final RefreshTokenRepository refreshTokenRepository;
    
    @Value("${jwt.refresh-expiration:604800000}")  // 7일
    private long refreshExpirationTime;
    
    // Refresh Token 생성 및 저장
    public RefreshToken createRefreshToken(String username) {
        // 기존 토큰 삭제
        refreshTokenRepository.findByUsername(username)
                .ifPresent(refreshTokenRepository::delete);
        
        // 새 토큰 생성
        String token = UUID.randomUUID().toString();
        LocalDateTime expiryDate = LocalDateTime.now()
                .plusSeconds(refreshExpirationTime / 1000);
        
        RefreshToken refreshToken = new RefreshToken(token, username, expiryDate);
        return refreshTokenRepository.save(refreshToken);
    }
    
    // Refresh Token 검증
    public RefreshToken verifyRefreshToken(String token) {
        RefreshToken refreshToken = refreshTokenRepository.findByToken(token)
                .orElseThrow(() -> new TokenException("Refresh token not found"));
        
        if (refreshToken.isExpired()) {
            refreshTokenRepository.delete(refreshToken);
            throw new TokenException("Refresh token expired");
        }
        
        return refreshToken;
    }
    
    // Refresh Token 삭제 (로그아웃)
    public void deleteByUsername(String username) {
        refreshTokenRepository.deleteByUsername(username);
    }
}

// 4. 로그인 API (Access + Refresh Token 발급)
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {
    
    private final AuthenticationManager authenticationManager;
    private final JwtProvider jwtProvider;
    private final RefreshTokenService refreshTokenService;
    
    @PostMapping("/login")
    public ResponseEntity<TokenResponse> login(@RequestBody LoginRequest request) {
        // 1. 인증
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                request.getUsername(),
                request.getPassword()
            )
        );
        
        String username = authentication.getName();
        
        // 2. Access Token 생성
        String accessToken = jwtProvider.createToken(authentication);
        
        // 3. Refresh Token 생성 및 저장
        RefreshToken refreshToken = refreshTokenService.createRefreshToken(username);
        
        // 4. 응답
        return ResponseEntity.ok(new TokenResponse(
            accessToken,
            refreshToken.getToken()
        ));
    }
}

@Data
@AllArgsConstructor
public class TokenResponse {
    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";
    
    public TokenResponse(String accessToken, String refreshToken) {
        this.accessToken = accessToken;
        this.refreshToken = refreshToken;
    }
}

// 5. Access Token 재발급 API
@PostMapping("/refresh")
public ResponseEntity<TokenResponse> refresh(
        @RequestBody RefreshTokenRequest request) {
    
    String refreshTokenValue = request.getRefreshToken();
    
    // 1. Refresh Token 검증
    RefreshToken refreshToken = refreshTokenService
            .verifyRefreshToken(refreshTokenValue);
    
    // 2. 사용자 정보 조회
    String username = refreshToken.getUsername();
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
    
    // 3. 새 Access Token 생성
    Authentication authentication = new UsernamePasswordAuthenticationToken(
        userDetails,
        null,
        userDetails.getAuthorities()
    );
    String newAccessToken = jwtProvider.createToken(authentication);
    
    // 4. 응답 (Refresh Token은 재사용)
    return ResponseEntity.ok(new TokenResponse(
        newAccessToken,
        refreshTokenValue
    ));
}

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}

// 6. RTR (Refresh Token Rotation) 구현
@PostMapping("/refresh-rtr")
public ResponseEntity<TokenResponse> refreshWithRotation(
        @RequestBody RefreshTokenRequest request) {
    
    String oldRefreshTokenValue = request.getRefreshToken();
    
    // 1. 기존 Refresh Token 검증
    RefreshToken oldRefreshToken = refreshTokenService
            .verifyRefreshToken(oldRefreshTokenValue);
    
    String username = oldRefreshToken.getUsername();
    
    // 2. 기존 Refresh Token 삭제
    refreshTokenRepository.delete(oldRefreshToken);
    
    // 3. 새 Access Token 생성
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
    Authentication authentication = new UsernamePasswordAuthenticationToken(
        userDetails, null, userDetails.getAuthorities()
    );
    String newAccessToken = jwtProvider.createToken(authentication);
    
    // 4. 새 Refresh Token 생성
    RefreshToken newRefreshToken = refreshTokenService
            .createRefreshToken(username);
    
    // 5. 응답 (둘 다 새 토큰)
    return ResponseEntity.ok(new TokenResponse(
        newAccessToken,
        newRefreshToken.getToken()
    ));
}

// 7. 로그아웃 API (Refresh Token 삭제)
@PostMapping("/logout")
public ResponseEntity<Void> logout(Authentication authentication) {
    String username = authentication.getName();
    
    // Refresh Token 삭제
    refreshTokenService.deleteByUsername(username);
    
    return ResponseEntity.ok().build();
}

// 8. 재사용 공격 탐지 (RTR)
@Service
@RequiredArgsConstructor
public class RefreshTokenService {
    
    private final RefreshTokenRepository refreshTokenRepository;
    private final UsedTokenRepository usedTokenRepository;
    
    public RefreshToken verifyRefreshTokenWithReuseDetection(String token) {
        // 1. 사용된 토큰인지 확인
        if (usedTokenRepository.existsByToken(token)) {
            // 재사용 공격 탐지!
            log.warn("Refresh token reuse detected: {}", token);
            
            // 해당 사용자의 모든 토큰 무효화
            RefreshToken oldToken = refreshTokenRepository.findByToken(token)
                    .orElseThrow();
            refreshTokenRepository.deleteByUsername(oldToken.getUsername());
            
            throw new SecurityException("Token reuse detected. All tokens revoked.");
        }
        
        // 2. 토큰 검증
        RefreshToken refreshToken = refreshTokenRepository.findByToken(token)
                .orElseThrow(() -> new TokenException("Invalid refresh token"));
        
        if (refreshToken.isExpired()) {
            refreshTokenRepository.delete(refreshToken);
            throw new TokenException("Refresh token expired");
        }
        
        // 3. 사용된 토큰으로 기록
        usedTokenRepository.save(new UsedToken(token));
        
        return refreshToken;
    }
}

// 9. 만료된 Refresh Token 자동 삭제 (스케줄러)
@Component
@RequiredArgsConstructor
public class TokenCleanupScheduler {
    
    private final RefreshTokenRepository refreshTokenRepository;
    
    @Scheduled(cron = "0 0 3 * * *")  // 매일 새벽 3시
    @Transactional
    public void cleanupExpiredTokens() {
        refreshTokenRepository.deleteExpiredTokens(LocalDateTime.now());
        log.info("Expired refresh tokens cleaned up");
    }
}

// 10. 멀티 디바이스 지원
@Entity
public class RefreshToken {
    
    @Column
    private String deviceId;  // 디바이스 식별자
    
    @Column
    private String deviceName;  // 디바이스 이름 (예: "iPhone 14")
}

@Service
public class RefreshTokenService {
    
    public RefreshToken createRefreshToken(
            String username,
            String deviceId,
            String deviceName) {
        
        String token = UUID.randomUUID().toString();
        LocalDateTime expiryDate = LocalDateTime.now()
                .plusSeconds(refreshExpirationTime / 1000);
        
        RefreshToken refreshToken = RefreshToken.builder()
                .token(token)
                .username(username)
                .deviceId(deviceId)
                .deviceName(deviceName)
                .expiryDate(expiryDate)
                .build();
        
        return refreshTokenRepository.save(refreshToken);
    }
    
    // 디바이스별 조회
    public List<RefreshToken> getDevicesByUsername(String username) {
        return refreshTokenRepository.findAllByUsername(username);
    }
    
    // 특정 디바이스 토큰 삭제
    public void deleteByUsernameAndDeviceId(String username, String deviceId) {
        refreshTokenRepository.deleteByUsernameAndDeviceId(username, deviceId);
    }
}

// 11. Refresh Token을 Cookie에 저장 (httpOnly)
@PostMapping("/login-cookie")
public ResponseEntity<AccessTokenResponse> loginWithCookie(
        @RequestBody LoginRequest request,
        HttpServletResponse response) {
    
    // 인증 및 토큰 생성
    Authentication authentication = authenticate(request);
    String accessToken = jwtProvider.createToken(authentication);
    RefreshToken refreshToken = refreshTokenService
            .createRefreshToken(authentication.getName());
    
    // Refresh Token을 httpOnly Cookie에 저장
    Cookie cookie = new Cookie("refreshToken", refreshToken.getToken());
    cookie.setHttpOnly(true);  // JavaScript 접근 불가
    cookie.setSecure(true);    // HTTPS만
    cookie.setPath("/api/auth/refresh");  // 특정 경로만
    cookie.setMaxAge(7 * 24 * 60 * 60);   // 7일
    response.addCookie(cookie);
    
    // Access Token만 응답 Body에
    return ResponseEntity.ok(new AccessTokenResponse(accessToken));
}

// Refresh 시 Cookie에서 읽기
@PostMapping("/refresh-cookie")
public ResponseEntity<AccessTokenResponse> refreshFromCookie(
        @CookieValue(name = "refreshToken") String refreshToken) {
    
    // Refresh Token 검증 및 새 Access Token 발급
    RefreshToken token = refreshTokenService.verifyRefreshToken(refreshToken);
    String newAccessToken = createNewAccessToken(token.getUsername());
    
    return ResponseEntity.ok(new AccessTokenResponse(newAccessToken));
}

// 12. Access Token 자동 갱신 (프론트엔드)
// JavaScript 예시
// axios interceptor로 401 응답 시 자동 갱신
axios.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;
    
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Refresh Token으로 새 Access Token 받기
        const { data } = await axios.post('/api/auth/refresh', {
          refreshToken: localStorage.getItem('refreshToken')
        });
        
        // 새 Access Token 저장
        localStorage.setItem('accessToken', data.accessToken);
        
        // 원래 요청 재시도
        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;
        return axios(originalRequest);
        
      } catch (refreshError) {
        // Refresh 실패 → 로그인 페이지로
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);
```

## 주의사항 / 함정

### 1. Refresh Token을 Access Token처럼 사용
```java
// ❌ Refresh Token으로 API 호출
Authorization: Bearer <refresh-token>

// ✅ Access Token만 API 호출에 사용
Authorization: Bearer <access-token>
// Refresh Token은 /refresh 엔드포인트에만 사용
```

### 2. Refresh Token DB 저장 안 함
```java
// ❌ Refresh Token도 클라이언트만 저장
String refreshToken = UUID.randomUUID().toString();
return new TokenResponse(accessToken, refreshToken);
// 강제 만료 불가능!

// ✅ DB에 저장
RefreshToken token = refreshTokenService.createRefreshToken(username);
```

### 3. RTR 미적용
```java
// ❌ Refresh Token 재사용
// 탈취된 토큰이 계속 유효

// ✅ RTR 적용
// Refresh할 때마다 새 Refresh Token 발급
```

### 4. Refresh Token 만료 시간 너무 김
```java
// ❌ 1년 만료
refreshExpirationTime = 31536000000;  // 보안 위험!

// ✅ 1~2주 권장
refreshExpirationTime = 604800000;  // 7일
```

### 5. 재사용 공격 탐지 안 함
```java
// ❌ 사용된 Refresh Token도 계속 유효
// 공격자가 탈취한 토큰 재사용 가능

// ✅ 사용된 토큰 기록 및 탐지
usedTokenRepository.save(new UsedToken(token));
```

### 6. httpOnly Cookie 미사용
```java
// ❌ LocalStorage에 Refresh Token 저장
localStorage.setItem('refreshToken', token);
// XSS 공격에 취약!

// ✅ httpOnly Cookie 사용
Cookie cookie = new Cookie("refreshToken", token);
cookie.setHttpOnly(true);
```

### 7. Access Token 만료 시간 너무 김
```java
// ❌ 24시간 만료
accessExpirationTime = 86400000;
// Refresh Token 의미 없음

// ✅ 1시간 이하 권장
accessExpirationTime = 3600000;  // 1시간
```

## 관련 개념
- [[JWT-토큰-기반-인증]]
- [[Spring-Security-아키텍처]]
- [[인증-흐름-Authentication]]

## 면접 질문

1. **왜 Access Token과 Refresh Token을 분리하나요?**
   - Access: 짧은 만료 (보안)
   - Refresh: 긴 만료 (편의성)
   - 탈취 시 피해 최소화

2. **Refresh Token은 어디에 저장하나요?**
   - 서버: DB에 저장 (강제 만료 가능)
   - 클라이언트: httpOnly Cookie (XSS 방지)

3. **RTR(Refresh Token Rotation)이란?**
   - Refresh할 때마다 새 Refresh Token 발급
   - 이전 Refresh Token 무효화
   - 재사용 공격 방지

4. **Refresh Token이 탈취되면?**
   - 재사용 공격 탐지로 모든 토큰 무효화
   - 사용자 로그아웃 및 재로그인 요구

5. **Access Token vs Refresh Token 차이는?**
   - Access: API 인증, 짧은 만료, 클라이언트 저장
   - Refresh: 토큰 재발급, 긴 만료, DB 저장

6. **멀티 디바이스 지원은 어떻게 하나요?**
   - deviceId 필드 추가
   - 디바이스별 Refresh Token 관리
   - 디바이스별 로그아웃 가능

7. **로그아웃 시 어떻게 처리하나요?**
   - Refresh Token DB에서 삭제
   - Access Token은 만료까지 유효 (블랙리스트 추가 고려)

## 참고 자료
- RFC 6749 - OAuth 2.0
- Auth0 Refresh Token Best Practices
- https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/
