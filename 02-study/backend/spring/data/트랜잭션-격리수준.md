---
tags:
  - study
  - spring
  - data
  - transaction
  - isolation
created: 2025-02-08
---

# 트랜잭션 격리수준

## 한 줄 요약
> 트랜잭션 격리수준(Isolation Level)은 동시에 실행되는 여러 트랜잭션 간의 간섭 정도를 제어하여, 데이터 일관성과 동시성 사이의 균형을 조절하는 설정이다.

## 상세 설명

### 트랜잭션 격리수준이란?
- **동시성 제어** 메커니즘
- 한 트랜잭션이 다른 트랜잭션의 변경사항을 볼 수 있는 범위 결정
- 격리 수준 ↑ → 일관성 ↑, 동시성 ↓
- 격리 수준 ↓ → 동시성 ↑, 일관성 ↓

### 왜 격리수준이 필요한가?
```
트랜잭션 A: 계좌 잔액 조회 (10,000원)
트랜잭션 B: 계좌에서 5,000원 출금

A가 조회한 10,000원은 정확한가?
- B가 커밋 전이라면? (더티 리드)
- B가 커밋 후라면? (논리펀터블 리드)
```
→ 격리수준으로 제어!

### 격리수준과 발생 가능한 문제

| 격리수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
|---------|------------|---------------------|--------------|
| **READ UNCOMMITTED** | ⭕ | ⭕ | ⭕ |
| **READ COMMITTED** | ❌ | ⭕ | ⭕ |
| **REPEATABLE READ** | ❌ | ❌ | ⭕(InnoDB는 ❌) |
| **SERIALIZABLE** | ❌ | ❌ | ❌ |

### 동시성 문제 유형

#### 1. Dirty Read (더티 리드)
- **커밋되지 않은 데이터를 읽음**
- 트랜잭션 A가 수정 중인 데이터를 트랜잭션 B가 조회
- A가 롤백하면 B는 존재하지 않는 데이터를 읽은 것

```
시간  트랜잭션 A              트랜잭션 B
1    잔액 조회 (10,000원)
2    5,000원 출금
3                           잔액 조회 (5,000원) ← Dirty Read!
4    롤백 (다시 10,000원)
5                           (존재하지 않는 데이터 읽음)
```

#### 2. Non-Repeatable Read (반복 불가능 읽기)
- **같은 쿼리의 결과가 달라짐**
- 트랜잭션 내에서 같은 데이터를 다시 읽었을 때 값이 변경됨

```
시간  트랜잭션 A              트랜잭션 B
1    잔액 조회 (10,000원)
2                           5,000원 출금
3                           커밋
4    잔액 조회 (5,000원)     ← 다른 결과!
```

#### 3. Phantom Read (팬텀 리드)
- **같은 쿼리의 결과 행 수가 달라짐**
- 트랜잭션 내에서 같은 조건 조회 시 행이 생기거나 사라짐

```
시간  트랜잭션 A                    트랜잭션 B
1    나이 20대 조회 (10명)
2                                 새 회원 추가 (나이 25)
3                                 커밋
4    나이 20대 조회 (11명)         ← Phantom Read!
```

### Spring의 격리수준 설정

| 격리수준 | 설명 | 성능 | 일관성 |
|---------|------|------|--------|
| **DEFAULT** | DB 기본 설정 사용 | - | - |
| **READ_UNCOMMITTED** | 커밋 안 된 데이터 읽기 가능 | 최고 | 최저 |
| **READ_COMMITTED** | 커밋된 데이터만 읽기 | 높음 | 중간 |
| **REPEATABLE_READ** | 트랜잭션 내 일관된 읽기 | 중간 | 높음 |
| **SERIALIZABLE** | 완전한 격리 (직렬화) | 최저 | 최고 |

### DB별 기본 격리수준
- **MySQL InnoDB**: REPEATABLE READ
- **PostgreSQL**: READ COMMITTED
- **Oracle**: READ COMMITTED
- **SQL Server**: READ COMMITTED

## 코드 예시

```java
// 1. READ UNCOMMITTED (거의 사용 안 함)
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public Account getAccount(Long id) {
    // ❌ 위험: 커밋 안 된 데이터도 읽을 수 있음
    // Dirty Read 발생 가능
    return accountRepository.findById(id)
            .orElseThrow(AccountNotFoundException::new);
}

// 2. READ COMMITTED (Oracle, PostgreSQL 기본값)
@Transactional(isolation = Isolation.READ_COMMITTED)
public Account getAccount(Long id) {
    // ✅ 커밋된 데이터만 읽음
    // Dirty Read 방지
    // Non-Repeatable Read는 발생 가능
    return accountRepository.findById(id)
            .orElseThrow(AccountNotFoundException::new);
}

// 3. REPEATABLE READ (MySQL InnoDB 기본값)
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void processAccount(Long id) {
    // ✅ 트랜잭션 시작 시점의 스냅샷 읽기
    // 같은 데이터를 여러 번 읽어도 동일한 결과
    Account account1 = accountRepository.findById(id).get();
    
    // 다른 트랜잭션이 이 계좌를 수정해도
    account1 = accountRepository.findById(id).get();  // 동일한 값
    
    // MySQL InnoDB: Phantom Read도 방지 (MVCC)
}

// 4. SERIALIZABLE (가장 엄격)
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transfer(Long fromId, Long toId, int amount) {
    // ✅ 완전한 격리
    // 다른 트랜잭션이 대기하게 됨
    // 성능 최저, 데드락 위험 최고
    Account from = accountRepository.findById(fromId).get();
    Account to = accountRepository.findById(toId).get();
    
    from.withdraw(amount);
    to.deposit(amount);
}

// 5. Dirty Read 예시
@Service
@RequiredArgsConstructor
public class DirtyReadExample {
    
    private final AccountRepository accountRepository;
    
    // 트랜잭션 A: 수정 중
    @Transactional
    public void updateBalance(Long id, int amount) {
        Account account = accountRepository.findById(id).get();
        account.setBalance(amount);
        
        // 아직 커밋 안 됨
        Thread.sleep(5000);
        
        // 롤백될 수도 있음
        if (amount < 0) {
            throw new RuntimeException("음수 잔액");
        }
    }
    
    // 트랜잭션 B: READ UNCOMMITTED로 조회
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public int getBalance(Long id) {
        Account account = accountRepository.findById(id).get();
        // ❌ 커밋 안 된 데이터를 읽을 수 있음
        // A가 롤백하면 존재하지 않는 데이터
        return account.getBalance();
    }
}

// 6. Non-Repeatable Read 예시
@Service
public class NonRepeatableReadExample {
    
    // 트랜잭션 A: READ COMMITTED로 두 번 조회
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void checkBalance(Long id) {
        Account account1 = accountRepository.findById(id).get();
        int balance1 = account1.getBalance();
        
        // 다른 트랜잭션이 수정 가능
        Thread.sleep(1000);
        
        Account account2 = accountRepository.findById(id).get();
        int balance2 = account2.getBalance();
        
        // ❌ balance1 != balance2 가능 (Non-Repeatable Read)
    }
    
    // 트랜잭션 A: REPEATABLE READ로 두 번 조회
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void checkBalanceRepeatable(Long id) {
        Account account1 = accountRepository.findById(id).get();
        int balance1 = account1.getBalance();
        
        Thread.sleep(1000);
        
        Account account2 = accountRepository.findById(id).get();
        int balance2 = account2.getBalance();
        
        // ✅ balance1 == balance2 (항상 동일)
    }
}

// 7. Phantom Read 예시
@Service
public class PhantomReadExample {
    
    // READ COMMITTED: Phantom Read 발생 가능
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void countUsers() {
        List<User> users1 = userRepository.findByAgeGreaterThan(20);
        int count1 = users1.size();  // 예: 10명
        
        // 다른 트랜잭션이 새 유저 추가
        Thread.sleep(1000);
        
        List<User> users2 = userRepository.findByAgeGreaterThan(20);
        int count2 = users2.size();  // 예: 11명 (Phantom Read)
        
        // ❌ count1 != count2
    }
    
    // REPEATABLE READ (MySQL InnoDB): Phantom Read 방지
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void countUsersRepeatable() {
        List<User> users1 = userRepository.findByAgeGreaterThan(20);
        int count1 = users1.size();  // 예: 10명
        
        Thread.sleep(1000);
        
        List<User> users2 = userRepository.findByAgeGreaterThan(20);
        int count2 = users2.size();  // 여전히 10명
        
        // ✅ count1 == count2 (MySQL InnoDB는 MVCC로 Phantom Read 방지)
    }
}

// 8. 실무 패턴: 조회는 낮은 격리수준, 수정은 높은 격리수준
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    
    // 조회: READ COMMITTED
    @Transactional(isolation = Isolation.READ_COMMITTED, readOnly = true)
    public List<Order> findOrders() {
        return orderRepository.findAll();
    }
    
    // 수정: REPEATABLE READ
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void updateOrder(Long id, OrderStatus status) {
        Order order = orderRepository.findById(id).get();
        order.setStatus(status);
    }
}

// 9. 비관적 락과 함께 사용
@Service
public class InventoryService {
    
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void decreaseStock(Long productId, int quantity) {
        // 비관적 락으로 동시성 제어
        Product product = productRepository.findByIdWithLock(productId);
        
        if (product.getStock() < quantity) {
            throw new OutOfStockException();
        }
        
        product.decreaseStock(quantity);
    }
}

// JPA 비관적 락
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") Long id);
}

// 10. 낙관적 락 (격리수준 낮춰도 안전)
@Entity
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Version  // 낙관적 락
    private Long version;
    
    private int stock;
    
    public void decreaseStock(int quantity) {
        if (this.stock < quantity) {
            throw new OutOfStockException();
        }
        this.stock -= quantity;
    }
}

@Service
public class ProductService {
    
    // 낙관적 락 사용 시 READ COMMITTED도 충분
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void decreaseStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId).get();
        product.decreaseStock(quantity);
        
        // 저장 시 version 체크
        // 다른 트랜잭션이 먼저 수정했으면 OptimisticLockException
    }
}

// 11. 배치 작업에서의 격리수준
@Service
public class BatchService {
    
    // 대량 조회: READ UNCOMMITTED도 가능 (정확도보다 속도)
    @Transactional(
        isolation = Isolation.READ_UNCOMMITTED,
        readOnly = true
    )
    public List<Order> findAllOrdersForBatch() {
        // 배치 처리용 대량 조회
        // Dirty Read 허용 (통계나 리포트 용도)
        return orderRepository.findAll();
    }
}

// 12. 격리수준별 동작 테스트
@Service
public class IsolationTestService {
    
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void testReadCommitted() {
        // Test code
    }
    
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void testRepeatableRead() {
        // Test code
    }
    
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void testSerializable() {
        // Test code
    }
}
```

## 주의사항 / 함정

### 1. 높은 격리수준의 성능 저하
```java
// ❌ SERIALIZABLE 남용
@Transactional(isolation = Isolation.SERIALIZABLE)
public List<User> findAll() {
    // 모든 조회에 SERIALIZABLE → 성능 최악
    return userRepository.findAll();
}

// ✅ 필요한 곳에만 사용
@Transactional(isolation = Isolation.READ_COMMITTED)
public List<User> findAll() {
    return userRepository.findAll();
}
```

### 2. DB별 격리수준 동작 차이
```java
// MySQL InnoDB: REPEATABLE READ에서도 Phantom Read 방지
// PostgreSQL: REPEATABLE READ에서 Phantom Read 발생 가능
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void method() {
    // DB마다 동작이 다를 수 있음!
}
```

### 3. 격리수준과 락의 차이
```java
// 격리수준: 읽기 일관성 제어
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void read() {
    // 스냅샷 읽기
}

// 락: 동시 수정 방지
@Transactional
@Lock(LockModeType.PESSIMISTIC_WRITE)
public void write() {
    // 다른 트랜잭션 대기
}
```

### 4. DEFAULT 격리수준 주의
```java
@Transactional(isolation = Isolation.DEFAULT)
public void method() {
    // MySQL: REPEATABLE READ
    // Oracle: READ COMMITTED
    // DB마다 다름! 명시적 지정 권장
}
```

### 5. SERIALIZABLE의 데드락 위험
```java
// ❌ SERIALIZABLE에서 데드락 발생 가능
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transfer() {
    // 트랜잭션 A: 계좌 1 → 계좌 2
    // 트랜잭션 B: 계좌 2 → 계좌 1
    // 데드락 발생!
}
```

### 6. 읽기 전용 트랜잭션과 격리수준
```java
// readOnly=true는 격리수준과 별개
@Transactional(
    isolation = Isolation.REPEATABLE_READ,
    readOnly = true  // 성능 최적화
)
public User findUser(Long id) {
    return userRepository.findById(id).get();
}
```

### 7. JPA 2차 캐시와 격리수준
```java
// 2차 캐시는 격리수준을 무시
@Transactional(isolation = Isolation.READ_COMMITTED)
public User findUser(Long id) {
    // 2차 캐시에서 조회 시 격리수준 적용 안 됨!
    return userRepository.findById(id).get();
}
```

## 관련 개념
- [[트랜잭션-관리]]
- [[트랜잭션-전파]]
- [[Spring-Data-JPA-연동]]

## 면접 질문

1. **트랜잭션 격리수준 4가지는?**
   - READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE

2. **Dirty Read, Non-Repeatable Read, Phantom Read의 차이는?**
   - Dirty Read: 커밋 안 된 데이터 읽기
   - Non-Repeatable Read: 같은 데이터 재조회 시 값 변경
   - Phantom Read: 같은 조건 재조회 시 행 수 변경

3. **MySQL InnoDB의 기본 격리수준은?**
   - REPEATABLE READ
   - MVCC(Multi-Version Concurrency Control)로 Phantom Read도 방지

4. **READ COMMITTED에서 방지되는 문제는?**
   - Dirty Read만 방지
   - Non-Repeatable Read, Phantom Read는 발생 가능

5. **SERIALIZABLE의 단점은?**
   - 성능 최저 (직렬화)
   - 데드락 위험 최고
   - 동시성 최저

6. **격리수준과 락의 차이는?**
   - 격리수준: 읽기 일관성 제어 (스냅샷)
   - 락: 동시 수정 방지 (대기)

7. **실무에서 권장하는 격리수준은?**
   - 조회: READ COMMITTED (성능)
   - 수정: REPEATABLE READ (일관성)
   - 락과 조합해서 사용

## 참고 자료
- 김영한의 스프링 DB 2편 - 데이터 접근 활용 기술
- MySQL InnoDB Transaction Model
- https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html
