---
tags:
  - study
  - spring
  - data
  - transaction
  - propagation
created: 2025-02-08
---

# 트랜잭션 전파

## 한 줄 요약
> 트랜잭션 전파(Propagation)는 트랜잭션이 있는 메서드가 다른 트랜잭션 메서드를 호출할 때, 기존 트랜잭션을 이어받을지 새로 시작할지 결정하는 정책이다.

## 상세 설명

### 트랜잭션 전파란?
- **트랜잭션의 경계를 결정**하는 메커니즘
- 메서드 A가 메서드 B를 호출할 때, B의 트랜잭션을 어떻게 처리할지 결정
- 7가지 전파 옵션 제공

### 왜 트랜잭션 전파가 필요한가?
```java
@Transactional
public void 주문생성() {
    주문저장();
    재고감소();  // 이 메서드도 @Transactional이면?
}

@Transactional
public void 재고감소() {
    // 기존 트랜잭션 참여? 새 트랜잭션? 트랜잭션 없이?
}
```
→ 트랜잭션 전파로 결정!

### 트랜잭션 전파 종류

| 전파 속성 | 설명 | 사용 시나리오 |
|----------|------|--------------|
| **REQUIRED** (기본) | 기존 트랜잭션 있으면 참여, 없으면 새로 시작 | 대부분의 경우 |
| **REQUIRES_NEW** | 항상 새로운 트랜잭션 시작, 기존 트랜잭션 일시 중단 | 독립적 트랜잭션 |
| **SUPPORTS** | 기존 트랜잭션 있으면 참여, 없어도 트랜잭션 없이 진행 | 읽기 전용 |
| **NOT_SUPPORTED** | 트랜잭션 없이 진행, 기존 트랜잭션 일시 중단 | 트랜잭션 불필요 |
| **MANDATORY** | 기존 트랜잭션 필수, 없으면 예외 발생 | 반드시 트랜잭션 내부 |
| **NEVER** | 트랜잭션 없이 진행, 기존 트랜잭션 있으면 예외 | 트랜잭션 금지 |
| **NESTED** | 기존 트랜잭션 내부에 중첩 트랜잭션 생성 | 부분 롤백 |

### 주요 전파 속성 상세

#### 1. REQUIRED (가장 많이 사용)
```
외부 트랜잭션 있음
  ↓
내부 메서드 참여 (같은 트랜잭션)
  ↓
내부 예외 → 전체 롤백

외부 트랜잭션 없음
  ↓
새 트랜잭션 시작
```

#### 2. REQUIRES_NEW (독립적 트랜잭션)
```
외부 트랜잭션 있음
  ↓
외부 트랜잭션 일시 중단
  ↓
새 트랜잭션 시작
  ↓
내부 완료 → 커밋/롤백
  ↓
외부 트랜잭션 재개
```

#### 3. NESTED (중첩 트랜잭션)
```
외부 트랜잭션 있음
  ↓
Savepoint 생성
  ↓
내부 예외 → Savepoint로 롤백
외부는 계속 진행 가능
```

## 코드 예시

```java
// 1. REQUIRED (기본값)
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final InventoryService inventoryService;
    
    @Transactional  // propagation = Propagation.REQUIRED (기본)
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // inventoryService.decrease()도 같은 트랜잭션에 참여
        inventoryService.decrease(order.getProductId(), order.getQuantity());
        
        // 어느 쪽에서든 예외 발생 시 전체 롤백
    }
}

@Service
@RequiredArgsConstructor
public class InventoryService {
    
    private final InventoryRepository inventoryRepository;
    
    @Transactional  // 기존 트랜잭션에 참여
    public void decrease(Long productId, int quantity) {
        Inventory inventory = inventoryRepository.findById(productId)
                .orElseThrow(InventoryNotFoundException::new);
        
        inventory.decrease(quantity);
        
        // 예외 발생 시 createOrder()까지 모두 롤백
        if (inventory.getQuantity() < 0) {
            throw new OutOfStockException();
        }
    }
}

// 2. REQUIRES_NEW (독립적 트랜잭션)
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final LogService logService;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 로그는 독립적으로 저장 (주문 실패해도 로그는 남음)
        try {
            logService.saveLog("주문 생성: " + order.getId());
        } catch (Exception e) {
            // 로그 저장 실패해도 주문은 계속 진행
        }
    }
}

@Service
@RequiredArgsConstructor
public class LogService {
    
    private final LogRepository logRepository;
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String message) {
        // 독립적인 새 트랜잭션
        // 이 메서드의 성공/실패는 외부 트랜잭션에 영향 없음
        Log log = new Log(message, LocalDateTime.now());
        logRepository.save(log);
    }
}

// 3. SUPPORTS (트랜잭션 선택적)
@Service
public class StatisticsService {
    
    // 트랜잭션이 있으면 참여, 없어도 무방
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public OrderStatistics getStatistics() {
        // 읽기만 하는 경우 적합
        return orderRepository.getStatistics();
    }
}

// 4. NOT_SUPPORTED (트랜잭션 없이)
@Service
public class EmailService {
    
    // 외부 API 호출 시 트랜잭션 불필요
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void sendEmail(String to, String subject, String body) {
        // 트랜잭션 없이 실행
        // DB 커넥션을 점유하지 않음
        externalEmailApi.send(to, subject, body);
    }
}

// 5. MANDATORY (트랜잭션 필수)
@Service
public class PaymentService {
    
    // 반드시 트랜잭션 내부에서만 호출되어야 함
    @Transactional(propagation = Propagation.MANDATORY)
    public void processPayment(Payment payment) {
        // 트랜잭션 없이 호출되면 예외 발생
        paymentRepository.save(payment);
    }
}

@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final PaymentService paymentService;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // ✅ 트랜잭션 내부에서 호출 → OK
        paymentService.processPayment(order.getPayment());
    }
}

// 6. NEVER (트랜잭션 금지)
@Service
public class CacheService {
    
    // 트랜잭션이 있으면 예외 발생
    @Transactional(propagation = Propagation.NEVER)
    public void clearCache() {
        // 캐시 클리어는 트랜잭션 불필요
        cache.clear();
    }
}

// 7. NESTED (중첩 트랜잭션, Savepoint)
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final CouponService couponService;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 쿠폰 적용 시도
        try {
            couponService.applyCoupon(order.getCouponCode());
        } catch (Exception e) {
            // 쿠폰 적용 실패해도 주문은 계속 진행
            // NESTED면 이 부분만 롤백
        }
        
        // 주문은 성공
    }
}

@Service
@RequiredArgsConstructor
public class CouponService {
    
    private final CouponRepository couponRepository;
    
    @Transactional(propagation = Propagation.NESTED)
    public void applyCoupon(String couponCode) {
        Coupon coupon = couponRepository.findByCode(couponCode)
                .orElseThrow(CouponNotFoundException::new);
        
        if (coupon.isExpired()) {
            // 예외 발생 → Savepoint로 롤백
            // 하지만 외부 트랜잭션은 계속 진행 가능
            throw new CouponExpiredException();
        }
        
        coupon.use();
    }
}

// 8. 전파 속성 조합 예시
@Service
@RequiredArgsConstructor
public class OrderFacadeService {
    
    private final OrderService orderService;
    private final NotificationService notificationService;
    private final AuditService auditService;
    
    public void processOrder(Order order) {
        // 주문 처리 (트랜잭션 O)
        orderService.createOrder(order);  // REQUIRED
        
        // 알림 발송 (트랜잭션 X, 실패해도 주문은 유지)
        try {
            notificationService.sendNotification(order);  // REQUIRES_NEW
        } catch (Exception e) {
            log.warn("알림 발송 실패", e);
        }
        
        // 감사 로그 (독립적 트랜잭션)
        auditService.log("주문 처리: " + order.getId());  // REQUIRES_NEW
    }
}

// 9. 전파 속성별 예외 처리
@Service
public class TransactionPropagationExample {
    
    @Autowired
    private Self self;  // 자기 자신 주입 (프록시를 통해 호출하기 위함)
    
    @Transactional
    public void outerMethod() {
        try {
            self.innerRequiresNew();
        } catch (Exception e) {
            // REQUIRES_NEW는 독립 트랜잭션이므로
            // 내부 예외가 외부에 영향 없음
        }
        
        try {
            self.innerRequired();
        } catch (Exception e) {
            // REQUIRED는 같은 트랜잭션이므로
            // 내부 예외 발생 시 전체 롤백
            // 여기서 예외를 잡아도 롤백됨!
        }
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void innerRequiresNew() {
        // 독립 트랜잭션
        throw new RuntimeException("독립 트랜잭션 예외");
    }
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void innerRequired() {
        // 같은 트랜잭션
        throw new RuntimeException("같은 트랜잭션 예외");
    }
}

// 10. 실무 패턴: 이벤트 발행과 전파
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 이벤트 발행 (트랜잭션 커밋 후 처리)
        eventPublisher.publishEvent(new OrderCreatedEvent(order.getId()));
    }
}

@Component
public class OrderEventListener {
    
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 주문 생성 트랜잭션과 독립적으로 실행
        // 이메일 발송, 알림 등
    }
}
```

## 주의사항 / 함정

### 1. REQUIRED의 예외 전파
```java
@Transactional
public void outer() {
    try {
        inner();  // REQUIRED (같은 트랜잭션)
    } catch (Exception e) {
        // ❌ 예외를 잡아도 이미 트랜잭션이 rollback-only로 마킹됨
        // 외부 메서드 종료 시 UnexpectedRollbackException 발생
    }
}

@Transactional  // REQUIRED
public void inner() {
    throw new RuntimeException();
}
```

### 2. REQUIRES_NEW의 성능 이슈
```java
@Transactional
public void outer() {
    for (int i = 0; i < 1000; i++) {
        inner();  // ❌ 1000번 새 트랜잭션 생성/종료
    }
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void inner() {
    // 매번 새 커넥션 획득, 커밋/롤백 → 성능 저하
}
```

### 3. NESTED는 모든 DB가 지원하지 않음
```java
@Transactional(propagation = Propagation.NESTED)
public void nested() {
    // ❌ MySQL InnoDB는 NESTED 미지원
    // DataSource가 Savepoint를 지원해야 함
    // JPA에서는 지원하지 않음 (JDBC만 가능)
}
```

### 4. 같은 클래스 내부 호출
```java
@Service
public class OrderService {
    
    @Transactional
    public void outer() {
        this.inner();  // ❌ 프록시를 거치지 않아 전파 설정 무시!
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void inner() {
        // 새 트랜잭션이 아닌 outer의 트랜잭션에 포함됨
    }
}

// ✅ 해결: 다른 빈으로 분리
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final InnerService innerService;
    
    @Transactional
    public void outer() {
        innerService.inner();  // 프록시를 통해 호출
    }
}
```

### 5. SUPPORTS의 혼란
```java
@Transactional(propagation = Propagation.SUPPORTS)
public void method() {
    // 트랜잭션이 있을 수도, 없을 수도 있음
    // → 일관성 없는 동작 가능
    // 사용에 주의 필요
}
```

### 6. 전파 속성과 격리 수준
```java
@Transactional(
    propagation = Propagation.REQUIRES_NEW,
    isolation = Isolation.SERIALIZABLE  // 새 트랜잭션에만 적용
)
public void method() {
    // 외부 트랜잭션의 격리 수준과 다를 수 있음
}
```

### 7. 롤백 마킹 이해
```java
@Transactional
public void outer() {
    inner();  // REQUIRED
    
    // inner()에서 예외 발생하면
    // 트랜잭션이 "rollback-only"로 마킹됨
    // 여기서 뭘 해도 최종적으로 롤백됨
}
```

## 관련 개념
- [[트랜잭션-관리]]
- [[트랜잭션-격리수준]]
- [[AOP-개념과-활용]]

## 면접 질문

1. **트랜잭션 전파의 기본값은?**
   - REQUIRED (기존 트랜잭션 있으면 참여, 없으면 새로 생성)

2. **REQUIRED와 REQUIRES_NEW의 차이는?**
   - REQUIRED: 기존 트랜잭션 재사용
   - REQUIRES_NEW: 항상 새 트랜잭션 생성, 기존 트랜잭션 일시 중단

3. **NESTED 전파 속성은 언제 사용하나요?**
   - 부분 롤백이 필요할 때 (Savepoint 활용)
   - 주의: JPA는 미지원, JDBC만 가능

4. **REQUIRED에서 내부 메서드 예외를 catch하면?**
   - 이미 트랜잭션이 rollback-only로 마킹됨
   - 외부 메서드 종료 시 UnexpectedRollbackException 발생

5. **같은 클래스 내부에서 @Transactional 메서드를 호출하면?**
   - 프록시를 거치지 않아 트랜잭션 설정이 적용 안 됨
   - 다른 빈으로 분리하거나 self-injection 필요

6. **REQUIRES_NEW를 반복문에서 호출하면?**
   - 매번 새 트랜잭션 생성/종료 → 성능 저하
   - 배치 작업 시 주의 필요

7. **SUPPORTS는 언제 사용하나요?**
   - 읽기 전용 메서드에서 트랜잭션이 선택적일 때
   - 하지만 일관성 문제로 실무에서는 잘 안 씀

## 참고 자료
- 김영한의 스프링 DB 1편 - 데이터 접근 핵심 원리
- Spring Framework Reference - Transaction Propagation
- https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/tx-propagation.html
