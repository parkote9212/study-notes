---
tags:
  - study
  - spring
  - web
  - validation
  - data-binding
created: 2025-02-08
---

# 검증과 데이터바인딩

## 한 줄 요약
> Spring의 검증과 데이터바인딩은 HTTP 요청 파라미터를 Java 객체로 자동 변환하고, Bean Validation(@Valid)으로 입력값을 검증하여 안전한 데이터 처리를 보장한다.

## 상세 설명

### 데이터 바인딩이란?
- **HTTP 요청 → Java 객체 변환**
- @ModelAttribute, @RequestBody 자동 처리
- 타입 변환, 포맷팅 자동 수행

### 검증(Validation)이란?
- **입력값의 유효성 검사**
- 클라이언트 검증 (JavaScript) + 서버 검증 (필수)
- Bean Validation (JSR-303, JSR-380) 표준 사용

### 왜 서버 검증이 필수인가?
```javascript
// ❌ 클라이언트 검증만으로는 불충분
// 사용자가 개발자 도구로 검증 우회 가능
// Postman 같은 도구로 직접 API 호출 가능
<script>
  if (email.length < 5) {
    alert("이메일이 너무 짧습니다");
    return false;
  }
</script>
```
→ 서버 검증은 필수!

### Bean Validation 애노테이션

| 애노테이션 | 설명 | 사용 예시 |
|-----------|------|-----------|
| **@NotNull** | null 불가 | `@NotNull String name` |
| **@NotEmpty** | null, "" 불가 | `@NotEmpty String email` |
| **@NotBlank** | null, "", " " 불가 | `@NotBlank String password` |
| **@Size** | 길이 제한 | `@Size(min=2, max=30)` |
| **@Min, @Max** | 숫자 범위 | `@Min(0) @Max(100)` |
| **@Email** | 이메일 형식 | `@Email String email` |
| **@Pattern** | 정규식 매칭 | `@Pattern(regexp="^[0-9]*$")` |
| **@Past, @Future** | 날짜 검증 | `@Past LocalDate birthDate` |
| **@Positive** | 양수 | `@Positive Integer age` |
| **@AssertTrue** | true 여부 | `@AssertTrue boolean agreed` |

### BindingResult
- **검증 오류 정보를 담는 객체**
- 파라미터 순서: `@Valid` 바로 다음에 위치
- 검증 실패 시 예외 대신 오류 정보 저장

### 데이터 바인딩 애노테이션

| 애노테이션 | 설명 | 사용 위치 |
|-----------|------|----------|
| **@ModelAttribute** | 폼 데이터, 쿼리스트링 | GET, POST (Form) |
| **@RequestBody** | HTTP Body (JSON) | POST, PUT, PATCH |
| **@RequestParam** | 쿼리 파라미터 | GET |
| **@PathVariable** | URL 경로 변수 | GET, DELETE |

## 코드 예시

```java
// 1. 기본 검증 예시
@Getter
@Setter
public class UserCreateRequest {
    
    @NotBlank(message = "이름은 필수입니다")
    @Size(min = 2, max = 30, message = "이름은 2~30자여야 합니다")
    private String name;
    
    @NotBlank(message = "이메일은 필수입니다")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;
    
    @NotBlank(message = "비밀번호는 필수입니다")
    @Pattern(
        regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$",
        message = "비밀번호는 8자 이상, 영문, 숫자, 특수문자를 포함해야 합니다"
    )
    private String password;
    
    @NotNull(message = "나이는 필수입니다")
    @Min(value = 0, message = "나이는 0 이상이어야 합니다")
    @Max(value = 150, message = "나이는 150 이하여야 합니다")
    private Integer age;
    
    @Past(message = "생년월일은 과거 날짜여야 합니다")
    private LocalDate birthDate;
    
    @AssertTrue(message = "이용약관에 동의해야 합니다")
    private Boolean agreedToTerms;
}

// 2. 컨트롤러에서 검증 처리
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // @Valid: 검증 실행
    // BindingResult: 검증 오류 정보 저장
    @PostMapping
    public ResponseEntity<?> createUser(
            @Valid @RequestBody UserCreateRequest request,
            BindingResult bindingResult) {
        
        // 검증 실패 시
        if (bindingResult.hasErrors()) {
            Map<String, String> errors = new HashMap<>();
            bindingResult.getFieldErrors().forEach(error -> {
                errors.put(error.getField(), error.getDefaultMessage());
            });
            return ResponseEntity.badRequest().body(errors);
        }
        
        // 검증 성공 시
        User user = userService.create(request);
        return ResponseEntity.ok(user);
    }
}

// 3. @ControllerAdvice로 검증 예외 통합 처리
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        ErrorResponse response = ErrorResponse.builder()
                .status(400)
                .message("입력값이 올바르지 않습니다")
                .errors(errors)
                .build();
        
        return ResponseEntity.badRequest().body(response);
    }
}

// 4. 커스텀 검증 애노테이션
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface PhoneNumber {
    String message() default "올바른 전화번호 형식이 아닙니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class PhoneNumberValidator 
        implements ConstraintValidator<PhoneNumber, String> {
    
    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("^01(?:0|1|[6-9])-(?:\\d{3}|\\d{4})-\\d{4}$");
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isEmpty()) {
            return true;  // @NotBlank와 조합 사용
        }
        return PHONE_PATTERN.matcher(value).matches();
    }
}

// 사용
public class UserRequest {
    @PhoneNumber
    private String phoneNumber;
}

// 5. 그룹 검증 (Groups)
public interface CreateGroup {}
public interface UpdateGroup {}

@Getter
@Setter
public class UserDto {
    
    @NotNull(groups = UpdateGroup.class)  // 수정 시에만 필수
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})  // 둘 다 필수
    private String name;
    
    @NotBlank(groups = CreateGroup.class)  // 생성 시에만 필수
    private String password;
}

@RestController
public class UserController {
    
    @PostMapping("/users")
    public User create(
            @Validated(CreateGroup.class) @RequestBody UserDto dto) {
        // CreateGroup 검증만 실행
    }
    
    @PutMapping("/users/{id}")
    public User update(
            @Validated(UpdateGroup.class) @RequestBody UserDto dto) {
        // UpdateGroup 검증만 실행
    }
}

// 6. @ModelAttribute vs @RequestBody
@Controller
public class FormController {
    
    // HTML Form 데이터 바인딩
    @PostMapping("/form")
    public String submitForm(
            @Valid @ModelAttribute UserForm form,
            BindingResult bindingResult,
            Model model) {
        
        if (bindingResult.hasErrors()) {
            return "form";  // 폼 페이지로 다시 이동
        }
        
        userService.create(form);
        return "redirect:/success";
    }
}

@RestController
public class ApiController {
    
    // JSON 데이터 바인딩
    @PostMapping("/api/users")
    public ResponseEntity<?> createUser(
            @Valid @RequestBody UserDto dto) {
        // JSON → Java 객체 자동 변환
        User user = userService.create(dto);
        return ResponseEntity.ok(user);
    }
}

// 7. 중첩 객체 검증
@Getter
@Setter
public class OrderRequest {
    
    @Valid  // 중첩 객체도 검증
    @NotNull
    private UserInfo userInfo;
    
    @Valid
    @NotEmpty
    private List<@Valid OrderItem> items;
}

@Getter
@Setter
public class UserInfo {
    @NotBlank
    private String name;
    
    @Email
    private String email;
}

@Getter
@Setter
public class OrderItem {
    @NotNull
    @Positive
    private Long productId;
    
    @NotNull
    @Min(1)
    private Integer quantity;
}

// 8. 커스텀 클래스 레벨 검증
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
public @interface PasswordMatches {
    String message() default "비밀번호가 일치하지 않습니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class PasswordMatchesValidator 
        implements ConstraintValidator<PasswordMatches, Object> {
    
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        UserRegistrationDto user = (UserRegistrationDto) obj;
        return user.getPassword().equals(user.getPasswordConfirm());
    }
}

@PasswordMatches
@Getter
@Setter
public class UserRegistrationDto {
    private String password;
    private String passwordConfirm;
}

// 9. 조건부 검증
@Getter
@Setter
public class PaymentRequest {
    
    @NotNull
    private PaymentType paymentType;
    
    // 신용카드 결제일 때만 필수
    @NotBlank(groups = CreditCardGroup.class)
    private String cardNumber;
    
    // 계좌이체일 때만 필수
    @NotBlank(groups = BankTransferGroup.class)
    private String accountNumber;
}

// 10. MessageSource로 메시지 국제화
// messages.properties
// NotBlank.userCreateRequest.name=이름은 필수입니다
// Size.userCreateRequest.name=이름은 {min}~{max}자여야 합니다

@Configuration
public class ValidationConfig {
    
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = 
            new ResourceBundleMessageSource();
        messageSource.setBasename("messages");
        messageSource.setDefaultEncoding("UTF-8");
        return messageSource;
    }
    
    @Bean
    public LocalValidatorFactoryBean validator() {
        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
        bean.setValidationMessageSource(messageSource());
        return bean;
    }
}
```

## 주의사항 / 함정

### 1. @Valid vs @Validated
```java
// @Valid: 자바 표준 (javax.validation.Valid)
// - 그룹 검증 불가
@PostMapping
public User create(@Valid @RequestBody UserDto dto) { }

// @Validated: 스프링 확장 (org.springframework.validation.annotation.Validated)
// - 그룹 검증 가능
@PostMapping
public User create(
        @Validated(CreateGroup.class) @RequestBody UserDto dto) { }
```

### 2. BindingResult 위치
```java
// ❌ 잘못된 위치
public ResponseEntity<?> create(
        BindingResult bindingResult,  // 먼저 오면 안 됨!
        @Valid @RequestBody UserDto dto) { }

// ✅ 올바른 위치
public ResponseEntity<?> create(
        @Valid @RequestBody UserDto dto,
        BindingResult bindingResult) {  // @Valid 바로 다음
}
```

### 3. 중첩 객체 검증 누락
```java
@Getter
@Setter
public class OrderRequest {
    // ❌ @Valid 없으면 UserInfo 내부 검증 안 됨
    @NotNull
    private UserInfo userInfo;
    
    // ✅ @Valid 추가해야 내부 필드 검증
    @Valid
    @NotNull
    private UserInfo userInfo;
}
```

### 4. 컬렉션 검증
```java
// ❌ 리스트 자체만 검증 (요소는 검증 안 됨)
@NotEmpty
private List<OrderItem> items;

// ✅ 리스트와 각 요소 모두 검증
@NotEmpty
private List<@Valid OrderItem> items;
```

### 5. null vs empty vs blank
```java
@NotNull    // null 불가, "" 가능, " " 가능
@NotEmpty   // null 불가, "" 불가, " " 가능
@NotBlank   // null 불가, "" 불가, " " 불가 (가장 엄격)
```

### 6. 기본 타입 vs Wrapper 타입
```java
// ❌ int는 @NotNull 불필요 (기본값 0)
@NotNull
private int age;  // 항상 값이 있음

// ✅ Integer는 @NotNull 필요
@NotNull
private Integer age;  // null 가능
```

### 7. @RequestBody 검증 실패 예외
```java
// @RequestBody + @Valid 실패
// → MethodArgumentNotValidException 발생

// @ModelAttribute + @Valid 실패
// → BindException 발생

// 두 예외 모두 처리 필요
@ExceptionHandler({
    MethodArgumentNotValidException.class,
    BindException.class
})
public ResponseEntity<?> handleValidationException(...) { }
```

### 8. 검증 메시지 우선순위
```
1. 애노테이션에 직접 지정: @NotBlank(message = "...")
2. messages.properties: NotBlank.필드명=...
3. 기본 메시지: must not be blank
```

## 관련 개념
- [[예외처리-전략]]
- [[DispatcherServlet-동작흐름]]
- [[필터와-인터셉터]]

## 면접 질문

1. **@Valid와 @Validated의 차이는?**
   - @Valid: 자바 표준, 그룹 검증 불가
   - @Validated: 스프링 확장, 그룹 검증 가능

2. **@NotNull, @NotEmpty, @NotBlank의 차이는?**
   - @NotNull: null만 불가
   - @NotEmpty: null, "" 불가
   - @NotBlank: null, "", " " 불가 (가장 엄격)

3. **BindingResult를 왜 사용하나요?**
   - 검증 실패 시 예외 발생 대신 오류 정보를 객체에 담음
   - 여러 필드의 오류를 한 번에 처리 가능

4. **중첩 객체 검증 시 주의할 점은?**
   - 부모 필드에 @Valid를 붙여야 자식 객체의 필드도 검증됨

5. **커스텀 검증 애노테이션을 만드는 방법은?**
   - @Constraint 애노테이션 정의
   - ConstraintValidator 구현
   - 클래스 또는 필드에 적용

6. **@ModelAttribute와 @RequestBody의 차이는?**
   - @ModelAttribute: Form 데이터, 쿼리스트링 바인딩
   - @RequestBody: JSON, XML 등 HTTP Body 바인딩

7. **검증 실패 시 발생하는 예외는?**
   - @RequestBody: MethodArgumentNotValidException
   - @ModelAttribute: BindException

## 참고 자료
- 김영한의 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술
- Bean Validation 2.0 (JSR-380)
- https://docs.spring.io/spring-framework/reference/core/validation.html
