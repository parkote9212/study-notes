---
tags:
  - study
  - spring
  - web
  - filter
  - interceptor
created: 2025-02-08
---

# 필터와 인터셉터

## 한 줄 요약
> 필터는 서블릿 컨테이너 레벨에서 요청/응답을 가공하고, 인터셉터는 스프링 MVC 레벨에서 컨트롤러 전후 처리를 담당하는 웹 계층의 공통 관심사 처리 메커니즘이다.

## 상세 설명

### 필터(Filter)와 인터셉터(Interceptor)의 차이

| 구분 | Filter | Interceptor |
|------|--------|-------------|
| **관리 주체** | 서블릿 컨테이너 | 스프링 컨테이너 |
| **적용 시점** | DispatcherServlet 전/후 | DispatcherServlet ~ Controller 사이 |
| **설정 방법** | web.xml, @WebFilter | WebMvcConfigurer |
| **스프링 빈 주입** | 제한적 | 자유로움 |
| **예외 처리** | @ControllerAdvice 불가 | @ControllerAdvice 가능 |
| **용도** | 인코딩, 보안, 로깅 | 인증/인가, 로깅 |

### 실행 순서
```
HTTP 요청
  ↓
Filter 1 (doFilter 시작)
  ↓
Filter 2 (doFilter 시작)
  ↓
DispatcherServlet
  ↓
Interceptor 1 (preHandle)
  ↓
Interceptor 2 (preHandle)
  ↓
Controller (핸들러 메서드 실행)
  ↓
Interceptor 2 (postHandle)
  ↓
Interceptor 1 (postHandle)
  ↓
View Rendering
  ↓
Interceptor 2 (afterCompletion)
  ↓
Interceptor 1 (afterCompletion)
  ↓
Filter 2 (doFilter 종료)
  ↓
Filter 1 (doFilter 종료)
  ↓
HTTP 응답
```

### Filter

#### 특징
- **서블릿 스펙의 일부** (javax.servlet.Filter)
- DispatcherServlet **이전/이후** 실행
- 스프링과 무관하게 동작 가능
- Request/Response 객체 조작 가능

#### 언제 사용하는가?
- **인코딩 처리**: UTF-8 인코딩 설정
- **보안**: XSS, CSRF 방어
- **압축/암호화**: 요청/응답 데이터 변환
- **로깅**: 모든 요청 로깅 (DispatcherServlet 도달 전)
- **인증**: JWT 토큰 검증

### Interceptor

#### 특징
- **스프링 MVC의 일부** (HandlerInterceptor)
- DispatcherServlet ~ Controller **사이** 실행
- 스프링 빈 주입 가능
- ModelAndView 접근 가능

#### 메서드
1. **preHandle()**: 컨트롤러 실행 전
   - return false: 컨트롤러 실행 중단
2. **postHandle()**: 컨트롤러 실행 후, 뷰 렌더링 전
   - 컨트롤러 예외 발생 시 호출 안 됨
3. **afterCompletion()**: 뷰 렌더링 후
   - 예외 발생해도 항상 호출 (finally 블록과 유사)

#### 언제 사용하는가?
- **인증/인가**: 로그인 체크, 권한 검증
- **로깅**: 컨트롤러 실행 시간 측정
- **공통 데이터 처리**: 공통 헤더, 사용자 정보 주입
- **API 호출 제한**: Rate Limiting

## 코드 예시

```java
// ========== Filter ==========

// 1. UTF-8 인코딩 필터
@Component
@Order(1)
public class CharacterEncodingFilter implements Filter {
    
    @Override
    public void init(FilterConfig filterConfig) {
        // 필터 초기화 (한 번만 실행)
    }
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;
        
        // 요청 전처리
        req.setCharacterEncoding("UTF-8");
        res.setCharacterEncoding("UTF-8");
        
        // 다음 필터 또는 서블릿 실행
        chain.doFilter(request, response);
        
        // 응답 후처리
    }
    
    @Override
    public void destroy() {
        // 필터 종료 시 정리 작업
    }
}

// 2. 로깅 필터
@Slf4j
@Component
@Order(2)
public class LoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        String requestURI = req.getRequestURI();
        String uuid = UUID.randomUUID().toString();
        
        try {
            log.info("REQUEST [{}][{}]", uuid, requestURI);
            chain.doFilter(request, response);
        } finally {
            log.info("RESPONSE [{}][{}]", uuid, requestURI);
        }
    }
}

// 3. 인증 필터 (JWT)
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter implements Filter {
    
    private final JwtTokenProvider jwtTokenProvider;
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest req = (HttpServletRequest) request;
        String token = resolveToken(req);
        
        if (token != null && jwtTokenProvider.validateToken(token)) {
            Authentication auth = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        
        chain.doFilter(request, response);
    }
    
    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// 4. Request/Response Wrapper로 Body 여러 번 읽기
public class CachedBodyHttpServletRequest 
        extends HttpServletRequestWrapper {
    
    private byte[] cachedBody;
    
    public CachedBodyHttpServletRequest(HttpServletRequest request) 
            throws IOException {
        super(request);
        InputStream requestInputStream = request.getInputStream();
        this.cachedBody = StreamUtils.copyToByteArray(requestInputStream);
    }
    
    @Override
    public ServletInputStream getInputStream() {
        return new CachedBodyServletInputStream(this.cachedBody);
    }
}

@Component
public class RequestCachingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) 
            throws IOException, ServletException {
        
        CachedBodyHttpServletRequest cachedRequest = 
            new CachedBodyHttpServletRequest((HttpServletRequest) request);
        
        chain.doFilter(cachedRequest, response);
    }
}

// ========== Interceptor ==========

// 1. 로그인 체크 인터셉터
@Slf4j
public class LoginCheckInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        
        String requestURI = request.getRequestURI();
        log.info("인증 체크 인터셉터 실행: {}", requestURI);
        
        HttpSession session = request.getSession(false);
        if (session == null || session.getAttribute("loginMember") == null) {
            log.info("미인증 사용자 요청");
            response.sendRedirect("/login?redirectURL=" + requestURI);
            return false;  // 컨트롤러 실행 중단
        }
        
        return true;  // 컨트롤러 실행
    }
}

// 2. 실행 시간 측정 인터셉터
@Slf4j
@Component
public class PerformanceInterceptor implements HandlerInterceptor {
    
    private static final String START_TIME = "startTime";
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) {
        long startTime = System.currentTimeMillis();
        request.setAttribute(START_TIME, startTime);
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request, 
                          HttpServletResponse response, 
                          Object handler, 
                          ModelAndView modelAndView) {
        // 컨트롤러 실행 완료 후
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) {
        long startTime = (Long) request.getAttribute(START_TIME);
        long endTime = System.currentTimeMillis();
        long executeTime = endTime - startTime;
        
        log.info("[{}] 실행 시간: {}ms", request.getRequestURI(), executeTime);
        
        if (ex != null) {
            log.error("예외 발생: ", ex);
        }
    }
}

// 3. 권한 체크 인터셉터
@Component
@RequiredArgsConstructor
public class AdminCheckInterceptor implements HandlerInterceptor {
    
    private final MemberService memberService;  // 스프링 빈 주입 가능!
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        
        // @Admin 애노테이션 확인
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Admin admin = handlerMethod.getMethodAnnotation(Admin.class);
            
            if (admin != null) {
                Member member = getCurrentMember();
                if (!member.isAdmin()) {
                    response.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return false;
                }
            }
        }
        
        return true;
    }
    
    private Member getCurrentMember() {
        // 현재 로그인한 사용자 정보 조회
        return memberService.getCurrentMember();
    }
}

// 4. 인터셉터 등록
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoginCheckInterceptor loginCheckInterceptor;
    
    @Autowired
    private PerformanceInterceptor performanceInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 실행 시간 측정 (모든 요청)
        registry.addInterceptor(performanceInterceptor)
                .order(1)
                .addPathPatterns("/**")
                .excludePathPatterns("/css/**", "/js/**", "/images/**");
        
        // 로그인 체크 (특정 경로만)
        registry.addInterceptor(loginCheckInterceptor)
                .order(2)
                .addPathPatterns("/**")
                .excludePathPatterns(
                    "/", "/members/add", "/login", "/logout",
                    "/css/**", "/*.ico", "/error"
                );
    }
}

// 5. 커스텀 애노테이션 기반 인터셉터
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    int value() default 100;  // 요청 제한 수
}

@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final Map<String, AtomicInteger> requestCounts = new ConcurrentHashMap<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            RateLimit rateLimit = handlerMethod.getMethodAnnotation(RateLimit.class);
            
            if (rateLimit != null) {
                String clientId = getClientId(request);
                AtomicInteger count = requestCounts.computeIfAbsent(
                    clientId, k -> new AtomicInteger(0)
                );
                
                if (count.incrementAndGet() > rateLimit.value()) {
                    response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                    return false;
                }
            }
        }
        
        return true;
    }
    
    private String getClientId(HttpServletRequest request) {
        return request.getRemoteAddr();
    }
}
```

## 주의사항 / 함정

### 1. Filter에서 스프링 빈 주입 제한
```java
// ❌ Filter에 @Autowired가 동작하지 않을 수 있음
@Component  // 또는 @WebFilter
public class MyFilter implements Filter {
    @Autowired
    private MyService myService;  // null일 수 있음!
}

// ✅ DelegatingFilterProxy 사용 또는 @Component 확인
@Configuration
public class FilterConfig {
    
    @Bean
    public FilterRegistrationBean<MyFilter> myFilter(MyService myService) {
        FilterRegistrationBean<MyFilter> bean = new FilterRegistrationBean<>();
        bean.setFilter(new MyFilter(myService));
        bean.addUrlPatterns("/*");
        return bean;
    }
}
```

### 2. Interceptor의 postHandle 호출 제한
```java
@Override
public void postHandle(...) {
    // ❌ 컨트롤러에서 예외 발생 시 호출되지 않음!
}

@Override
public void afterCompletion(..., Exception ex) {
    // ✅ 예외 발생해도 항상 호출됨 (finally 블록처럼)
    if (ex != null) {
        log.error("예외 발생", ex);
    }
}
```

### 3. @ResponseBody 사용 시 ViewResolver 미호출
```java
@RestController
public class ApiController {
    
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.findAll();  // JSON 직접 반환
    }
}

@Component
public class MyInterceptor implements HandlerInterceptor {
    
    @Override
    public void postHandle(..., ModelAndView modelAndView) {
        // ❌ @RestController에서는 modelAndView가 null!
        // ViewResolver를 거치지 않기 때문
    }
}
```

### 4. Interceptor 등록 시 URL 패턴 주의
```java
registry.addInterceptor(interceptor)
        .addPathPatterns("/admin/**")
        .excludePathPatterns("/admin/login");  // 제외 패턴

// URL 패턴 매칭 규칙:
// /** : 모든 경로
// /* : 한 단계 경로
// /admin/* : /admin/page (O), /admin/page/detail (X)
// /admin/** : /admin/page (O), /admin/page/detail (O)
```

### 5. Filter 순서 지정
```java
// ❌ @Component만 사용하면 순서 보장 안 됨
@Component
public class Filter1 implements Filter { }

@Component
public class Filter2 implements Filter { }

// ✅ @Order 또는 FilterRegistrationBean 사용
@Component
@Order(1)
public class Filter1 implements Filter { }

@Component
@Order(2)
public class Filter2 implements Filter { }
```

### 6. HandlerMethod 타입 체크
```java
@Override
public boolean preHandle(..., Object handler) {
    // handler는 항상 HandlerMethod가 아님!
    // 정적 리소스 요청 시 ResourceHttpRequestHandler일 수 있음
    
    if (handler instanceof HandlerMethod) {
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        // 컨트롤러 메서드 정보 접근
    }
    
    return true;
}
```

## 관련 개념
- [[DispatcherServlet-동작흐름]]
- [[예외처리-전략]]
- [[AOP-개념과-활용]]

## 면접 질문

1. **Filter와 Interceptor의 차이는?**
   - Filter: 서블릿 컨테이너 레벨, DispatcherServlet 전/후, 스프링 빈 주입 제한
   - Interceptor: 스프링 MVC 레벨, DispatcherServlet ~ Controller 사이, 스프링 빈 주입 자유

2. **Filter와 Interceptor를 각각 언제 사용하나요?**
   - Filter: 인코딩, 보안(XSS, CSRF), 로깅, 압축/암호화
   - Interceptor: 인증/인가, 로깅, 공통 데이터 처리, API 호출 제한

3. **Interceptor의 postHandle과 afterCompletion의 차이는?**
   - postHandle: 컨트롤러 정상 실행 후 호출, 예외 발생 시 호출 안 됨
   - afterCompletion: 항상 호출 (finally 블록처럼), 예외 정보 접근 가능

4. **Filter에서 Request/Response를 여러 번 읽으려면?**
   - HttpServletRequestWrapper로 감싸서 body를 캐싱
   - CachedBodyHttpServletRequest 같은 커스텀 Wrapper 사용

5. **Interceptor에서 컨트롤러 실행을 중단하려면?**
   - preHandle()에서 false 반환

6. **@RestController에서 Interceptor의 postHandle이 호출되나요?**
   - 호출은 되지만 ModelAndView가 null (ViewResolver를 거치지 않음)

7. **Filter와 Interceptor의 실행 순서는?**
   - Filter → DispatcherServlet → Interceptor → Controller → Interceptor → View → Filter

## 참고 자료
- 김영한의 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술
- Spring Framework Reference - Filters and Interceptors
- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/interceptors.html
