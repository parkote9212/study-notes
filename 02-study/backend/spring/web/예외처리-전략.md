---
tags:
  - study
  - spring
  - web
  - exception
  - error-handling
created: 2025-02-08
---

# 예외처리 전략

## 한 줄 요약
> Spring에서 예외 처리는 @ExceptionHandler, @ControllerAdvice, HandlerExceptionResolver를 활용하여 일관되고 유지보수 가능한 에러 처리 구조를 만드는 것이다.

## 상세 설명

### 왜 체계적인 예외 처리가 필요한가?
```java
// ❌ 나쁜 예: 컨트롤러마다 try-catch 중복
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        try {
            return userService.findById(id);
        } catch (UserNotFoundException e) {
            // 에러 응답 처리
        } catch (DatabaseException e) {
            // 에러 응답 처리
        }
    }
    
    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        try {
            return userService.create(user);
        } catch (DuplicateUserException e) {
            // 에러 응답 처리 (위와 동일한 로직)
        }
    }
}
```
→ 모든 컨트롤러에 예외 처리 로직 중복!

### Spring의 예외 처리 방법

#### 1. @ExceptionHandler (컨트롤러 레벨)
- 특정 컨트롤러 내에서만 적용
- 해당 컨트롤러의 예외만 처리

#### 2. @ControllerAdvice (전역 레벨)
- 모든 컨트롤러에 적용
- 애플리케이션 전역 예외 처리
- basePackages로 특정 패키지만 지정 가능

#### 3. @RestControllerAdvice
- @ControllerAdvice + @ResponseBody
- API 응답을 자동으로 JSON 변환

#### 4. HandlerExceptionResolver (저레벨)
- DispatcherServlet 레벨에서 예외 처리
- 커스터마이징 가능하지만 복잡

### 예외 처리 우선순위
```
1. @ExceptionHandler (컨트롤러 내부)
   ↓
2. @ControllerAdvice의 @ExceptionHandler
   ↓
3. Spring 기본 예외 처리
```

### HTTP 상태 코드와 예외 매핑

| 상태 코드 | 의미 | 예외 예시 |
|----------|------|----------|
| **400** | Bad Request | 잘못된 요청 파라미터 |
| **401** | Unauthorized | 인증 실패 |
| **403** | Forbidden | 권한 부족 |
| **404** | Not Found | 리소스 없음 |
| **409** | Conflict | 중복 데이터 |
| **500** | Internal Server Error | 서버 내부 오류 |

### 에러 응답 표준화
```json
{
  "timestamp": "2025-02-08T10:30:00",
  "status": 404,
  "error": "Not Found",
  "message": "User not found with id: 123",
  "path": "/api/users/123"
}
```

## 코드 예시

```java
// 1. 커스텀 예외 정의
@Getter
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
    
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

public class UserNotFoundException extends BusinessException {
    public UserNotFoundException() {
        super(ErrorCode.USER_NOT_FOUND);
    }
}

public class DuplicateUserException extends BusinessException {
    public DuplicateUserException() {
        super(ErrorCode.DUPLICATE_USER);
    }
}

// 2. ErrorCode Enum으로 에러 관리
@Getter
@RequiredArgsConstructor
public enum ErrorCode {
    // 400 Bad Request
    INVALID_INPUT_VALUE(400, "C001", "입력값이 올바르지 않습니다."),
    INVALID_TYPE_VALUE(400, "C002", "입력 타입이 올바르지 않습니다."),
    
    // 401 Unauthorized
    UNAUTHORIZED(401, "A001", "인증이 필요합니다."),
    INVALID_TOKEN(401, "A002", "유효하지 않은 토큰입니다."),
    
    // 403 Forbidden
    FORBIDDEN(403, "A003", "권한이 없습니다."),
    
    // 404 Not Found
    USER_NOT_FOUND(404, "U001", "사용자를 찾을 수 없습니다."),
    
    // 409 Conflict
    DUPLICATE_USER(409, "U002", "이미 존재하는 사용자입니다."),
    
    // 500 Internal Server Error
    INTERNAL_SERVER_ERROR(500, "S001", "서버 내부 오류가 발생했습니다.");
    
    private final int status;
    private final String code;
    private final String message;
}

// 3. 에러 응답 DTO
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ErrorResponse {
    private String message;
    private String code;
    private int status;
    private LocalDateTime timestamp;
    private List<FieldError> errors;
    
    @Builder
    public ErrorResponse(ErrorCode errorCode) {
        this.message = errorCode.getMessage();
        this.code = errorCode.getCode();
        this.status = errorCode.getStatus();
        this.timestamp = LocalDateTime.now();
        this.errors = new ArrayList<>();
    }
    
    public static ErrorResponse of(ErrorCode errorCode) {
        return ErrorResponse.builder()
                .errorCode(errorCode)
                .build();
    }
    
    public static ErrorResponse of(ErrorCode errorCode, 
                                   BindingResult bindingResult) {
        ErrorResponse response = ErrorResponse.of(errorCode);
        response.errors = FieldError.of(bindingResult);
        return response;
    }
    
    @Getter
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public static class FieldError {
        private String field;
        private String value;
        private String reason;
        
        @Builder
        private FieldError(String field, String value, String reason) {
            this.field = field;
            this.value = value;
            this.reason = reason;
        }
        
        public static List<FieldError> of(BindingResult bindingResult) {
            return bindingResult.getFieldErrors().stream()
                    .map(error -> FieldError.builder()
                            .field(error.getField())
                            .value(error.getRejectedValue() == null ? 
                                   "" : error.getRejectedValue().toString())
                            .reason(error.getDefaultMessage())
                            .build())
                    .collect(Collectors.toList());
        }
    }
}

// 4. @ControllerAdvice로 전역 예외 처리
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 비즈니스 예외 처리
    @ExceptionHandler(BusinessException.class)
    protected ResponseEntity<ErrorResponse> handleBusinessException(
            BusinessException e) {
        log.error("BusinessException: ", e);
        ErrorCode errorCode = e.getErrorCode();
        ErrorResponse response = ErrorResponse.of(errorCode);
        return ResponseEntity
                .status(errorCode.getStatus())
                .body(response);
    }
    
    // @Valid 검증 실패
    @ExceptionHandler(MethodArgumentNotValidException.class)
    protected ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException e) {
        log.error("MethodArgumentNotValidException: ", e);
        ErrorResponse response = ErrorResponse.of(
            ErrorCode.INVALID_INPUT_VALUE, 
            e.getBindingResult()
        );
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(response);
    }
    
    // @RequestParam 바인딩 실패
    @ExceptionHandler(BindException.class)
    protected ResponseEntity<ErrorResponse> handleBindException(
            BindException e) {
        log.error("BindException: ", e);
        ErrorResponse response = ErrorResponse.of(
            ErrorCode.INVALID_INPUT_VALUE, 
            e.getBindingResult()
        );
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(response);
    }
    
    // Enum 타입 바인딩 실패
    @ExceptionHandler(HttpMessageNotReadableException.class)
    protected ResponseEntity<ErrorResponse> handleHttpMessageNotReadableException(
            HttpMessageNotReadableException e) {
        log.error("HttpMessageNotReadableException: ", e);
        ErrorResponse response = ErrorResponse.of(ErrorCode.INVALID_TYPE_VALUE);
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(response);
    }
    
    // 인증 실패
    @ExceptionHandler(AuthenticationException.class)
    protected ResponseEntity<ErrorResponse> handleAuthenticationException(
            AuthenticationException e) {
        log.error("AuthenticationException: ", e);
        ErrorResponse response = ErrorResponse.of(ErrorCode.UNAUTHORIZED);
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(response);
    }
    
    // 권한 부족
    @ExceptionHandler(AccessDeniedException.class)
    protected ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException e) {
        log.error("AccessDeniedException: ", e);
        ErrorResponse response = ErrorResponse.of(ErrorCode.FORBIDDEN);
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(response);
    }
    
    // 그 외 모든 예외
    @ExceptionHandler(Exception.class)
    protected ResponseEntity<ErrorResponse> handleException(Exception e) {
        log.error("Exception: ", e);
        ErrorResponse response = ErrorResponse.of(
            ErrorCode.INTERNAL_SERVER_ERROR
        );
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(response);
    }
}

// 5. 컨트롤러에서 예외 던지기
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    @GetMapping("/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        // 예외를 던지면 GlobalExceptionHandler가 처리
        User user = userService.findById(id)
                .orElseThrow(UserNotFoundException::new);
        return UserResponse.from(user);
    }
    
    @PostMapping
    public UserResponse createUser(@Valid @RequestBody UserCreateRequest request) {
        // @Valid 검증 실패 → MethodArgumentNotValidException
        // 중복 → DuplicateUserException
        User user = userService.create(request);
        return UserResponse.from(user);
    }
}

// 6. 특정 컨트롤러에만 적용하는 @ExceptionHandler
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    // 이 컨트롤러에서만 AdminException 처리
    @ExceptionHandler(AdminException.class)
    public ResponseEntity<ErrorResponse> handleAdminException(
            AdminException e) {
        ErrorResponse response = ErrorResponse.of(e.getErrorCode());
        return ResponseEntity
                .status(e.getErrorCode().getStatus())
                .body(response);
    }
    
    @GetMapping("/users")
    public List<UserResponse> getUsers() {
        // ...
    }
}

// 7. 특정 패키지에만 적용하는 @ControllerAdvice
@RestControllerAdvice(basePackages = "com.example.api")
public class ApiExceptionHandler {
    // API 패키지의 컨트롤러 예외만 처리
}

// 8. ResponseStatusException (간단한 예외)
@GetMapping("/{id}")
public User getUser(@PathVariable Long id) {
    return userRepository.findById(id)
            .orElseThrow(() -> new ResponseStatusException(
                HttpStatus.NOT_FOUND, 
                "User not found"
            ));
}

// 9. @ResponseStatus로 상태 코드 지정
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

// 10. 비동기 예외 처리
@ControllerAdvice
public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler {
    
    @Override
    public void handleUncaughtException(
            Throwable ex, 
            Method method, 
            Object... params) {
        log.error("비동기 메서드 예외 발생: {}", method.getName(), ex);
    }
}

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}
```

## 주의사항 / 함정

### 1. 예외 계층 구조 설계
```java
// ❌ 모든 예외를 RuntimeException으로 직접 상속
public class UserException extends RuntimeException { }
public class OrderException extends RuntimeException { }

// ✅ 비즈니스 예외의 공통 부모 클래스 생성
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
}

public class UserException extends BusinessException { }
public class OrderException extends BusinessException { }
```

### 2. @ExceptionHandler 우선순위
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 구체적인 예외가 먼저 처리됨
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<?> handleUserNotFound(UserNotFoundException e) {
        // 이것이 먼저 실행
    }
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<?> handleBusiness(BusinessException e) {
        // UserNotFoundException은 여기까지 오지 않음
    }
}
```

### 3. Checked Exception vs Unchecked Exception
```java
// ❌ Checked Exception: try-catch 강제
public User findById(Long id) throws UserNotFoundException {  
    // 호출하는 쪽에서 무조건 처리해야 함
}

// ✅ Unchecked Exception: 선택적 처리 (권장)
public User findById(Long id) {
    return userRepository.findById(id)
            .orElseThrow(UserNotFoundException::new);
}
```

### 4. @Valid와 @Validated 차이
```java
// @Valid: 자바 표준 (javax.validation)
@PostMapping
public UserResponse create(@Valid @RequestBody UserRequest request) {
    // 검증 실패 → MethodArgumentNotValidException
}

// @Validated: 스프링 확장 (그룹 검증 지원)
@PostMapping
public UserResponse create(
        @Validated(CreateGroup.class) @RequestBody UserRequest request) {
    // 그룹별 검증 가능
}
```

### 5. ResponseEntity vs @ResponseStatus
```java
// @ResponseStatus: 항상 같은 상태 코드
@ExceptionHandler(UserNotFoundException.class)
@ResponseStatus(HttpStatus.NOT_FOUND)
public ErrorResponse handle(UserNotFoundException e) {
    return ErrorResponse.of(e.getErrorCode());
}

// ResponseEntity: 동적 상태 코드 가능 (권장)
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ErrorResponse> handle(BusinessException e) {
    ErrorCode errorCode = e.getErrorCode();
    return ResponseEntity
            .status(errorCode.getStatus())
            .body(ErrorResponse.of(errorCode));
}
```

### 6. 순환 참조 주의
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleException(Exception e) {
        // ❌ 여기서 또 예외 발생하면 무한 루프!
        throw new RuntimeException("에러 처리 중 에러");
    }
}
```

### 7. 로깅 레벨 구분
```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<?> handle(BusinessException e) {
    // 비즈니스 예외는 warn (예상 가능한 오류)
    log.warn("Business exception: {}", e.getMessage());
    // ...
}

@ExceptionHandler(Exception.class)
public ResponseEntity<?> handle(Exception e) {
    // 시스템 예외는 error (예상 못한 오류)
    log.error("Unexpected exception", e);
    // ...
}
```

## 관련 개념
- [[DispatcherServlet-동작흐름]]
- [[필터와-인터셉터]]
- [[검증과-데이터바인딩]]

## 면접 질문

1. **@ExceptionHandler와 @ControllerAdvice의 차이는?**
   - @ExceptionHandler: 특정 컨트롤러 내에서만 적용
   - @ControllerAdvice: 전역적으로 모든 컨트롤러에 적용

2. **@RestControllerAdvice와 @ControllerAdvice의 차이는?**
   - @RestControllerAdvice = @ControllerAdvice + @ResponseBody
   - REST API에서 JSON 응답 자동 변환

3. **예외 처리 우선순위는?**
   - 컨트롤러 내 @ExceptionHandler → @ControllerAdvice → Spring 기본 처리

4. **Checked Exception과 Unchecked Exception 중 어느 것을 사용해야 하나요?**
   - Unchecked Exception 권장 (RuntimeException 상속)
   - 비즈니스 예외는 복구 불가능한 경우가 많아 강제 처리가 번거로움

5. **ErrorCode를 Enum으로 관리하는 이유는?**
   - 에러 코드 중복 방지
   - 에러 메시지 일관성 유지
   - 유지보수 용이 (한 곳에서 관리)

6. **@Valid 검증 실패 시 어떤 예외가 발생하나요?**
   - @RequestBody: MethodArgumentNotValidException
   - @ModelAttribute: BindException

7. **HandlerExceptionResolver를 직접 구현하는 경우는?**
   - 매우 특수한 예외 처리가 필요할 때
   - 대부분 @ControllerAdvice로 충분

## 참고 자료
- 김영한의 스프링 MVC 2편 - 백엔드 웹 개발 활용 기술
- Spring Framework Reference - Exception Handling
- https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-exceptionhandler.html
