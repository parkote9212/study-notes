---
tags:
  - study
  - spring
  - advanced
  - event
  - architecture
created: 2025-02-08
---

# 이벤트 기반 아키텍처

## 한 줄 요약
> Spring Event는 애플리케이션 컴포넌트 간 느슨한 결합을 제공하여, 이벤트 발행자와 구독자가 서로를 직접 알지 못해도 통신할 수 있게 하는 패턴이다.

## 상세 설명

### 이벤트 기반 아키텍처란?
- **발행-구독 패턴**(Publish-Subscribe)
- **발행자(Publisher)**와 **구독자(Subscriber)** 분리
- **느슨한 결합**(Loose Coupling)

### 왜 이벤트를 사용하는가?
```java
// ❌ 강한 결합: OrderService가 모든 것을 알아야 함
@Service
public class OrderService {
    private final EmailService emailService;
    private final SmsService smsService;
    private final CouponService couponService;
    private final PointService pointService;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        emailService.sendOrderEmail(order);        // 의존
        smsService.sendOrderSms(order);            // 의존
        couponService.issueCoupon(order);          // 의존
        pointService.accumulatePoints(order);      // 의존
        // 새로운 기능 추가 시 OrderService 수정 필요!
    }
}

// ✅ 느슨한 결합: 이벤트만 발행
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 이벤트만 발행 (누가 처리하는지 몰라도 됨)
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}
```

### Spring Event 장점
1. **느슨한 결합**: 발행자는 구독자를 몰라도 됨
2. **단일 책임 원칙**: 각 컴포넌트가 자신의 역할만 수행
3. **확장 용이**: 새 리스너 추가해도 발행자 수정 불필요
4. **비동기 처리**: @Async와 조합 가능

### Spring Event 주요 애노테이션
- **@EventListener**: 이벤트 리스너 등록
- **@TransactionalEventListener**: 트랜잭션 단계별 이벤트 처리
- **@Async**: 비동기 이벤트 처리

## 코드 예시

```java
// 1. 기본 이벤트 클래스
@Getter
@RequiredArgsConstructor
public class OrderCreatedEvent {
    private final Long orderId;
    private final Long userId;
    private final int amount;
}

// 2. 이벤트 발행
@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 이벤트 발행
        OrderCreatedEvent event = new OrderCreatedEvent(
            order.getId(),
            order.getUserId(),
            order.getAmount()
        );
        eventPublisher.publishEvent(event);
    }
}

// 3. 이벤트 리스너 (동기)
@Component
@Slf4j
public class OrderEventListener {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        log.info("주문 생성 이벤트 수신: {}", event.getOrderId());
        // 이벤트 처리 로직
    }
}

// 4. 여러 리스너
@Component
public class EmailEventListener {
    
    @EventListener
    public void sendOrderEmail(OrderCreatedEvent event) {
        // 주문 확인 이메일 발송
        emailService.sendOrderConfirmation(event.getOrderId());
    }
}

@Component
public class SmsEventListener {
    
    @EventListener
    public void sendOrderSms(OrderCreatedEvent event) {
        // 주문 확인 SMS 발송
        smsService.sendOrderNotification(event.getUserId());
    }
}

@Component
public class PointEventListener {
    
    @EventListener
    public void accumulatePoints(OrderCreatedEvent event) {
        // 포인트 적립
        pointService.add(event.getUserId(), event.getAmount() / 10);
    }
}

// 5. @TransactionalEventListener (트랜잭션 단계별)
@Component
@Slf4j
public class TransactionalEventListener {
    
    // 트랜잭션 커밋 후 (가장 많이 사용)
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void afterCommit(OrderCreatedEvent event) {
        log.info("트랜잭션 커밋 후 실행");
        // 외부 API 호출, 이메일 발송 등
    }
    
    // 트랜잭션 커밋 전
    @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
    public void beforeCommit(OrderCreatedEvent event) {
        log.info("트랜잭션 커밋 전 실행");
        // 추가 검증, 로깅 등
    }
    
    // 트랜잭션 롤백 후
    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void afterRollback(OrderCreatedEvent event) {
        log.error("트랜잭션 롤백됨");
        // 보상 처리, 알림 등
    }
    
    // 트랜잭션 완료 후 (커밋/롤백 상관없이)
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)
    public void afterCompletion(OrderCreatedEvent event) {
        log.info("트랜잭션 완료");
        // 리소스 정리 등
    }
}

// 6. 비동기 이벤트 처리
@Component
@Slf4j
public class AsyncEventListener {
    
    @Async
    @EventListener
    public void handleAsync(OrderCreatedEvent event) {
        log.info("비동기 이벤트 처리: {}", Thread.currentThread().getName());
        // 시간이 오래 걸리는 작업
    }
    
    // 비동기 + 트랜잭션
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleAsyncAfterCommit(OrderCreatedEvent event) {
        log.info("커밋 후 비동기 처리");
        // 외부 API 호출
    }
}

// 7. 조건부 이벤트 처리
@Component
public class ConditionalEventListener {
    
    // SpEL로 조건 지정
    @EventListener(condition = "#event.amount > 10000")
    public void handleLargeOrder(OrderCreatedEvent event) {
        // 10,000원 이상 주문만 처리
        sendSpecialNotification(event);
    }
    
    @EventListener(condition = "#event.userId == 'VIP123'")
    public void handleVipOrder(OrderCreatedEvent event) {
        // VIP 회원 주문만 처리
        giveExtraPoints(event);
    }
}

// 8. 이벤트 체인 (한 이벤트가 다른 이벤트 발생)
@Component
@RequiredArgsConstructor
public class PaymentEventListener {
    
    private final ApplicationEventPublisher eventPublisher;
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 결제 처리
        processPayment(event);
        
        // 결제 완료 이벤트 발생
        eventPublisher.publishEvent(
            new PaymentCompletedEvent(event.getOrderId())
        );
    }
}

@Component
public class DeliveryEventListener {
    
    @EventListener
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        // 배송 시작
        startDelivery(event.getOrderId());
    }
}

// 9. 제네릭 이벤트
public class EntityCreatedEvent<T> {
    private final T entity;
    private final LocalDateTime createdAt;
    
    public EntityCreatedEvent(T entity) {
        this.entity = entity;
        this.createdAt = LocalDateTime.now();
    }
}

@Component
public class GenericEventListener {
    
    @EventListener
    public void handleUserCreated(EntityCreatedEvent<User> event) {
        User user = event.getEntity();
        // 사용자 생성 처리
    }
    
    @EventListener
    public void handleProductCreated(EntityCreatedEvent<Product> event) {
        Product product = event.getEntity();
        // 상품 생성 처리
    }
}

// 10. 이벤트 우선순위
@Component
public class OrderedEventListener {
    
    @Order(1)
    @EventListener
    public void firstListener(OrderCreatedEvent event) {
        // 가장 먼저 실행
    }
    
    @Order(2)
    @EventListener
    public void secondListener(OrderCreatedEvent event) {
        // 두 번째 실행
    }
}

// 11. 예외 처리
@Component
@Slf4j
public class ErrorHandlingEventListener {
    
    @EventListener
    public void handle(OrderCreatedEvent event) {
        try {
            riskyOperation(event);
        } catch (Exception e) {
            log.error("이벤트 처리 중 에러", e);
            // 에러를 던지지 않으면 다른 리스너들은 계속 실행됨
        }
    }
}

// 12. 이벤트 필터링
@Component
public class FilteredEventListener {
    
    @EventListener
    public void handleEvent(ApplicationEvent event) {
        if (event instanceof OrderCreatedEvent) {
            OrderCreatedEvent orderEvent = (OrderCreatedEvent) event;
            // 처리
        } else if (event instanceof PaymentCompletedEvent) {
            PaymentCompletedEvent paymentEvent = (PaymentCompletedEvent) event;
            // 처리
        }
    }
}

// 13. 실무 패턴: 이벤트 기록
@Component
@RequiredArgsConstructor
public class EventAuditListener {
    
    private final EventLogRepository eventLogRepository;
    
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void recordEvent(OrderCreatedEvent event) {
        EventLog log = EventLog.builder()
                .eventType("ORDER_CREATED")
                .eventData(toJson(event))
                .timestamp(LocalDateTime.now())
                .build();
        
        eventLogRepository.save(log);
    }
}

// 14. 이벤트 재시도
@Component
@Slf4j
public class RetryEventListener {
    
    @Retryable(
        value = {ApiException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000)
    )
    @EventListener
    public void handleWithRetry(OrderCreatedEvent event) {
        // API 호출 실패 시 3번까지 재시도
        externalApi.notify(event);
    }
    
    @Recover
    public void recover(ApiException e, OrderCreatedEvent event) {
        log.error("재시도 실패, 이벤트 저장: {}", event.getOrderId());
        // DLQ(Dead Letter Queue)에 저장 등
    }
}

// 15. 커스텀 이벤트 발행자
@Component
@RequiredArgsConstructor
public class OrderEventPublisher {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public void publishOrderCreated(Order order) {
        OrderCreatedEvent event = new OrderCreatedEvent(
            order.getId(),
            order.getUserId(),
            order.getAmount()
        );
        eventPublisher.publishEvent(event);
    }
    
    public void publishOrderCancelled(Long orderId) {
        eventPublisher.publishEvent(new OrderCancelledEvent(orderId));
    }
}

// 16. 이벤트 저장소 패턴
@Entity
@Table(name = "event_store")
@Getter
@NoArgsConstructor
public class EventStore {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String eventType;
    private String aggregateId;
    
    @Column(columnDefinition = "TEXT")
    private String payload;
    
    private LocalDateTime occurredAt;
    private boolean published;
}

@Component
@RequiredArgsConstructor
public class EventStorePublisher {
    
    private final EventStoreRepository eventStoreRepository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Scheduled(fixedDelay = 5000)  // 5초마다
    public void publishStoredEvents() {
        List<EventStore> events = eventStoreRepository
                .findByPublishedFalse();
        
        for (EventStore event : events) {
            try {
                // 이벤트 재발행
                Object domainEvent = deserialize(event.getPayload());
                eventPublisher.publishEvent(domainEvent);
                
                event.setPublished(true);
                eventStoreRepository.save(event);
            } catch (Exception e) {
                log.error("이벤트 발행 실패", e);
            }
        }
    }
}
```

## 주의사항 / 함정

### 1. 동기 이벤트의 트랜잭션
```java
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);
    eventPublisher.publishEvent(event);
    // 이벤트 리스너도 같은 트랜잭션에서 실행
    // 리스너에서 예외 발생 시 전체 롤백!
}

// ✅ 트랜잭션 분리
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void handle(OrderCreatedEvent event) {
    // 커밋 후 실행, 별도 트랜잭션
}
```

### 2. 이벤트 순서 보장 안 됨
```java
// ❌ 리스너 실행 순서 불확실
@EventListener
public void listener1(OrderCreatedEvent event) { }

@EventListener
public void listener2(OrderCreatedEvent event) { }

// ✅ @Order로 순서 지정
@Order(1)
@EventListener
public void listener1(OrderCreatedEvent event) { }

@Order(2)
@EventListener
public void listener2(OrderCreatedEvent event) { }
```

### 3. 비동기 이벤트의 예외
```java
@Async
@EventListener
public void handle(OrderCreatedEvent event) {
    throw new RuntimeException();
    // ❌ 예외가 발행자에게 전달 안 됨!
}

// ✅ 예외 처리 필수
@Async
@EventListener
public void handle(OrderCreatedEvent event) {
    try {
        // 처리
    } catch (Exception e) {
        log.error("이벤트 처리 실패", e);
        // 보상 처리
    }
}
```

### 4. 이벤트 무한 루프
```java
// ❌ 무한 루프 발생
@EventListener
public void handle(OrderCreatedEvent event) {
    eventPublisher.publishEvent(event);  // 자기 자신 다시 발행!
}

// ✅ 이벤트 타입 변경 또는 조건 체크
@EventListener
public void handle(OrderCreatedEvent event) {
    if (!event.isProcessed()) {
        // 처리
        eventPublisher.publishEvent(new OrderProcessedEvent(event));
    }
}
```

### 5. 트랜잭션 없이 @TransactionalEventListener
```java
// ❌ 트랜잭션이 없으면 이벤트 발행 안 됨
public void createOrder(Order order) {  // @Transactional 없음
    orderRepository.save(order);
    eventPublisher.publishEvent(event);
    // @TransactionalEventListener가 실행 안 됨!
}

// ✅ @Transactional 필수
@Transactional
public void createOrder(Order order) {
    orderRepository.save(order);
    eventPublisher.publishEvent(event);
}
```

### 6. 이벤트 손실
```java
// ❌ 이벤트 발행 후 애플리케이션 종료 시 손실
@Async
@EventListener
public void handle(OrderCreatedEvent event) {
    // 처리 중 서버 재시작 → 이벤트 손실!
}

// ✅ 이벤트 저장소 패턴 사용
@EventListener
public void handle(OrderCreatedEvent event) {
    eventStoreRepository.save(new EventStore(event));
    // 나중에 재처리 가능
}
```

### 7. 이벤트 리스너가 너무 많음
```java
// ❌ 하나의 이벤트에 10개 이상 리스너
// → 성능 저하, 디버깅 어려움

// ✅ 이벤트 세분화
OrderCreatedEvent → EmailEvent, SmsEvent, PointEvent
```

## 관련 개념
- [[비동기처리-Async]]
- [[트랜잭션-관리]]
- [[AOP-개념과-활용]]

## 면접 질문

1. **Spring Event의 장점은?**
   - 느슨한 결합 (Loose Coupling)
   - 단일 책임 원칙
   - 확장 용이성

2. **@EventListener와 @TransactionalEventListener의 차이는?**
   - @EventListener: 즉시 실행
   - @TransactionalEventListener: 트랜잭션 단계별 실행 (커밋 전/후 등)

3. **동기 이벤트와 비동기 이벤트의 차이는?**
   - 동기: 같은 스레드, 같은 트랜잭션
   - 비동기: 다른 스레드, 다른 트랜잭션 (@Async 사용)

4. **이벤트 손실을 방지하는 방법은?**
   - 이벤트 저장소 패턴 (Event Store)
   - 메시지 큐 사용 (Kafka, RabbitMQ)
   - 재시도 메커니즘

5. **언제 이벤트를 사용하나요?**
   - 컴포넌트 간 결합도를 낮추고 싶을 때
   - 부가 기능 추가가 빈번할 때
   - 비동기 처리가 필요할 때

6. **TransactionPhase의 종류는?**
   - BEFORE_COMMIT: 커밋 전
   - AFTER_COMMIT: 커밋 후 (가장 많이 사용)
   - AFTER_ROLLBACK: 롤백 후
   - AFTER_COMPLETION: 완료 후 (커밋/롤백 상관없이)

7. **이벤트 우선순위는 어떻게 지정하나요?**
   - @Order 애노테이션 사용
   - 숫자가 작을수록 먼저 실행

## 참고 자료
- Spring Framework Reference - Application Events
- DDD - Domain Events
- https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events
