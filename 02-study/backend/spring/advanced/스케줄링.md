---
tags:
  - study
  - spring
  - advanced
  - scheduling
  - cron
created: 2025-02-08
---

# 스케줄링

## 한 줄 요약
> Spring Scheduling은 특정 시간이나 주기마다 자동으로 메서드를 실행하여, 정기적인 배치 작업이나 반복 작업을 코드만으로 간편하게 구현할 수 있게 한다.

## 상세 설명

### 스케줄링이란?
- **정해진 시간**에 **자동으로** 작업 실행
- **반복 작업** 자동화
- **배치 작업**, **정기 점검**, **데이터 동기화** 등에 활용

### 왜 스케줄링이 필요한가?
```java
// ❌ 수동 실행: 매일 자정에 개발자가 직접 실행
public void generateDailyReport() {
    // 일일 리포트 생성
}

// ✅ 스케줄링: 자동 실행
@Scheduled(cron = "0 0 0 * * *")  // 매일 자정 자동 실행
public void generateDailyReport() {
    // 일일 리포트 생성
}
```

### 스케줄링 사용 시나리오
- **일일 배치**: 매일 자정 통계 생성
- **주기적 동기화**: 10분마다 외부 API 호출
- **데이터 정리**: 매주 일요일 오래된 데이터 삭제
- **알림 발송**: 매시간 알림 체크
- **캐시 갱신**: 5분마다 캐시 업데이트

### Spring Scheduling 방식

| 방식 | 설명 | 예시 |
|-----|------|------|
| **fixedRate** | 이전 시작 시점부터 고정 주기 | 매 3초마다 |
| **fixedDelay** | 이전 종료 시점부터 고정 딜레이 | 종료 후 3초 뒤 |
| **cron** | Cron 표현식으로 정확한 시간 지정 | 매일 자정 |
| **initialDelay** | 최초 실행 딜레이 | 시작 10초 후 |

### Cron 표현식 구조
```
초 분 시 일 월 요일

0  0  0  *  *  *    →  매일 자정 (00:00:00)
0  0  9  *  *  MON  →  매주 월요일 오전 9시
0  */10 * * * *     →  매 10분마다
0  0  0  1  *  *    →  매월 1일 자정
```

## 코드 예시

```java
// 1. @EnableScheduling 활성화
@EnableScheduling
@Configuration
public class SchedulingConfig {
    
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10);  // 스레드 풀 크기
        scheduler.setThreadNamePrefix("scheduled-");
        scheduler.initialize();
        return scheduler;
    }
}

// 2. fixedRate (고정 주기)
@Component
@Slf4j
public class FixedRateScheduler {
    
    @Scheduled(fixedRate = 3000)  // 3초마다 (시작 시점 기준)
    public void runEvery3Seconds() {
        log.info("3초마다 실행: {}", LocalDateTime.now());
        // 이전 실행이 끝나지 않아도 3초마다 시작
    }
    
    @Scheduled(fixedRateString = "${schedule.fixed-rate}")  // 설정 파일에서 읽기
    public void runFromProperties() {
        log.info("설정 파일 기반 실행");
    }
}

// 3. fixedDelay (고정 딜레이)
@Component
@Slf4j
public class FixedDelayScheduler {
    
    @Scheduled(fixedDelay = 3000)  // 종료 후 3초 뒤 (종료 시점 기준)
    public void runAfter3Seconds() {
        log.info("작업 시작: {}", LocalDateTime.now());
        
        try {
            Thread.sleep(2000);  // 2초 작업
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        log.info("작업 종료: {}", LocalDateTime.now());
        // 종료 후 3초 뒤에 다시 시작
    }
}

// 4. initialDelay (최초 실행 딜레이)
@Component
@Slf4j
public class InitialDelayScheduler {
    
    @Scheduled(
        initialDelay = 10000,  // 애플리케이션 시작 10초 후 최초 실행
        fixedRate = 5000       // 이후 5초마다 실행
    )
    public void runWithInitialDelay() {
        log.info("최초 딜레이 후 실행");
    }
}

// 5. cron 표현식
@Component
@Slf4j
public class CronScheduler {
    
    // 매일 자정
    @Scheduled(cron = "0 0 0 * * *")
    public void runAtMidnight() {
        log.info("매일 자정 실행");
    }
    
    // 매주 월요일 오전 9시
    @Scheduled(cron = "0 0 9 * * MON")
    public void runMondayMorning() {
        log.info("월요일 오전 9시 실행");
    }
    
    // 매 10분마다
    @Scheduled(cron = "0 */10 * * * *")
    public void runEvery10Minutes() {
        log.info("10분마다 실행");
    }
    
    // 평일 오전 9시부터 오후 6시까지 1시간마다
    @Scheduled(cron = "0 0 9-18 * * MON-FRI")
    public void runBusinessHours() {
        log.info("평일 업무시간 실행");
    }
    
    // 매월 1일 자정
    @Scheduled(cron = "0 0 0 1 * *")
    public void runFirstDayOfMonth() {
        log.info("매월 1일 실행");
    }
    
    // 설정 파일에서 cron 읽기
    @Scheduled(cron = "${schedule.cron}")
    public void runFromPropertiesCron() {
        log.info("설정 파일 cron 실행");
    }
}

// application.yml
// schedule:
//   cron: "0 0 2 * * *"  # 매일 새벽 2시

// 6. 실무 패턴: 일일 배치
@Component
@RequiredArgsConstructor
@Slf4j
public class DailyBatchScheduler {
    
    private final OrderRepository orderRepository;
    private final ReportService reportService;
    
    @Scheduled(cron = "0 0 0 * * *")  // 매일 자정
    @Transactional
    public void generateDailyReport() {
        log.info("일일 리포트 생성 시작");
        
        LocalDate yesterday = LocalDate.now().minusDays(1);
        List<Order> orders = orderRepository.findByDate(yesterday);
        
        Report report = reportService.generate(orders);
        reportService.save(report);
        
        log.info("일일 리포트 생성 완료: {} 건", orders.size());
    }
}

// 7. 실무 패턴: 오래된 데이터 삭제
@Component
@RequiredArgsConstructor
@Slf4j
public class DataCleanupScheduler {
    
    private final LogRepository logRepository;
    
    @Scheduled(cron = "0 0 3 * * SUN")  // 매주 일요일 새벽 3시
    @Transactional
    public void deleteOldLogs() {
        log.info("오래된 로그 삭제 시작");
        
        LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);
        int deletedCount = logRepository.deleteByCreatedAtBefore(thirtyDaysAgo);
        
        log.info("오래된 로그 삭제 완료: {} 건", deletedCount);
    }
}

// 8. 실무 패턴: 주기적 동기화
@Component
@RequiredArgsConstructor
@Slf4j
public class SyncScheduler {
    
    private final ExternalApiClient apiClient;
    private final ProductRepository productRepository;
    
    @Scheduled(fixedDelay = 600000)  // 10분마다 (종료 후 10분 뒤)
    public void syncProducts() {
        log.info("상품 동기화 시작");
        
        try {
            List<Product> products = apiClient.fetchProducts();
            productRepository.saveAll(products);
            
            log.info("상품 동기화 완료: {} 건", products.size());
        } catch (Exception e) {
            log.error("상품 동기화 실패", e);
        }
    }
}

// 9. 조건부 스케줄링
@Component
@Slf4j
public class ConditionalScheduler {
    
    @Value("${schedule.enabled:false}")
    private boolean scheduleEnabled;
    
    @Scheduled(fixedRate = 5000)
    public void conditionalTask() {
        if (!scheduleEnabled) {
            return;  // 스케줄 비활성화 시 실행 안 함
        }
        
        log.info("조건부 스케줄 실행");
    }
}

// 10. 동적 스케줄링
@Component
@RequiredArgsConstructor
public class DynamicScheduler {
    
    private final TaskScheduler taskScheduler;
    private ScheduledFuture<?> scheduledTask;
    
    public void startSchedule(String cronExpression) {
        if (scheduledTask != null) {
            scheduledTask.cancel(false);  // 기존 스케줄 취소
        }
        
        scheduledTask = taskScheduler.schedule(
            this::executeTask,
            new CronTrigger(cronExpression)
        );
        
        log.info("스케줄 시작: {}", cronExpression);
    }
    
    public void stopSchedule() {
        if (scheduledTask != null) {
            scheduledTask.cancel(false);
            log.info("스케줄 중지");
        }
    }
    
    private void executeTask() {
        log.info("동적 스케줄 실행");
    }
}

// 11. 스케줄 모니터링
@Component
@Slf4j
public class ScheduleMonitor {
    
    private final AtomicInteger executionCount = new AtomicInteger(0);
    private final AtomicLong totalExecutionTime = new AtomicLong(0);
    
    @Scheduled(fixedRate = 60000)  // 1분마다
    public void monitoredTask() {
        long startTime = System.currentTimeMillis();
        
        try {
            // 작업 실행
            executeBusinessLogic();
            
            executionCount.incrementAndGet();
        } catch (Exception e) {
            log.error("스케줄 실행 실패", e);
        } finally {
            long executionTime = System.currentTimeMillis() - startTime;
            totalExecutionTime.addAndGet(executionTime);
            
            log.info("실행 시간: {}ms, 총 실행 횟수: {}", 
                    executionTime, executionCount.get());
        }
    }
    
    private void executeBusinessLogic() {
        // 비즈니스 로직
    }
}

// 12. 병렬 스케줄링
@Configuration
@EnableScheduling
public class ParallelSchedulingConfig {
    
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(10);  // 10개 스레드 동시 실행 가능
        scheduler.setThreadNamePrefix("parallel-");
        scheduler.setWaitForTasksToCompleteOnShutdown(true);
        scheduler.setAwaitTerminationSeconds(20);
        scheduler.initialize();
        return scheduler;
    }
}

@Component
@Slf4j
public class ParallelScheduler {
    
    @Scheduled(fixedRate = 1000)
    public void task1() {
        log.info("Task 1 실행: {}", Thread.currentThread().getName());
        sleep(3000);
    }
    
    @Scheduled(fixedRate = 1000)
    public void task2() {
        log.info("Task 2 실행: {}", Thread.currentThread().getName());
        sleep(3000);
    }
    
    // 두 작업이 동시에 실행됨 (별도 스레드)
}

// 13. 스케줄 락 (중복 실행 방지)
@Component
@Slf4j
public class LockedScheduler {
    
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    
    @Scheduled(fixedRate = 5000)
    public void taskWithLock() {
        if (!isRunning.compareAndSet(false, true)) {
            log.warn("이전 작업이 아직 실행 중");
            return;
        }
        
        try {
            log.info("작업 시작");
            Thread.sleep(10000);  // 10초 작업
            log.info("작업 완료");
        } catch (Exception e) {
            log.error("작업 실패", e);
        } finally {
            isRunning.set(false);
        }
    }
}

// 14. 분산 환경 스케줄링 (ShedLock)
@Configuration
@EnableScheduling
@EnableSchedulerLock(defaultLockAtMostFor = "10m")
public class ShedLockConfig {
    
    @Bean
    public LockProvider lockProvider(DataSource dataSource) {
        return new JdbcTemplateLockProvider(dataSource);
    }
}

@Component
@Slf4j
public class DistributedScheduler {
    
    @Scheduled(cron = "0 0 0 * * *")
    @SchedulerLock(
        name = "generateDailyReport",
        lockAtMostFor = "9m",
        lockAtLeastFor = "5m"
    )
    public void generateDailyReport() {
        log.info("일일 리포트 생성 (분산 환경)");
        // 여러 서버 중 하나만 실행
    }
}

// 15. 스케줄 테스트
@SpringBootTest
class SchedulerTest {
    
    @Autowired
    private DailyBatchScheduler scheduler;
    
    @Test
    void testDailyBatch() {
        // 스케줄러 메서드 직접 호출
        scheduler.generateDailyReport();
        
        // 검증
    }
}

// 16. Cron 표현식 빌더
@Component
public class CronExpressionBuilder {
    
    public String buildDailyCron(int hour, int minute) {
        return String.format("0 %d %d * * *", minute, hour);
    }
    
    public String buildWeeklyCron(DayOfWeek dayOfWeek, int hour) {
        return String.format("0 0 %d * * %s", hour, dayOfWeek.name());
    }
    
    public String buildMonthlyCron(int dayOfMonth, int hour) {
        return String.format("0 0 %d %d * *", hour, dayOfMonth);
    }
}
```

## 주의사항 / 함정

### 1. fixedRate vs fixedDelay
```java
// fixedRate: 시작 시점 기준 (오버랩 가능)
@Scheduled(fixedRate = 3000)
public void task() {
    sleep(5000);  // 5초 작업
    // 3초마다 시작 → 동시에 여러 개 실행될 수 있음!
}

// fixedDelay: 종료 시점 기준 (오버랩 없음)
@Scheduled(fixedDelay = 3000)
public void task() {
    sleep(5000);  // 5초 작업
    // 종료 후 3초 뒤 시작 → 동시 실행 없음
}
```

### 2. 예외 처리 누락
```java
// ❌ 예외 발생 시 스케줄 중단
@Scheduled(fixedRate = 5000)
public void task() {
    throw new RuntimeException();  // 다음 실행 안 됨!
}

// ✅ try-catch로 보호
@Scheduled(fixedRate = 5000)
public void task() {
    try {
        riskyOperation();
    } catch (Exception e) {
        log.error("스케줄 실행 실패", e);
    }
}
```

### 3. 긴 작업과 fixedRate
```java
// ❌ fixedRate + 긴 작업 = 스레드 풀 고갈
@Scheduled(fixedRate = 1000)
public void longTask() {
    sleep(10000);  // 10초 작업
    // 매초 시작 → 10개씩 쌓임 → 스레드 풀 고갈!
}

// ✅ fixedDelay 사용 또는 작업 시간 단축
@Scheduled(fixedDelay = 1000)
public void longTask() {
    sleep(10000);
}
```

### 4. 트랜잭션 전파
```java
// ❌ 스케줄러는 별도 스레드 → 트랜잭션 전파 안 됨
@Transactional
public void outerMethod() {
    // 트랜잭션 시작
}

@Scheduled(fixedRate = 5000)
public void scheduler() {
    outerMethod();  // 새 트랜잭션 시작
}
```

### 5. 분산 환경에서 중복 실행
```java
// ❌ 서버 3대 → 스케줄러 3번 실행
@Scheduled(cron = "0 0 0 * * *")
public void task() {
    // 모든 서버에서 동시 실행!
}

// ✅ ShedLock으로 하나만 실행
@SchedulerLock(name = "task")
@Scheduled(cron = "0 0 0 * * *")
public void task() {
    // 한 서버에서만 실행
}
```

### 6. Cron 표현식 검증 부족
```java
// ❌ 잘못된 cron 표현식
@Scheduled(cron = "0 0 25 * * *")  // 25시는 없음!
public void task() { }

// ✅ CronExpression으로 검증
String cron = "0 0 25 * * *";
try {
    CronExpression.parse(cron);
} catch (Exception e) {
    log.error("잘못된 cron 표현식");
}
```

### 7. 스레드 풀 크기 부족
```java
// ❌ 기본 스레드 풀 크기 1
@EnableScheduling
@Configuration
public class Config { }
// 여러 스케줄러 → 순차 실행!

// ✅ 스레드 풀 크기 설정
@Bean
public TaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
    scheduler.setPoolSize(10);
    return scheduler;
}
```

## 관련 개념
- [[비동기처리-Async]]
- [[배치처리-기초]]
- [[트랜잭션-관리]]

## 면접 질문

1. **fixedRate와 fixedDelay의 차이는?**
   - fixedRate: 시작 시점 기준 (이전 작업 끝나지 않아도 시작)
   - fixedDelay: 종료 시점 기준 (이전 작업 끝난 후 시작)

2. **Cron 표현식 "0 0 9 * * MON"의 의미는?**
   - 매주 월요일 오전 9시

3. **분산 환경에서 스케줄러 중복 실행을 막는 방법은?**
   - ShedLock 사용
   - Redis 분산 락
   - DB 락

4. **스케줄러에서 예외 처리가 중요한 이유는?**
   - 예외 발생 시 다음 실행이 중단될 수 있음
   - try-catch로 보호 필수

5. **@Scheduled의 기본 스레드 풀 크기는?**
   - 1개 (단일 스레드)
   - TaskScheduler 설정으로 증가 필요

6. **언제 스케줄링을 사용하나요?**
   - 일일 배치, 주기적 동기화
   - 데이터 정리, 캐시 갱신
   - 정기 리포트 생성

7. **initialDelay의 용도는?**
   - 애플리케이션 시작 직후 즉시 실행 방지
   - 초기화 시간 확보

## 참고 자료
- Spring Framework Reference - Task Execution and Scheduling
- Cron Expression Guide
- https://docs.spring.io/spring-framework/reference/integration/scheduling.html
