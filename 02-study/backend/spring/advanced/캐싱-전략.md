---
tags:
  - study
  - spring
  - advanced
  - cache
  - performance
created: 2025-02-08
---

# 캐싱 전략

## 한 줄 요약
> Spring Cache는 메서드 결과를 메모리에 저장하여 반복적인 연산이나 DB 조회를 줄이고, 애플리케이션 성능을 획기적으로 향상시키는 추상화 기술이다.

## 상세 설명

### 캐시란?
- **자주 사용하는 데이터를 빠른 저장소에 보관**
- 같은 요청에 대해 빠르게 응답
- DB 부하 감소, 응답 시간 단축

### 왜 캐시가 필요한가?
```java
// ❌ 캐시 없이: 매번 DB 조회 (느림)
public Product getProduct(Long id) {
    return productRepository.findById(id).get();  // 매번 DB 쿼리
}

// ✅ 캐시 사용: 첫 번째만 DB 조회, 이후는 캐시에서 (빠름)
@Cacheable("products")
public Product getProduct(Long id) {
    return productRepository.findById(id).get();  // 최초 1번만 쿼리
}
```

### 캐시 사용 시나리오
- **변경이 적은 데이터**: 상품 정보, 카테고리, 설정
- **조회가 많은 데이터**: 인기 상품, 베스트셀러
- **계산 비용이 큰 데이터**: 통계, 집계, 순위

### Spring Cache 애노테이션

| 애노테이션 | 설명 | 사용 시점 |
|-----------|------|----------|
| **@Cacheable** | 캐시에서 조회, 없으면 실행 후 저장 | 조회 메서드 |
| **@CachePut** | 항상 실행 후 캐시 갱신 | 수정 메서드 |
| **@CacheEvict** | 캐시 삭제 | 삭제, 수정 메서드 |
| **@Caching** | 여러 캐시 작업 조합 | 복잡한 캐시 로직 |

### 캐시 제공자
- **ConcurrentMapCache**: 로컬 메모리 (기본)
- **EhCache**: 로컬 캐시 (많이 사용)
- **Redis**: 분산 캐시 (권장)
- **Caffeine**: 고성능 로컬 캐시

## 코드 예시

```java
// 1. @EnableCaching 활성화
@EnableCaching
@Configuration
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("products", "users");
    }
}

// 2. @Cacheable (조회 시 캐싱)
@Service
@Slf4j
public class ProductService {
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        log.info("DB 조회: {}", id);  // 첫 번째만 출력
        return productRepository.findById(id)
                .orElseThrow(ProductNotFoundException::new);
    }
}

// 사용
productService.getProduct(1L);  // DB 조회 → 캐시 저장
productService.getProduct(1L);  // 캐시에서 조회 (빠름)
productService.getProduct(1L);  // 캐시에서 조회 (빠름)

// 3. key 지정 (SpEL)
@Cacheable(value = "products", key = "#id")
public Product getById(Long id) { }

@Cacheable(value = "products", key = "#product.id")
public Product save(Product product) { }

@Cacheable(value = "users", key = "#email")
public User findByEmail(String email) { }

// 복합 키
@Cacheable(value = "users", key = "#name + '_' + #age")
public List<User> findByNameAndAge(String name, int age) { }

// 4. condition (조건부 캐싱)
@Cacheable(
    value = "products",
    key = "#id",
    condition = "#id > 0"  // id가 양수일 때만 캐싱
)
public Product getProduct(Long id) { }

@Cacheable(
    value = "users",
    key = "#email",
    unless = "#result == null"  // 결과가 null이 아닐 때만 캐싱
)
public User findByEmail(String email) { }

// 5. @CachePut (항상 실행하고 캐시 갱신)
@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    // 항상 DB 업데이트 실행
    Product updated = productRepository.save(product);
    // 캐시도 자동 갱신
    return updated;
}

// 6. @CacheEvict (캐시 삭제)
// 특정 항목 삭제
@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
}

// 전체 캐시 삭제
@CacheEvict(value = "products", allEntries = true)
public void deleteAllProducts() {
    productRepository.deleteAll();
}

// 메서드 실행 전 삭제 (beforeInvocation = true)
@CacheEvict(
    value = "products",
    key = "#id",
    beforeInvocation = true  // 메서드 실행 전 캐시 삭제
)
public void deleteProductSafely(Long id) {
    // 예외 발생해도 캐시는 이미 삭제됨
    productRepository.deleteById(id);
}

// 7. @Caching (여러 캐시 작업 조합)
@Caching(
    put = {
        @CachePut(value = "products", key = "#product.id"),
        @CachePut(value = "products", key = "#product.code")
    },
    evict = {
        @CacheEvict(value = "productList", allEntries = true)
    }
)
public Product updateProduct(Product product) {
    return productRepository.save(product);
}

// 8. Redis 캐시 설정
@Configuration
@EnableCaching
public class RedisCacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))  // TTL 10분
                .serializeKeysWith(
                    RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer())
                )
                .serializeValuesWith(
                    RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer())
                );
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }
}

// 9. 캐시별 TTL 설정
@Configuration
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        
        // products 캐시: 1시간
        cacheConfigurations.put("products",
            RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))
        );
        
        // users 캐시: 30분
        cacheConfigurations.put("users",
            RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))
        );
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig())
                .withInitialCacheConfigurations(cacheConfigurations)
                .build();
    }
}

// 10. Caffeine 캐시 (고성능 로컬 캐시)
@Configuration
@EnableCaching
public class CaffeineCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
            "products", "users"
        );
        cacheManager.setCaffeine(
            Caffeine.newBuilder()
                .maximumSize(1000)  // 최대 1000개
                .expireAfterWrite(10, TimeUnit.MINUTES)  // 10분 후 만료
                .recordStats()  // 통계 기록
        );
        return cacheManager;
    }
}

// 11. 실무 패턴: Cache-Aside
@Service
@RequiredArgsConstructor
public class ProductCacheService {
    
    private final ProductRepository productRepository;
    private final CacheManager cacheManager;
    
    public Product getProduct(Long id) {
        // 1. 캐시 조회
        Cache cache = cacheManager.getCache("products");
        Product cachedProduct = cache.get(id, Product.class);
        
        if (cachedProduct != null) {
            return cachedProduct;  // 캐시 히트
        }
        
        // 2. 캐시 미스 → DB 조회
        Product product = productRepository.findById(id)
                .orElseThrow(ProductNotFoundException::new);
        
        // 3. 캐시 저장
        cache.put(id, product);
        
        return product;
    }
}

// 12. 실무 패턴: Write-Through
@Service
public class ProductService {
    
    @CachePut(value = "products", key = "#product.id")
    @Transactional
    public Product saveProduct(Product product) {
        // DB 저장과 동시에 캐시 갱신
        return productRepository.save(product);
    }
}

// 13. 실무 패턴: Write-Behind (비동기 쓰기)
@Service
@RequiredArgsConstructor
public class ProductAsyncCacheService {
    
    private final CacheManager cacheManager;
    private final ProductRepository productRepository;
    
    public void updateProduct(Product product) {
        // 1. 캐시 즉시 갱신
        Cache cache = cacheManager.getCache("products");
        cache.put(product.getId(), product);
        
        // 2. DB는 비동기로 저장
        CompletableFuture.runAsync(() -> {
            productRepository.save(product);
        });
    }
}

// 14. 캐시 워밍업 (애플리케이션 시작 시 캐시 미리 채우기)
@Component
@RequiredArgsConstructor
public class CacheWarmer {
    
    private final ProductService productService;
    
    @EventListener(ApplicationReadyEvent.class)
    public void warmUpCache() {
        // 인기 상품 미리 캐싱
        List<Long> popularProductIds = Arrays.asList(1L, 2L, 3L, 4L, 5L);
        
        popularProductIds.forEach(id -> {
            try {
                productService.getProduct(id);  // 캐시에 저장
            } catch (Exception e) {
                log.warn("캐시 워밍업 실패: {}", id);
            }
        });
        
        log.info("캐시 워밍업 완료");
    }
}

// 15. 캐시 통계 모니터링
@Component
@RequiredArgsConstructor
@Slf4j
public class CacheMonitor {
    
    private final CacheManager cacheManager;
    
    @Scheduled(fixedRate = 60000)  // 1분마다
    public void logCacheStats() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> 
                    nativeCache = (com.github.benmanes.caffeine.cache.Cache) 
                        ((CaffeineCache) cache).getNativeCache();
                
                log.info("캐시 통계 [{}]: {}", cacheName, nativeCache.stats());
            }
        });
    }
}

// 16. 캐시 수동 조작
@Service
@RequiredArgsConstructor
public class CacheManagementService {
    
    private final CacheManager cacheManager;
    
    // 특정 캐시 항목 조회
    public Product getCachedProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        return cache.get(id, Product.class);
    }
    
    // 특정 캐시 항목 저장
    public void putProductToCache(Product product) {
        Cache cache = cacheManager.getCache("products");
        cache.put(product.getId(), product);
    }
    
    // 특정 캐시 항목 삭제
    public void evictProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        cache.evict(id);
    }
    
    // 전체 캐시 삭제
    public void clearCache(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
        }
    }
    
    // 모든 캐시 삭제
    public void clearAllCaches() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                cache.clear();
            }
        });
    }
}

// 17. 캐시 키 생성 전략
@Configuration
public class CacheKeyConfig {
    
    @Bean
    public KeyGenerator customKeyGenerator() {
        return (target, method, params) -> {
            StringBuilder sb = new StringBuilder();
            sb.append(target.getClass().getSimpleName());
            sb.append("_");
            sb.append(method.getName());
            for (Object param : params) {
                sb.append("_").append(param);
            }
            return sb.toString();
        };
    }
}

@Service
public class ProductService {
    
    @Cacheable(value = "products", keyGenerator = "customKeyGenerator")
    public Product getProduct(Long id) {
        // 키: ProductService_getProduct_123
        return productRepository.findById(id).get();
    }
}
```

## 주의사항 / 함정

### 1. 동기화 문제 (Cache Stampede)
```java
// ❌ 동시 요청 시 모두 DB 조회
@Cacheable("products")
public Product getProduct(Long id) {
    // 캐시 만료 직후 100개 요청 → 100번 DB 조회!
    return productRepository.findById(id).get();
}

// ✅ sync = true (하나만 DB 조회, 나머지는 대기)
@Cacheable(value = "products", key = "#id", sync = true)
public Product getProduct(Long id) {
    return productRepository.findById(id).get();
}
```

### 2. 캐시 일관성 문제
```java
// ❌ 수정 시 캐시 갱신 누락
@Transactional
public Product updateProduct(Product product) {
    return productRepository.save(product);
    // 캐시는 그대로 → 오래된 데이터 조회!
}

// ✅ @CachePut으로 캐시 갱신
@CachePut(value = "products", key = "#product.id")
@Transactional
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
```

### 3. 캐시 키 충돌
```java
// ❌ 기본 키 생성 전략 사용 시 충돌 가능
@Cacheable("data")
public String getData(int id) { }

@Cacheable("data")
public String getData(String code) { }
// 같은 캐시 이름, 키가 "1"일 때 충돌!

// ✅ 명시적 키 지정
@Cacheable(value = "data", key = "'id_' + #id")
public String getDataById(int id) { }

@Cacheable(value = "data", key = "'code_' + #code")
public String getDataByCode(String code) { }
```

### 4. 너무 많은 캐시
```java
// ❌ 모든 메서드에 캐싱 (메모리 낭비)
@Cacheable("cache1")
public String method1() { }

@Cacheable("cache2")
public String method2() { }

// ✅ 자주 조회되는 데이터만 캐싱
@Cacheable("hotData")
public String getHotData() { }
```

### 5. 캐시 만료 시간 미설정
```java
// ❌ TTL 없으면 영구 저장 → 메모리 부족
@Cacheable("products")
public Product getProduct(Long id) { }

// ✅ TTL 설정
RedisCacheConfiguration.defaultCacheConfig()
    .entryTtl(Duration.ofMinutes(10));
```

### 6. null 캐싱
```java
// ❌ null도 캐싱됨 → 캐시 공간 낭비
@Cacheable("users")
public User findByEmail(String email) {
    return userRepository.findByEmail(email)
            .orElse(null);  // null이 캐싱됨!
}

// ✅ unless로 null 제외
@Cacheable(value = "users", unless = "#result == null")
public User findByEmail(String email) {
    return userRepository.findByEmail(email).orElse(null);
}
```

### 7. 분산 환경에서 로컬 캐시 사용
```java
// ❌ 서버 A, B가 각각 다른 캐시 보유 → 불일치
// 서버 A: 캐시 갱신
// 서버 B: 오래된 캐시 유지

// ✅ Redis 같은 분산 캐시 사용
```

## 관련 개념
- [[비동기처리-Async]]
- [[트랜잭션-관리]]
- [[스케줄링]]

## 면접 질문

1. **캐시를 사용하는 이유는?**
   - DB 부하 감소
   - 응답 시간 단축
   - 서버 비용 절감

2. **@Cacheable, @CachePut, @CacheEvict의 차이는?**
   - @Cacheable: 캐시 조회 후 없으면 실행
   - @CachePut: 항상 실행 후 캐시 갱신
   - @CacheEvict: 캐시 삭제

3. **로컬 캐시와 분산 캐시의 차이는?**
   - 로컬: 각 서버 메모리 (ConcurrentMap, Caffeine)
   - 분산: 공유 저장소 (Redis, Memcached)

4. **Cache Stampede 문제란?**
   - 캐시 만료 시 동시 요청으로 DB 과부하
   - sync = true 또는 락으로 해결

5. **캐시 전략 3가지는?**
   - Cache-Aside: 애플리케이션이 캐시 관리
   - Write-Through: 쓰기 시 DB + 캐시 동시 갱신
   - Write-Behind: 캐시 먼저, DB는 비동기

6. **언제 캐시를 사용하지 말아야 하나요?**
   - 실시간 데이터 (주식, 채팅)
   - 자주 변경되는 데이터
   - 메모리 제약이 큰 환경

7. **캐시 키 설계 시 주의사항은?**
   - 충돌 방지 (명시적 키 지정)
   - 적절한 길이 (너무 길지 않게)
   - 예측 가능성 (디버깅 용이)

## 참고 자료
- Spring Framework Reference - Cache Abstraction
- Redis Best Practices
- https://docs.spring.io/spring-framework/reference/integration/cache.html
