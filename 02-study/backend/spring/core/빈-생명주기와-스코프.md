---
tags:
  - study
  - spring
  - core
  - bean
  - lifecycle
  - scope
created: 2025-02-08
---

# 빈 생명주기와 스코프

## 한 줄 요약
> Spring 빈은 생성, 초기화, 사용, 소멸의 생명주기를 가지며, 싱글톤/프로토타입 등의 스코프로 빈의 생성 범위와 생명주기를 제어할 수 있다.

## 상세 설명

### 빈 생명주기 (Bean Lifecycle)

**Spring 컨테이너 생성 → 빈 객체 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸 전 콜백 → 종료**

1. **객체 생성 단계**
   - 스프링 컨테이너가 빈 정의를 읽어 객체 생성
   - 생성자 호출

2. **의존관계 주입 단계**
   - 필드나 세터를 통한 의존성 주입
   - @Autowired, @Resource 등 처리

3. **초기화 단계**
   - 초기화 콜백 메서드 실행
   - 연결 풀 생성, 리소스 로딩 등 수행

4. **사용 단계**
   - 실제 비즈니스 로직 수행

5. **소멸 단계**
   - 소멸 전 콜백 메서드 실행
   - 연결 해제, 리소스 정리 등

### 생명주기 콜백 방법

#### 1. @PostConstruct, @PreDestroy (권장)
- JSR-250 자바 표준
- 가장 편리하고 권장되는 방법
- 외부 라이브러리에는 적용 불가

#### 2. InitializingBean, DisposableBean 인터페이스
- 스프링 전용 인터페이스에 의존
- 코드가 스프링에 종속됨 (권장 X)

#### 3. @Bean의 initMethod, destroyMethod
- 외부 라이브러리 초기화/종료 시 사용
- 설정 정보에 콜백 메서드명 지정

### 빈 스코프 (Bean Scope)

| 스코프 | 설명 | 사용 시기 |
|--------|------|-----------|
| **singleton** | 스프링 컨테이너 당 하나의 인스턴스 (기본값) | 대부분의 경우 (무상태) |
| **prototype** | 요청마다 새로운 인스턴스 생성 | 상태를 가지는 빈 |
| **request** | HTTP 요청마다 새로운 인스턴스 | 웹 요청 정보 |
| **session** | HTTP 세션마다 새로운 인스턴스 | 사용자 세션 정보 |
| **application** | ServletContext와 동일한 생명주기 | 애플리케이션 전역 정보 |
| **websocket** | WebSocket과 동일한 생명주기 | WebSocket 통신 |

### Singleton vs Prototype

**싱글톤 스코프**
- 스프링 컨테이너의 시작과 끝까지 유지
- 하나의 공유 인스턴스 사용
- 초기화 콜백과 소멸 콜백 모두 실행

**프로토타입 스코프**
- 요청 시마다 새로운 인스턴스 생성
- 스프링 컨테이너가 생성, 의존관계 주입, 초기화까지만 관여
- **소멸 메서드 호출 안 됨** (클라이언트가 직접 관리)

## 코드 예시

```java
// 1. @PostConstruct / @PreDestroy 사용 (권장)
@Component
public class NetworkClient {
    private String url;
    
    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
    }
    
    @PostConstruct
    public void init() {
        System.out.println("NetworkClient.init");
        connect();
        call("초기화 연결 메시지");
    }
    
    @PreDestroy
    public void close() {
        System.out.println("NetworkClient.close");
        disconnect();
    }
    
    public void connect() {
        System.out.println("connect: " + url);
    }
    
    public void disconnect() {
        System.out.println("close: " + url);
    }
}

// 2. @Bean의 initMethod, destroyMethod (외부 라이브러리)
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "init", destroyMethod = "close")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
    }
}

// 3. Prototype 스코프
@Scope("prototype")
@Component
public class PrototypeBean {
    
    @PostConstruct
    public void init() {
        System.out.println("PrototypeBean.init");
    }
    
    @PreDestroy
    public void destroy() {
        System.out.println("PrototypeBean.destroy");
        // 프로토타입은 이 메서드가 호출되지 않음!
    }
}

// 4. Request 스코프 (웹 환경)
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
    private String uuid;
    private String requestURL;
    
    public void setRequestURL(String requestURL) {
        this.requestURL = requestURL;
    }
    
    public void log(String message) {
        System.out.println("[" + uuid + "][" + requestURL + "] " + message);
    }
    
    @PostConstruct
    public void init() {
        uuid = UUID.randomUUID().toString();
        System.out.println("[" + uuid + "] request scope bean create");
    }
    
    @PreDestroy
    public void close() {
        System.out.println("[" + uuid + "] request scope bean close");
    }
}

// 5. 싱글톤 빈에서 프로토타입 빈 사용하기
@Component
@RequiredArgsConstructor
public class ClientBean {
    private final ObjectProvider<PrototypeBean> prototypeBeanProvider;
    
    public int logic() {
        PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
        prototypeBean.addCount();
        return prototypeBean.getCount();
    }
}

// 6. 웹 스코프와 프록시
@Controller
@RequiredArgsConstructor
public class LogDemoController {
    private final LogDemoService logDemoService;
    private final MyLogger myLogger;  // request 스코프지만 프록시로 주입 가능
    
    @RequestMapping("log-demo")
    @ResponseBody
    public String logDemo(HttpServletRequest request) {
        String requestURL = request.getRequestURL().toString();
        myLogger.setRequestURL(requestURL);
        
        myLogger.log("controller test");
        logDemoService.logic("testId");
        return "OK";
    }
}
```

## 주의사항 / 함정

### 1. 프로토타입 빈의 소멸 메서드
```java
@Scope("prototype")
@Component
public class PrototypeBean {
    
    @PreDestroy
    public void destroy() {
        // ❌ 이 메서드는 호출되지 않음!
        // 프로토타입은 생성과 의존관계 주입, 초기화까지만 관여
    }
}
```

### 2. 싱글톤 빈에서 프로토타입 빈 주입 시 문제
- 싱글톤 빈 생성 시점에 프로토타입 빈도 함께 주입됨
- 이후 프로토타입 빈이 교체되지 않음 → 의도와 다른 동작
- 해결: ObjectProvider, JSR-330 Provider 사용

### 3. Request 스코프의 타이밍 이슈
```java
// ❌ 문제: 애플리케이션 시작 시점에는 request가 없음
@Component
@RequiredArgsConstructor
public class LogDemoController {
    private final MyLogger myLogger;  // 에러 발생!
}

// ✅ 해결 1: ObjectProvider 사용
@Component
@RequiredArgsConstructor
public class LogDemoController {
    private final ObjectProvider<MyLogger> myLoggerProvider;
    
    public void someMethod() {
        MyLogger myLogger = myLoggerProvider.getObject();
    }
}

// ✅ 해결 2: 프록시 모드 사용 (권장)
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger { }
```

### 4. 생성자 주입 시점의 초기화
- 생성자에서는 의존관계가 아직 주입되지 않음
- **초기화 작업은 @PostConstruct에서 수행**

### 5. destroyMethod의 기본값
- @Bean의 destroyMethod는 기본값이 `(inferred)`
- close, shutdown 같은 메서드를 자동으로 호출
- 외부 라이브러리 사용 시 편리

## 관련 개념
- [[IoC-DI-컨테이너]]
- [[컴포넌트-스캔]]
- [[비동기처리-Async]]

## 면접 질문

1. **스프링 빈의 생명주기를 설명하세요.**
   - 객체 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸 전 콜백 → 종료

2. **생명주기 콜백을 처리하는 3가지 방법은?**
   - @PostConstruct/@PreDestroy (권장)
   - InitializingBean/DisposableBean 인터페이스
   - @Bean의 initMethod/destroyMethod 속성

3. **싱글톤 스코프와 프로토타입 스코프의 차이는?**
   - 싱글톤: 컨테이너당 하나의 인스턴스, 소멸까지 관리
   - 프로토타입: 요청마다 새 인스턴스 생성, 생성과 초기화까지만 관여

4. **싱글톤 빈에서 프로토타입 빈을 사용할 때 주의점은?**
   - 싱글톤 생성 시점에 프로토타입도 주입되어 계속 같은 인스턴스 사용
   - ObjectProvider나 JSR-330 Provider로 해결

5. **Request 스코프를 사용할 때 프록시 모드가 필요한 이유는?**
   - 애플리케이션 시작 시점에는 HTTP 요청이 없어서 빈 생성 불가
   - 프록시 객체를 먼저 주입하고, 실제 요청 시점에 진짜 빈을 찾아서 위임

6. **@PostConstruct는 언제 호출되나요?**
   - 객체 생성과 의존관계 주입이 완료된 직후

## 참고 자료
- 김영한의 스프링 핵심 원리 - 기본편
- Spring Framework Reference - Bean Scopes
- https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html
