---
tags: study, TDD, Testing, Advanced
created: 2026-01-24
---

# TDD 고급 2026 최신 트렌드

## 한 줄 요약
> 2026년 TDD는 Testcontainers로 실제 환경 재현, ArchUnit로 아키텍처 검증, Mutation Testing으로 테스트 품질 측정하는 고급 기법 활용

## 상세 설명

고급 TDD는 단순 기능 테스트를 넘어 아키텍처 규칙 검증, 테스트 품질 측정, 프로덕션과 동일한 환경에서 테스트하는 것을 포함합니다.

### Testcontainers

**개념**: Docker 컨테이너로 실제 DB/Redis 등을 테스트 환경에서 실행

**장점**:
- H2가 아닌 실제 MySQL/PostgreSQL로 테스트
- 프로덕션과 동일한 환경 보장
- SQL 방언 차이로 인한 문제 방지

### ArchUnit

**개념**: 아키텍처 규칙을 코드로 검증

**검증 가능 규칙**:
- 계층 간 의존성 (Controller → Service → Repository)
- 명명 규칙 (Controller는 "Controller"로 끝나야 함)
- 순환 의존성 방지

### Mutation Testing

**개념**: 코드를 변형(mutation)하여 테스트가 잡아내는지 확인

**측정**: Mutation Score = 잡은 변형 / 전체 변형
- 80% 이상 목표

### Spring Cloud Contract

**개념**: API 계약 기반 테스트
- Consumer-Driven Contract Testing
- API 스펙 변경 시 자동 감지

### 병렬 실행

**JUnit 5 병렬 실행**:
- 테스트 속도 50-70% 향상
- 격리 보장 필수

## 코드 예시

```java
// 1. Testcontainers
@Testcontainers
@SpringBootTest
class IntegrationTest {
    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void properties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
    }
    
    @Test
    void testWithRealDatabase() {
        // 실제 MySQL로 테스트
    }
}

// 2. ArchUnit
@AnalyzeClasses(packages = "com.example")
class ArchitectureTest {
    @ArchTest
    static final ArchRule controllers_should_only_depend_on_services =
        classes()
            .that().resideInAPackage("..controller..")
            .should().onlyDependOnClassesThat()
            .resideInAnyPackage("..service..", "..dto..", "java..");
    
    @ArchTest
    static final ArchRule services_should_not_access_repositories_directly =
        noClasses()
            .that().resideInAPackage("..controller..")
            .should().accessClassesThat()
            .resideInAPackage("..repository..");
    
    @ArchTest
    static final ArchRule no_cycles =
        slices()
            .matching("com.example.(*)..")
            .should().beFreeOfCycles();
}

// 3. Mutation Testing (PIT)
// pom.xml
<plugin>
    <groupId>org.pitest</groupId>
    <artifactId>pitest-maven</artifactId>
    <version>1.15.3</version>
    <configuration>
        <targetClasses>
            <param>com.example.service.*</param>
        </targetClasses>
        <targetTests>
            <param>com.example.service.*Test</param>
        </targetTests>
    </configuration>
</plugin>

// 실행: mvn org.pitest:pitest-maven:mutationCoverage

// 4. 병렬 실행
// junit-platform.properties
junit.jupiter.execution.parallel.enabled=true
junit.jupiter.execution.parallel.mode.default=concurrent
junit.jupiter.execution.parallel.config.strategy=dynamic

// 테스트 격리
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ParallelTest {
    @Test
    void test1() {
        // 격리된 테스트
    }
}

// 5. Spring Cloud Contract
// contract.groovy
Contract.make {
    request {
        method 'GET'
        url '/api/users/1'
    }
    response {
        status 200
        body([
            id: 1,
            email: "test@example.com"
        ])
        headers {
            contentType(applicationJson())
        }
    }
}
```

## 주의사항 / 함정

1. **Testcontainers 속도**: 초기 이미지 다운로드 느림, CI/CD에서 캐싱 필요
2. **ArchUnit 과도한 규칙**: 필요한 규칙만 검증
3. **Mutation Testing 시간**: 빌드 시간 증가, CI에서 선택적 실행
4. **병렬 실행 격리**: 공유 자원 주의 (DB, 파일)

## 관련 개념
- [[TDD-기초-Red-Green-Refactor]]
- [[TDD-실전-Spring-Boot-테스트]]
- [[Testcontainers]]
- [[ArchUnit]]

## 면접 질문
1. Testcontainers를 사용하는 이유는?
2. Mutation Testing이란?
3. ArchUnit으로 무엇을 검증하나?

## 참고 자료
- Testcontainers 공식 문서
- ArchUnit 공식 문서
- PIT Mutation Testing
