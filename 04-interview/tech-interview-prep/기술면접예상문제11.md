### **Q91. 디자인 패턴 - Singleton**

**면접관**: Singleton 패턴을 설명하고 주의사항을 말씀해주세요.

**답변**:

Singleton은 인스턴스가 하나만 존재하도록 보장하는 패턴입니다.

**기본 구현:**

```java
public class DatabaseConnection {
    private static DatabaseConnection instance;
    
    private DatabaseConnection() {
        // private 생성자로 외부 생성 차단
    }
    
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```

**문제점:**

멀티스레드 환경에서 동시에 getInstance() 호출하면 인스턴스가 두 개 생성될 수 있습니다.

**Thread-Safe 구현:**

**1. Eager Initialization (이른 초기화)**

```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

장점: 간단, Thread-safe  
단점: 사용 안 해도 생성됨

**2. Lazy Initialization + synchronized**

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

장점: Lazy, Thread-safe  
단점: 성능 저하 (매번 동기화)

**3. Double-Checked Locking**

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

장점: Lazy, 성능 좋음  
주의: volatile 필수

**4. Enum (권장)**

```java
public enum Singleton {
    INSTANCE;
    
    public void doSomething() {
        // 비즈니스 로직
    }
}
```

장점:
- 간결
- Thread-safe 보장
- 직렬화 안전
- 리플렉션 공격 방지

**Spring에서는:**

```java
@Component
public class ConfigService {
    // Spring이 Singleton으로 관리
}
```

자동으로 Singleton이니까 직접 구현할 필요 없습니다.

**BizSync에서:**

```java
@Service
public class ApprovalService {
    // 애플리케이션에 1개만 존재
}
```

모든 요청이 같은 인스턴스를 공유합니다.

**주의사항:**

**1. 상태를 가지면 안 됩니다**

나쁨:

```java
@Service
public class UserService {
    private Long currentUserId;  // 공유됨!
    
    public void process(Long userId) {
        this.currentUserId = userId;
        // 멀티스레드에서 꼬임!
    }
}
```

좋음:

```java
@Service
public class UserService {
    public void process(Long userId) {
        // 지역 변수 사용
        User user = findUser(userId);
    }
}
```

**2. 테스트 어려움**

Singleton은 전역 상태라서 테스트 간 영향을 줄 수 있습니다.

정리:
- 인스턴스 하나만 보장
- Spring은 기본 Singleton
- 상태 가지면 안 됨
- Enum이 가장 안전

---

### **Q92. 디자인 패턴 - Factory**

**면접관**: Factory 패턴은 언제 사용하나요?

**답변**:

Factory 패턴은 객체 생성을 캡슐화하는 패턴입니다.

**사용 시나리오:**

알림을 여러 채널로 보낼 때 (이메일, SMS, Slack 등)

**Factory 없이:**

```java
public void sendNotification(String type, String message) {
    if (type.equals("email")) {
        EmailNotification email = new EmailNotification();
        email.send(message);
    } else if (type.equals("sms")) {
        SmsNotification sms = new SmsNotification();
        sms.send(message);
    }
    // 새 타입 추가하려면 이 코드 수정!
}
```

**Factory 사용:**

```java
public interface Notification {
    void send(String message);
}

public class EmailNotification implements Notification {
    public void send(String message) {
        // 이메일 발송
    }
}

public class SmsNotification implements Notification {
    public void send(String message) {
        // SMS 발송
    }
}

public class NotificationFactory {
    public static Notification create(String type) {
        return switch (type) {
            case "email" -> new EmailNotification();
            case "sms" -> new SmsNotification();
            case "slack" -> new SlackNotification();
            default -> throw new IllegalArgumentException();
        };
    }
}
```

사용:

```java
Notification notification = NotificationFactory.create("email");
notification.send("결재가 승인되었습니다");
```

**Spring에서는:**

```java
@Component
public class NotificationFactory {
    
    private final Map<String, Notification> notifications;
    
    public NotificationFactory(List<Notification> notificationList) {
        this.notifications = notificationList.stream()
            .collect(Collectors.toMap(
                Notification::getType,
                Function.identity()
            ));
    }
    
    public Notification create(String type) {
        Notification notification = notifications.get(type);
        if (notification == null) {
            throw new IllegalArgumentException("지원하지 않는 타입: " + type);
        }
        return notification;
    }
}

@Component
public class EmailNotification implements Notification {
    public String getType() { return "email"; }
    public void send(String message) { }
}

@Component
public class SmsNotification implements Notification {
    public String getType() { return "sms"; }
    public void send(String message) { }
}
```

**BizSync에서 사용했다면:**

결재 승인 방식이 순차, 병렬, 조건부 등 여러 가지일 때

```java
public interface ApprovalStrategy {
    void approve(ApprovalDocument doc);
}

public class SequentialApproval implements ApprovalStrategy {
    // 순차 승인 로직
}

public class ParallelApproval implements ApprovalStrategy {
    // 병렬 승인 로직
}

@Component
public class ApprovalStrategyFactory {
    public ApprovalStrategy create(String type) {
        return switch (type) {
            case "sequential" -> new SequentialApproval();
            case "parallel" -> new ParallelApproval();
            default -> throw new IllegalArgumentException();
        };
    }
}
```

**장점:**

1. 객체 생성 로직 캡슐화
2. 결합도 낮음
3. 새 타입 추가 쉬움
4. 단일 책임 원칙

**단점:**

1. 클래스 증가
2. 코드 복잡도

**언제 사용?**

- 객체 생성이 복잡할 때
- 타입에 따라 다른 객체 생성
- 생성 로직이 자주 바뀔 때

정리:
- 객체 생성 캡슐화
- 타입별로 다른 인스턴스
- Spring은 Bean으로 관리 가능

---

### **Q93. 디자인 패턴 - Strategy**

**면접관**: Strategy 패턴을 설명해주세요.

**답변**:

Strategy 패턴은 알고리즘을 교체 가능하게 만드는 패턴입니다.

**예시:**

정렬 방식을 동적으로 바꾸고 싶을 때

```java
// Strategy 인터페이스
public interface SortStrategy {
    void sort(List<Integer> list);
}

// 구체적인 전략들
public class BubbleSort implements SortStrategy {
    public void sort(List<Integer> list) {
        // 버블 정렬
    }
}

public class QuickSort implements SortStrategy {
    public void sort(List<Integer> list) {
        // 퀵 정렬
    }
}

// Context
public class Sorter {
    private SortStrategy strategy;
    
    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sort(List<Integer> list) {
        strategy.sort(list);
    }
}
```

**사용:**

```java
Sorter sorter = new Sorter();

sorter.setStrategy(new BubbleSort());
sorter.sort(list);  // 버블 정렬

sorter.setStrategy(new QuickSort());
sorter.sort(list);  // 퀵 정렬
```

**BizSync 실제 적용 가능한 예:**

**결제 방식 선택:**

```java
public interface PaymentStrategy {
    void pay(int amount);
}

public class CardPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("카드로 " + amount + "원 결제");
    }
}

public class AccountPayment implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("계좌이체로 " + amount + "원 결제");
    }
}

public class PaymentProcessor {
    private PaymentStrategy strategy;
    
    public void setPaymentMethod(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void process(int amount) {
        strategy.pay(amount);
    }
}
```

**할인 정책:**

```java
public interface DiscountStrategy {
    int discount(int price);
}

public class NoDiscount implements DiscountStrategy {
    public int discount(int price) {
        return price;
    }
}

public class PercentDiscount implements DiscountStrategy {
    private int percent;
    
    public PercentDiscount(int percent) {
        this.percent = percent;
    }
    
    public int discount(int price) {
        return price * (100 - percent) / 100;
    }
}

public class Calculator {
    private DiscountStrategy strategy;
    
    public Calculator(DiscountStrategy strategy) {
        this.strategy = strategy;
    }
    
    public int calculate(int price) {
        return strategy.discount(price);
    }
}
```

사용:

```java
Calculator calc = new Calculator(new PercentDiscount(10));
int finalPrice = calc.calculate(10000);  // 9000원
```

**Spring에서:**

```java
@Service
public class OrderService {
    
    private final Map<String, PaymentStrategy> strategies;
    
    public OrderService(List<PaymentStrategy> strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(
                PaymentStrategy::getName,
                Function.identity()
            ));
    }
    
    public void processPayment(String method, int amount) {
        PaymentStrategy strategy = strategies.get(method);
        strategy.pay(amount);
    }
}
```

**장점:**

1. 알고리즘 교체 쉬움
2. 조건문 제거 (if-else 없앰)
3. 개방-폐쇄 원칙
4. 런타임에 동적 변경

**단점:**

1. 클래스 증가
2. 클라이언트가 전략을 알아야 함

**Factory vs Strategy:**

- Factory: 객체 생성에 집중
- Strategy: 알고리즘 교체에 집중

정리:
- 알고리즘 캡슐화
- 런타임에 교체 가능
- if-else 제거
- 새 전략 추가 쉬움

---

### **Q94. 디자인 패턴 - Builder**

**면접관**: Builder 패턴은 왜 사용하나요?

**답변**:

Builder 패턴은 복잡한 객체 생성을 단계별로 할 수 있게 하는 패턴입니다.

**문제 상황:**

생성자 파라미터가 많을 때

```java
public class Project {
    private String name;
    private String description;
    private User leader;
    private LocalDate startDate;
    private LocalDate endDate;
    private String status;
    private int budget;
    
    public Project(String name, String description, User leader,
                   LocalDate startDate, LocalDate endDate,
                   String status, int budget) {
        // 파라미터 순서 헷갈림!
    }
}

// 사용
Project p = new Project(
    "BizSync",
    "협업 시스템",
    leader,
    LocalDate.now(),
    LocalDate.now().plusMonths(6),
    "ACTIVE",
    10000000
);
// 순서 틀리기 쉬움!
```

**Builder 패턴:**

```java
public class Project {
    private String name;
    private String description;
    private User leader;
    private LocalDate startDate;
    private LocalDate endDate;
    private String status;
    private int budget;
    
    private Project(Builder builder) {
        this.name = builder.name;
        this.description = builder.description;
        this.leader = builder.leader;
        this.startDate = builder.startDate;
        this.endDate = builder.endDate;
        this.status = builder.status;
        this.budget = builder.budget;
    }
    
    public static class Builder {
        private String name;
        private String description;
        private User leader;
        private LocalDate startDate;
        private LocalDate endDate;
        private String status = "ACTIVE";  // 기본값
        private int budget;
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder description(String description) {
            this.description = description;
            return this;
        }
        
        public Builder leader(User leader) {
            this.leader = leader;
            return this;
        }
        
        public Builder startDate(LocalDate startDate) {
            this.startDate = startDate;
            return this;
        }
        
        public Builder endDate(LocalDate endDate) {
            this.endDate = endDate;
            return this;
        }
        
        public Builder budget(int budget) {
            this.budget = budget;
            return this;
        }
        
        public Project build() {
            // 유효성 검증
            if (name == null || leader == null) {
                throw new IllegalStateException("필수 필드 누락");
            }
            return new Project(this);
        }
    }
}
```

**사용:**

```java
Project project = new Project.Builder()
    .name("BizSync")
    .description("협업 시스템")
    .leader(leader)
    .startDate(LocalDate.now())
    .endDate(LocalDate.now().plusMonths(6))
    .budget(10000000)
    .build();
```

**Lombok @Builder:**

```java
@Builder
@Getter
public class Project {
    private String name;
    private String description;
    private User leader;
    private LocalDate startDate;
    private LocalDate endDate;
    
    @Builder.Default
    private String status = "ACTIVE";
}
```

사용:

```java
Project project = Project.builder()
    .name("BizSync")
    .leader(leader)
    .build();
```

**BizSync에서 실제 사용:**

```java
@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Task {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long taskId;
    
    private String title;
    private String content;
    
    @Builder
    public Task(String title, String content) {
        this.title = title;
        this.content = content;
    }
}
```

Service에서:

```java
Task task = Task.builder()
    .title("새 작업")
    .content("작업 내용")
    .build();
```

**장점:**

1. 가독성 좋음
2. 불변 객체 생성 가능
3. 선택적 파라미터
4. 유효성 검증 한 곳에서

**단점:**

1. 코드량 증가
2. 간단한 객체엔 오버킬

**언제 사용?**

- 파라미터 4개 이상
- 선택적 파라미터 많음
- 불변 객체 필요
- 유효성 검증 복잡

정리:
- 복잡한 객체 생성
- 가독성 향상
- Lombok @Builder 편리
- 필수/선택 파라미터 구분

---

### **Q95. 테스트 - 단위 테스트**

**면접관**: 단위 테스트는 어떻게 작성하나요?

**답변**:

단위 테스트는 메서드 하나를 독립적으로 테스트하는 겁니다.

**JUnit 5 기본:**

```java
@Test
void 결재_승인_성공() {
    // given (준비)
    ApprovalDocument doc = new ApprovalDocument();
    doc.setStatus(PENDING);
    
    // when (실행)
    doc.approve();
    
    // then (검증)
    assertEquals(APPROVED, doc.getStatus());
}
```

**BizSync Service 테스트:**

```java
@ExtendWith(MockitoExtension.class)
class ApprovalServiceTest {
    
    @Mock
    private ApprovalRepository repository;
    
    @InjectMocks
    private ApprovalService approvalService;
    
    @Test
    void 결재_승인_성공() {
        // given
        Long docId = 1L;
        ApprovalDocument doc = createDocument();
        
        when(repository.findById(docId))
            .thenReturn(Optional.of(doc));
        
        // when
        approvalService.approve(docId);
        
        // then
        assertEquals(APPROVED, doc.getStatus());
        verify(repository).findById(docId);
    }
    
    @Test
    void 결재_문서_없음_예외() {
        // given
        Long docId = 999L;
        
        when(repository.findById(docId))
            .thenReturn(Optional.empty());
        
        // when & then
        assertThrows(
            DocumentNotFoundException.class,
            () -> approvalService.approve(docId)
        );
    }
    
    private ApprovalDocument createDocument() {
        return ApprovalDocument.builder()
            .title("테스트 문서")
            .status(PENDING)
            .build();
    }
}
```

**AssertJ 사용:**

```java
@Test
void 프로젝트_조회() {
    // given
    Long projectId = 1L;
    Project project = createProject();
    
    when(repository.findById(projectId))
        .thenReturn(Optional.of(project));
    
    // when
    Project result = projectService.findById(projectId);
    
    // then
    assertThat(result)
        .isNotNull()
        .extracting("name", "status")
        .containsExactly("BizSync", "ACTIVE");
}
```

**Repository 테스트 (통합):**

```java
@DataJpaTest
class ProjectRepositoryTest {
    
    @Autowired
    private ProjectRepository repository;
    
    @Test
    void 프로젝트_저장_조회() {
        // given
        Project project = Project.builder()
            .name("테스트 프로젝트")
            .build();
        
        // when
        Project saved = repository.save(project);
        
        // then
        assertThat(saved.getProjectId()).isNotNull();
        
        Project found = repository.findById(saved.getProjectId()).get();
        assertThat(found.getName()).isEqualTo("테스트 프로젝트");
    }
}
```

**테스트 격리:**

```java
@BeforeEach
void setUp() {
    // 각 테스트 전에 실행
}

@AfterEach
void tearDown() {
    // 각 테스트 후에 실행
    repository.deleteAll();
}
```

**Parameterized Test:**

```java
@ParameterizedTest
@ValueSource(strings = {"", "   ", "a", "12345678901234567890123456789012345678901234567890123456789"})
void 프로젝트명_검증(String name) {
    // given
    CreateProjectDTO dto = new CreateProjectDTO();
    dto.setName(name);
    
    // when & then
    assertThrows(ValidationException.class,
        () -> projectService.create(dto));
}
```

**Mock vs Spy:**

- Mock: 완전히 가짜 객체
- Spy: 실제 객체를 부분적으로 Mock

```java
@Spy
private List<String> spyList = new ArrayList<>();

@Test
void spy_테스트() {
    spyList.add("one");
    spyList.add("two");
    
    verify(spyList).add("one");
    assertEquals(2, spyList.size());  // 실제로 추가됨
    
    when(spyList.size()).thenReturn(100);
    assertEquals(100, spyList.size());  // Mock으로 변경
}
```

**좋은 테스트:**

1. 빠름 (Fast)
2. 독립적 (Independent)
3. 반복 가능 (Repeatable)
4. 자가 검증 (Self-validating)
5. 적시 작성 (Timely)

정리:
- given-when-then 패턴
- Mock으로 의존성 제거
- AssertJ로 가독성 향상
- 단위 테스트는 빠르고 독립적

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]