---
tags: teck-interview
---
### **Q11. Component Scan**

**면접관**: @ComponentScan이 어떻게 동작하나요?

**답변**:

@ComponentScan은 @Component가 붙은 클래스들을 찾아서 자동으로 Bean으로 등록합니다.

Spring Boot의 @SpringBootApplication에 이미 포함되어 있습니다:

```java
@SpringBootApplication
// = @Configuration + @EnableAutoConfiguration + @ComponentScan
public class BackendApplication {
    public static void main(String[] args) {
        SpringApplication.run(BackendApplication.class, args);
    }
}
```

**동작 과정:**

1. 애플리케이션 시작
2. @SpringBootApplication이 있는 패키지부터 스캔 (com.bizsync.backend)
3. 하위 패키지 전부 탐색
   - com.bizsync.backend.service
   - com.bizsync.backend.controller
   - com.bizsync.backend.repository
4. @Component 계열 찾기 (@Service, @Repository, @Controller, @Configuration)
5. Bean으로 등록

BizSync 구조:

```
com.bizsync.backend
├── BackendApplication.java  ← 여기서 스캔 시작
├── controller/
│   └── ApprovalController.java  ✓ 스캔됨
├── service/
│   └── ApprovalService.java     ✓ 스캔됨
└── domain/
    └── repository/
        └── ApprovalRepository.java  ✓ 스캔됨
```

만약 다른 패키지를 스캔하려면:

```java
@ComponentScan(basePackages = {
    "com.bizsync.backend",
    "com.external.library"
})
```

특정 클래스 제외:

```java
@ComponentScan(
    excludeFilters = @Filter(
        type = FilterType.ASSIGNABLE_TYPE,
        classes = TestConfig.class
    )
)
```

**주의사항:**

**1. @SpringBootApplication보다 상위 패키지에 클래스 두면 스캔 안 됨!**

```
com.bizsync/
└── SomeService.java  ← 스캔 안 됨
com.bizsync.backend/
└── BackendApplication.java
```

**2. 순환 참조 조심**

```java
@Service
class A {
    @Autowired B b;
}

@Service  
class B {
    @Autowired A a;
}
// 에러 발생!
```

해결: 생성자 주입 or @Lazy 사용

---

### **Q12. @Autowired vs @Resource vs @Inject**

**면접관**: 의존성 주입 애노테이션들의 차이는?

**답변**:

세 개 모두 의존성을 주입하지만 방식이 조금 다릅니다.

**@Autowired (Spring 제공)**
- 타입으로 찾음
- required=false 가능

```java
@Service
public class ApprovalService {
    @Autowired
    private ApprovalRepository repository;
    // 타입이 ApprovalRepository인 Bean 주입
}
```

같은 타입이 여러 개면:

```java
@Autowired
@Qualifier("approvalRepo")
private ApprovalRepository repository;
```

**@Resource (Java 표준 - javax.annotation)**
- 이름으로 찾음

```java
@Resource(name = "approvalRepository")
private ApprovalRepository repository;
```

**@Inject (Java 표준 - javax.inject)**
- @Autowired랑 거의 같음
- required 옵션 없음

BizSync에서는 @Autowired 대신 생성자 주입을 씁니다:

```java
@Service
@RequiredArgsConstructor  // Lombok
public class ApprovalService {
    private final ApprovalRepository repository;
    // 생성자 자동 생성 + 자동 주입
}
```

**왜 생성자 주입?**

1. final 사용 가능 (불변)
2. 테스트 쉬움
3. 순환 참조 방지

필드 주입의 문제:

```java
@Service
public class ApprovalService {
    @Autowired
    private ApprovalRepository repository;
    
    // 테스트 시 어떻게 주입?
    // Reflection 써야 함
}
```

생성자 주입:

```java
@Service
public class ApprovalService {
    private final ApprovalRepository repository;
    
    public ApprovalService(ApprovalRepository repository) {
        this.repository = repository;
    }
}

// 테스트
@Test
void test() {
    ApprovalRepository mock = mock(...);
    ApprovalService service = new ApprovalService(mock);
    // 쉽게 주입!
}
```

정리:
- 실무: 생성자 주입 + @RequiredArgsConstructor
- @Autowired: 레거시 코드에서 볼 수 있음
- @Resource, @Inject: 거의 안 씀

---

### **Q13. @Controller vs @RestController**

**면접관**: 둘의 차이를 설명해주세요.

**답변**:

@Controller는 View를 반환하고 @RestController는 데이터를 반환합니다.

**@Controller:**

```java
@Controller
public class PageController {
    @GetMapping("/home")
    public String home() {
        return "home";  // home.html 찾음
    }
    
    @GetMapping("/user")
    public String user(Model model) {
        model.addAttribute("name", "홍길동");
        return "user";  // user.html로 전달
    }
}
```

**@RestController:**

```java
@RestController
public class ApprovalController {
    @GetMapping("/api/approvals")
    public List<Approval> getApprovals() {
        return approvalService.findAll();
        // JSON으로 변환되어 응답
    }
}
```

@RestController는 사실:

```java
@Controller
@ResponseBody  // 모든 메서드에 자동으로
public class ApprovalController {
    // ...
}
```

BizSync는 React + Spring 구조라서 모든 Controller가 @RestController입니다:

```java
@RestController
@RequiredArgsConstructor
public class ProjectController {
    
    @GetMapping("/api/projects/{id}")
    public ResponseEntity<Project> getProject(@PathVariable Long id) {
        Project project = projectService.findById(id);
        return ResponseEntity.ok(project);
        // JSON 응답: {"projectId": 1, "name": "프로젝트A", ...}
    }
}
```

만약 @Controller로 데이터 반환하려면:

```java
@Controller
public class ApprovalController {
    
    @GetMapping("/api/approvals")
    @ResponseBody  // 이걸 매번 붙여야 함
    public List<Approval> getApprovals() {
        return approvalService.findAll();
    }
}
```

View + API 혼용:

```java
@Controller
public class MixedController {
    
    @GetMapping("/page")
    public String page() {
        return "page";  // HTML
    }
    
    @GetMapping("/api/data")
    @ResponseBody
    public Data getData() {
        return new Data();  // JSON
    }
}
```

정리:
- SPA (React, Vue): @RestController
- 전통적 MVC: @Controller
- 혼용: @Controller + @ResponseBody

---

### **Q14. @Transactional**

**면접관**: @Transactional의 기본 동작을 설명해주세요.

**답변**:

@Transactional은 메서드를 트랜잭션으로 감싸줍니다.

**기본 동작:**

```java
@Transactional
public void approveDocument(Long docId) {
    // 1. 트랜잭션 시작
    
    ApprovalDocument doc = repository.findById(docId);
    doc.approve();  // 상태 변경
    
    ApprovalLine line = lineRepository.findByDocId(docId);
    line.setStatus(APPROVED);  // 라인 상태 변경
    
    // 2. 예외 없으면 COMMIT
    // 3. 예외 발생하면 ROLLBACK
}
```

BizSync 실제 코드:

```java
@Service
@RequiredArgsConstructor
@Transactional
public class ApprovalService {
    
    @Transactional
    public void approveDocument(Long docId) {
        ApprovalDocument doc = docRepository.findByIdOrThrow(docId);
        
        // 결재 승인
        doc.approve();
        
        // 다음 결재자에게 알림
        notificationService.notify(doc.getNextApproverId());
        
        // 모두 성공하면 COMMIT
        // 중간에 예외 → ROLLBACK
    }
}
```

만약 트랜잭션 없으면:

```java
public void approveDocument(Long docId) {
    doc.approve();  // DB UPDATE
    
    // 여기서 예외 발생!
    throw new RuntimeException();
    
    // 이미 approve는 저장됨 → 데이터 불일치!
}
```

@Transactional 붙이면:

```java
@Transactional
public void approveDocument(Long docId) {
    doc.approve();  // 변경사항 메모리에만
    
    throw new RuntimeException();
    
    // ROLLBACK → approve 취소됨
}
```

**readOnly 옵션:**

```java
@Transactional(readOnly = true)
public ApprovalDocument findDocument(Long id) {
    return docRepository.findById(id);
    // 읽기 전용 → 성능 최적화
}
```

readOnly = true 장점:
1. Dirty Checking 안 함
2. 스냅샷 안 만듦  
3. flush 안 함
→ 메모리, CPU 절약

**주의사항:**

**1. private 메서드는 안 됨!**

```java
@Transactional
private void approve() { }  // 프록시 못 만듦
```

**2. 같은 클래스 내부 호출은 안 됨!**

```java
public void process() {
    approve();  // @Transactional 안 먹힘
}

@Transactional
public void approve() { }
```

왜? this.approve()라서 프록시를 안 거침

해결: 다른 Bean에서 호출

정리:
- 메서드 전체를 트랜잭션으로
- 예외 시 자동 롤백
- readOnly로 최적화
- public 메서드만 가능

---

### **Q15. AOP (Aspect-Oriented Programming)**

**면접관**: AOP가 무엇이고 언제 사용하나요?

**답변**:

AOP는 공통 관심사를 비즈니스 로직에서 분리하는 기법입니다.

예를 들어 모든 Service 메서드에 로그를 남기고 싶다면:

**AOP 없이:**

```java
public void createProject() {
    log.info("createProject 시작");
    // 실제 로직
    log.info("createProject 종료");
}

public void updateProject() {
    log.info("updateProject 시작");
    // 실제 로직  
    log.info("updateProject 종료");
}
// 중복 코드!
```

**AOP 사용:**

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Around("execution(* com.bizsync.backend.service.*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) 
        throws Throwable {
        
        long start = System.currentTimeMillis();
        
        Object result = joinPoint.proceed();  // 실제 메서드 실행
        
        long end = System.currentTimeMillis();
        
        log.info("{} 실행시간: {}ms", 
            joinPoint.getSignature(), 
            end - start);
        
        return result;
    }
}
```

이제 모든 Service 메서드에 자동으로 로그가 남습니다!

**BizSync에서 사용한 AOP:**

**1. 권한 체크**

```java
@Aspect
@Component
public class SecurityAspect {
    
    @Before("@annotation(RequireProjectLeader)")
    public void checkProjectLeader(JoinPoint joinPoint) {
        Long projectId = (Long) joinPoint.getArgs()[0];
        Long userId = SecurityUtil.getCurrentUserId();
        
        if (!isProjectLeader(projectId, userId)) {
            throw new ForbiddenException();
        }
    }
}

// Service에서 사용
@Service
public class KanbanService {
    
    @RequireProjectLeader
    public void deleteColumn(Long projectId, Long columnId) {
        // 권한 체크는 AOP가 자동으로!
        columnRepository.deleteById(columnId);
    }
}
```

**2. 실행 시간 측정**

```java
@Around("@annotation(Timed)")
public Object measureTime(ProceedingJoinPoint pjp) throws Throwable {
    StopWatch sw = new StopWatch();
    sw.start();
    
    Object result = pjp.proceed();
    
    sw.stop();
    log.info("실행시간: {}ms", sw.getTotalTimeMillis());
    
    return result;
}
```

**주요 애노테이션:**

- @Before: 메서드 실행 전
- @After: 메서드 실행 후 (예외 상관없이)
- @AfterReturning: 정상 종료 후
- @AfterThrowing: 예외 발생 후
- @Around: 전후 모두 (가장 강력)

**언제 사용?**
- 로깅
- 트랜잭션 관리 (@Transactional)
- 보안 체크
- 성능 측정
- 예외 처리

Spring이 AOP로 구현한 것들:
- @Transactional
- @Cacheable
- @Async

---

## **Part 3: JPA 기초 (15개)**

### **Q16. Entity 생명주기**

**면접관**: JPA Entity의 생명주기 상태를 설명해주세요.

**답변**:

Entity는 4가지 상태가 있습니다:

**1. 비영속 (new/transient)**
- 영속성 컨텍스트와 무관
- 그냥 new로 만든 상태

**2. 영속 (managed)**
- 영속성 컨텍스트가 관리
- DB와 동기화됨

**3. 준영속 (detached)**
- 영속성 컨텍스트에서 분리
- DB와 동기화 안 됨

**4. 삭제 (removed)**
- 삭제 예정

예시로 설명:

```java
// 1. 비영속
User user = new User();
user.setName("홍길동");
// 아직 DB와 무관

// 2. 영속
em.persist(user);
// 영속성 컨텍스트에 저장
// 아직 DB INSERT는 안 됨!

// 3. 준영속
em.detach(user);
user.setName("김철수");  // 변경해도 DB 반영 안 됨

// 4. 삭제
em.remove(user);
// 삭제 예약
```

BizSync 실제 코드:

```java
@Transactional
public void approveDocument(Long docId) {
    // 영속 상태로 조회
    ApprovalDocument doc = repository.findById(docId).get();
    
    // 엔티티 수정
    doc.approve();
    doc.setApprovedAt(LocalDateTime.now());
    
    // save() 안 해도 됨!
    // 트랜잭션 끝날 때 자동 UPDATE
}
```

**왜 자동 UPDATE?**

영속 상태의 엔티티는 변경 감지(Dirty Checking)가 동작합니다:

1. 조회 시 스냅샷 저장
2. 트랜잭션 종료 시 현재 상태와 비교
3. 변경되었으면 UPDATE 쿼리 자동 생성
4. flush()로 DB 반영

**준영속 상태 만드는 방법:**

```java
// 1. detach
em.detach(user);

// 2. clear  
em.clear();  // 전체 비움

// 3. close
em.close();  // 영속성 컨텍스트 종료

// 4. 트랜잭션 범위 벗어남
@Transactional
public User findUser(Long id) {
    return repository.findById(id);
    // 여기서 영속
}
// 메서드 끝나면 준영속
```

준영속 상태에서 Lazy Loading:

```java
User user = findUser(1L);  // 준영속
user.getProjects().size();  // LazyInitializationException!
```

해결:
1. fetch join
2. @Transactional 안에서 접근
3. DTO로 변환

정리:
- 비영속: new
- 영속: persist, find
- 준영속: detach, 트랜잭션 종료
- 삭제: remove

---

### **Q17. 즉시 로딩 vs 지연 로딩**

**면접관**: EAGER와 LAZY의 차이를 설명해주세요.

**답변**:

즉시 로딩(EAGER)은 엔티티 조회할 때 연관 엔티티도 같이 가져옵니다.

지연 로딩(LAZY)은 실제 사용할 때 가져옵니다.

**예시:**

```java
@Entity
public class Task {
    @ManyToOne(fetch = FetchType.EAGER)
    private User worker;  // 즉시 로딩
}

Task task = taskRepository.findById(1L);
// SELECT * FROM task t 
//   JOIN users u ON t.worker_id = u.user_id

// task를 조회하면 user도 자동으로 가져옵니다.
```

```java
@Entity  
public class Task {
    @ManyToOne(fetch = FetchType.LAZY)
    private User worker;  // 지연 로딩
}

Task task = taskRepository.findById(1L);
// SELECT * FROM task WHERE task_id = 1

String name = task.getWorker().getName();
// SELECT * FROM users WHERE user_id = ?
// 이 시점에 쿼리 실행!
```

BizSync는 모든 연관관계를 LAZY로:

```java
@Entity
public class ProjectMember {
    @ManyToOne(fetch = FetchType.LAZY)
    private Project project;
    
    @ManyToOne(fetch = FetchType.LAZY)
    private User user;
}
```

**왜 LAZY를 선호?**

**1. N+1 문제 방지**

```java
// EAGER면
List<Task> tasks = taskRepository.findAll();
// SELECT * FROM task t 
//   JOIN users u ...
//   JOIN kanban_column c ...
// 모든 연관 엔티티 JOIN → 쿼리 무거움

// LAZY면  
List<Task> tasks = taskRepository.findAll();
// SELECT * FROM task
// 필요한 것만!
```

**2. 성능 제어 가능**

```java
// 필요할 때만 fetch join
@Query("SELECT t FROM Task t JOIN FETCH t.worker WHERE t.id = :id")
Task findByIdWithWorker(@Param("id") Long id);
```

**EAGER의 문제:**

```java
@Entity
public class Project {
    @OneToMany(fetch = FetchType.EAGER)
    private List<ProjectMember> members;  // 항상 가져옴
}

Project project = projectRepository.findById(1L);
// 멤버 안 쓰는데도 무조건 조회!
```

**LAZY 사용 시 주의:**

```java
Task task = taskRepository.findById(1L);
// 트랜잭션 종료

task.getWorker().getName();  
// LazyInitializationException!
```

**해결:**

**1. 트랜잭션 안에서 접근**

```java
@Transactional
public TaskDTO getTask(Long id) {
    Task task = taskRepository.findById(id);
    return new TaskDTO(
        task.getId(),
        task.getWorker().getName()  // OK
    );
}
```

**2. fetch join**

```java
@Query("SELECT t FROM Task t JOIN FETCH t.worker")
List<Task> findAllWithWorker();
```

**3. DTO 프로젝션**

```java
@Query("SELECT new TaskDTO(t.id, u.name) " +
       "FROM Task t JOIN t.worker u")
List<TaskDTO> findAllDTO();
```

정리:
- 기본: LAZY
- 항상 함께 조회: fetch join
- 선택적 EAGER는 지양

---

### **Q18. 영속성 전이 (Cascade)**

**면접관**: CascadeType의 종류와 사용 사례를 설명해주세요.

**답변**:

Cascade는 부모 엔티티의 작업을 자식에게 전파하는 겁니다.

**종류:**

1. PERSIST: 저장 전파
2. REMOVE: 삭제 전파
3. MERGE: 병합 전파
4. REFRESH: 새로고침 전파
5. DETACH: 준영속 전파
6. ALL: 전부

BizSync 예시:

```java
@Entity
public class Project {
    
    @OneToMany(
        mappedBy = "project",
        cascade = CascadeType.ALL,
        orphanRemoval = true
    )
    private List<KanbanColumn> columns = new ArrayList<>();
}
```

**PERSIST 전파:**

```java
Project project = new Project("신규 프로젝트");

KanbanColumn todo = new KanbanColumn("TODO");
KanbanColumn doing = new KanbanColumn("DOING");

project.addColumn(todo);
project.addColumn(doing);

projectRepository.save(project);
// project만 save해도
// column들도 자동 저장!
```

Cascade 없으면:

```java
projectRepository.save(project);
columnRepository.save(todo);    // 각각 저장해야 함
columnRepository.save(doing);
```

**REMOVE 전파:**

```java
projectRepository.delete(project);
// project 삭제하면
// 연관된 column들도 자동 삭제!
```

**orphanRemoval = true:**

```java
project.getColumns().remove(0);
// 컬렉션에서 제거하면
// DB에서도 삭제!
```

실제 사용:

```java
@Service
@Transactional
public class ProjectService {
    
    public void createProject(ProjectCreateDTO dto) {
        Project project = new Project(dto.getName());
        
        // 기본 컬럼 생성
        project.addColumn(new KanbanColumn("TODO", 1));
        project.addColumn(new KanbanColumn("DOING", 2));
        project.addColumn(new KanbanColumn("DONE", 3));
        
        projectRepository.save(project);
        // 1번의 save로 4개 INSERT!
        // INSERT INTO project ...
        // INSERT INTO kanban_column ... (TODO)
        // INSERT INTO kanban_column ... (DOING)  
        // INSERT INTO kanban_column ... (DONE)
    }
}
```

**주의사항:**

**1. 양방향 연관관계 편의 메서드**

```java
public void addColumn(KanbanColumn column) {
    columns.add(column);
    column.setProject(this);  // 양방향 설정!
}
```

**2. Cascade.REMOVE vs orphanRemoval**

```java
// Cascade.REMOVE
project.getColumns().clear();
projectRepository.delete(project);  // 삭제됨

// orphanRemoval = true
project.getColumns().clear();
// clear만 해도 삭제됨!
```

**3. 다대다는 Cascade 조심**

```java
@ManyToMany(cascade = CascadeType.ALL)
private List<Tag> tags;

project.getTags().add(tag);
projectRepository.delete(project);
// tag까지 삭제될 수 있음!
```

**언제 사용?**
- 부모-자식 관계가 명확할 때
- 생명주기가 같을 때
- Project ↔ KanbanColumn (O)
- User ↔ Project (X, 독립적)

정리:
- PERSIST: 저장 편의
- REMOVE + orphanRemoval: 삭제 자동화
- 신중하게 사용

---

### **Q19. @Id 생성 전략**

**면접관**: @GeneratedValue의 전략들을 설명해주세요.

**답변**:

JPA에는 4가지 ID 생성 전략이 있습니다:

1. AUTO (기본값) - DB에 맞게 자동 선택
2. IDENTITY - DB의 AUTO_INCREMENT 사용
3. SEQUENCE - DB 시퀀스 사용
4. TABLE - 별도 테이블로 관리

BizSync는 IDENTITY 사용:

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;
}
```

MariaDB/MySQL은 AUTO_INCREMENT를 쓰니까 IDENTITY가 적합합니다.

**각 전략 차이:**

**IDENTITY:**

```java
User user = new User("홍길동");
userRepository.save(user);

System.out.println(user.getUserId());  // 1
// save()할 때 즉시 INSERT
// DB가 ID를 생성해서 돌려줌
```

**SEQUENCE (Oracle, PostgreSQL):**

```java
@Id
@GeneratedValue(
    strategy = GenerationType.SEQUENCE,
    generator = "user_seq"
)
@SequenceGenerator(
    name = "user_seq",
    sequenceName = "user_sequence",
    allocationSize = 50
)
private Long userId;

// save() 전에 시퀀스 조회
// INSERT는 flush 시점
```

**TABLE:**

```java
@Id
@GeneratedValue(
    strategy = GenerationType.TABLE,
    generator = "user_gen"
)
@TableGenerator(
    name = "user_gen",
    table = "id_generator",
    pkColumnValue = "user_id"
)
private Long userId;

// 별도 테이블에서 ID 관리
// 성능 안 좋아서 거의 안 씀
```

**IDENTITY의 단점:**

```java
@Transactional
public void createUsers() {
    for (int i = 0; i < 100; i++) {
        userRepository.save(new User("User" + i));
        // 100번 INSERT! (배치 안 됨)
    }
}
```

IDENTITY는 INSERT 해야 ID를 알 수 있어서 배치 INSERT가 불가능합니다.

SEQUENCE는 가능:
- allocationSize = 50으로 하면 50개씩 미리 받아서 메모리에 캐싱
- 배치 INSERT 가능

하지만 MariaDB는 시퀀스가 없으니 IDENTITY를 쓸 수밖에 없습니다.

**대안: JDBC batch:**

```yaml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 50
```

하지만 IDENTITY면 이것도 안 됩니다.

**UUID 사용:**

```java
@Id
@GeneratedValue(generator = "uuid2")
@GenericGenerator(name = "uuid2", strategy = "uuid2")
@Column(columnDefinition = "CHAR(36)")
private String id;
```

장점:
- 애플리케이션에서 생성
- 배치 가능
- 분산 환경 유리

단점:
- 크기 큼 (36 bytes)
- 인덱스 성능 저하

BizSync 선택:
- MariaDB → IDENTITY
- 단순하고 안정적
- 성능 이슈 없음

정리:
- MySQL/MariaDB: IDENTITY
- Oracle/PostgreSQL: SEQUENCE
- 범용: AUTO
- 특수: TABLE or UUID

[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]