## **Part 11: Spring 심화 (15개)**

### **Q76. Spring Boot Auto Configuration**

**면접관**: Spring Boot의 자동 설정은 어떻게 동작하나요?

**답변**:

Spring Boot는 @EnableAutoConfiguration으로 필요한 Bean들을 자동으로 등록합니다.

**동작 과정:**

@SpringBootApplication 안에 @EnableAutoConfiguration이 포함되어 있고, 이게 spring.factories 파일을 읽어서 자동 설정 클래스들을 찾습니다.

예를 들어 pom.xml에 spring-boot-starter-data-jpa를 추가하면, 자동으로 DataSource, EntityManagerFactory, TransactionManager 같은 Bean들이 등록됩니다.

**조건부 설정:**

```java
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean
public DataSource dataSource() {
    // DataSource 클래스가 있고
    // 아직 Bean이 없으면 생성
}
```

**BizSync에서 경험:**

application.yml만 설정하면 복잡한 설정 없이 바로 동작합니다.

```yaml
spring:
  datasource:
    url: jdbc:mariadb://localhost:3306/bizsync
    username: root
    password: 1234
```

이것만으로 DataSource, JPA 전부 설정됩니다.

**커스터마이징:**

만약 커스터마이징이 필요하면 직접 Bean을 등록하면 됩니다.

```java
@Bean
public DataSource customDataSource() {
    // 내 방식대로 설정
}
```

자동 설정보다 내가 만든 Bean이 우선됩니다.

정리:
- classpath 확인 → 필요한 Bean 자동 생성
- 조건부 설정으로 충돌 방지
- 설정 파일로 간편하게 커스터마이징

---

### **Q77. Spring Profile**

**면접관**: Profile은 어떻게 사용하나요?

**답변**:

Profile은 환경별로 다른 설정을 쓸 때 사용합니다.

**BizSync는 세 가지 Profile:**

1. local: 로컬 개발
2. dev: 개발 서버
3. prod: 운영 서버

**파일 구조:**

```
application.yml              # 공통 설정
application-local.yml        # 로컬
application-dev.yml          # 개발
application-prod.yml         # 운영
```

**공통 설정:**

```yaml
spring:
  application:
    name: bizsync
  jpa:
    show-sql: true
```

**로컬 설정:**

```yaml
spring:
  datasource:
    url: jdbc:mariadb://localhost:3306/bizsync
  config:
    activate:
      on-profile: local
```

**운영 설정:**

```yaml
spring:
  datasource:
    url: jdbc:mariadb://prod-db:3306/bizsync
  jpa:
    show-sql: false  # 운영에서는 끄기
  config:
    activate:
      on-profile: prod
```

**Profile 활성화:**

```yaml
// 1. application.yml
spring:
  profiles:
    active: local
```

```bash
// 2. 실행 시 지정
java -jar app.jar --spring.profiles.active=prod

// 3. 환경 변수
export SPRING_PROFILES_ACTIVE=prod
```

**Bean도 Profile별로 등록:**

```java
@Configuration
@Profile("local")
public class LocalConfig {
    @Bean
    public DataSource dataSource() {
        // H2 같은 테스트 DB
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        // 실제 운영 DB
    }
}
```

**BizSync Docker 배포:**

```bash
docker run -e SPRING_PROFILES_ACTIVE=prod bizsync
```

환경 변수로 Profile을 주입합니다.

**민감 정보 처리:**

application-prod.yml에 DB 비밀번호를 직접 쓰면 위험하니까 환경 변수로 주입합니다.

```yaml
spring:
  datasource:
    password: ${DB_PASSWORD}
```

정리:
- 환경별 설정 분리
- Profile 파일로 관리
- 민감 정보는 환경 변수

---

### **Q78. Spring Bean Lifecycle**

**면접관**: Spring Bean의 생명주기 콜백을 설명해주세요.

**답변**:

Bean이 생성되고 소멸될 때 특정 메서드를 실행할 수 있습니다.

**세 가지 방법:**

**1. @PostConstruct / @PreDestroy**

```java
@Component
public class InitialDataLoader {
    
    @PostConstruct
    public void init() {
        // Bean 생성 직후 실행
        log.info("초기 데이터 로딩 시작");
        createAdminUser();
    }
    
    @PreDestroy
    public void cleanup() {
        // Bean 소멸 직전 실행
        log.info("리소스 정리");
    }
}
```

**2. InitializingBean / DisposableBean**

```java
public class MyBean implements InitializingBean, DisposableBean {
    
    @Override
    public void afterPropertiesSet() {
        // 초기화
    }
    
    @Override
    public void destroy() {
        // 종료
    }
}
```

**3. @Bean(initMethod, destroyMethod)**

```java
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public MyService myService() {
        return new MyService();
    }
}
```

**BizSync에서 실제 사용:**

```java
@Component
public class WebSocketConnectionManager {
    
    private StompClient client;
    
    @PostConstruct
    public void connect() {
        client = new StompClient();
        client.connect(WS_URL);
        log.info("WebSocket 연결 완료");
    }
    
    @PreDestroy
    public void disconnect() {
        if (client != null) {
            client.disconnect();
            log.info("WebSocket 연결 해제");
        }
    }
}
```

**Bean 생성 순서:**

1. 생성자 호출
2. 의존성 주입
3. @PostConstruct 실행
4. Bean 사용 가능

**소멸 순서:**

1. @PreDestroy 실행
2. Bean 소멸

**초기 데이터 로딩:**

```java
@Component
public class InitialDataLoader {
    
    @PostConstruct
    public void loadData() {
        if (userRepository.count() == 0) {
            User admin = new User("admin", "1234");
            userRepository.save(admin);
        }
    }
}
```

**주의사항:**

@PostConstruct는 생성자 다음에 실행되니까 의존성이 주입된 상태입니다.

생성자에서 repository.save() 하면 NullPointerException 날 수 있지만 @PostConstruct에서는 안전합니다.

정리:
- 초기화: @PostConstruct
- 종료: @PreDestroy
- 리소스 관리에 유용

---

### **Q79. ApplicationContext vs BeanFactory**

**면접관**: ApplicationContext와 BeanFactory의 차이는?

**답변**:

BeanFactory는 기본적인 DI 컨테이너고, ApplicationContext는 더 많은 기능을 제공합니다.

**차이점:**

**BeanFactory:**
- 기본 DI 기능만
- Lazy Loading (요청 시 Bean 생성)
- 가벼움

**ApplicationContext:**
- BeanFactory 기능 전부 + α
- Eager Loading (시작 시 Bean 생성)
- 이벤트, 국제화, AOP 등 지원

실무에서는 무조건 ApplicationContext 씁니다.

**Spring Boot 앱 시작:**

```java
@SpringBootApplication
public class BackendApplication {
    public static void main(String[] args) {
        ApplicationContext context = 
            SpringApplication.run(BackendApplication.class, args);
    }
}
```

ApplicationContext가 생성됩니다.

**Bean 가져오기:**

```java
UserService userService = 
    context.getBean(UserService.class);
```

하지만 실무에서 직접 getBean()은 거의 안 씁니다. 의존성 주입으로 충분하니까요.

**ApplicationContext가 제공하는 기능:**

**1. 이벤트 발행**

```java
@Component
public class EventPublisher {
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void publish() {
        publisher.publishEvent(new CustomEvent());
    }
}
```

**2. 환경 정보 접근**

```java
@Autowired
private Environment env;

String dbUrl = env.getProperty("spring.datasource.url");
```

**3. 리소스 로딩**

```java
Resource resource = 
    context.getResource("classpath:data.json");
```

**BizSync에서 이벤트 사용:**

결재 승인되면 이벤트 발행하고 여러 리스너가 처리합니다.

```java
@TransactionalEventListener
public void onApprovalApproved(ApprovalApprovedEvent event) {
    // 알림 전송
    // 통계 업데이트
    // 등등
}
```

정리:
- 실무: ApplicationContext
- BeanFactory: 레거시나 특수 상황
- 이벤트, 환경 변수 등 다양한 기능

---

### **Q80. Spring Event**

**면접관**: Spring Event는 언제 사용하나요?

**답변**:

이벤트는 모듈 간 결합도를 낮출 때 사용합니다.

**예를 들어 결재 승인 로직:**

나쁨 - 강한 결합:

```java
@Transactional
public void approve(Long docId) {
    doc.approve();
    
    // 다른 모듈 직접 호출
    notificationService.send();
    statisticsService.update();
    emailService.send();
    
    // ApprovalService가 너무 많이 알아야 함!
}
```

좋음 - 이벤트 사용:

```java
@Transactional
public void approve(Long docId) {
    doc.approve();
    
    // 이벤트만 발행
    eventPublisher.publishEvent(
        new ApprovalApprovedEvent(docId)
    );
    
    // 누가 처리하는지 몰라도 됨
}
```

**이벤트 클래스:**

```java
public class ApprovalApprovedEvent {
    private final Long documentId;
    
    public ApprovalApprovedEvent(Long documentId) {
        this.documentId = documentId;
    }
    
    public Long getDocumentId() {
        return documentId;
    }
}
```

**리스너들:**

```java
@Component
public class NotificationEventListener {
    
    @EventListener
    public void handleApprovalApproved(ApprovalApprovedEvent event) {
        // 알림 전송
        notificationService.send(event.getDocumentId());
    }
}

@Component
public class StatisticsEventListener {
    
    @EventListener
    public void handleApprovalApproved(ApprovalApprovedEvent event) {
        // 통계 업데이트
        statisticsService.update();
    }
}
```

**트랜잭션과 함께:**

```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void handleApprovalApproved(ApprovalApprovedEvent event) {
    // 트랜잭션 커밋 후에 실행
    // 롤백되면 실행 안 됨
}
```

**비동기 처리:**

```java
@Async
@EventListener
public void handleApprovalApproved(ApprovalApprovedEvent event) {
    // 별도 스레드에서 실행
}
```

**장점:**

1. **결합도 낮음**
   - ApprovalService는 이벤트만 발행
   - 누가 처리하는지 몰라도 됨

2. **확장 쉬움**
   - 새 리스너 추가만 하면 됨
   - 기존 코드 수정 불필요

3. **테스트 쉬움**
   - 각 리스너 독립적으로 테스트

**주의사항:**

리스너에서 예외 발생하면 다른 리스너도 실행 안 됩니다.

```java
@EventListener
@Order(1)
public void listener1() {
    throw new RuntimeException();
}

@EventListener
@Order(2)
public void listener2() {
    // 실행 안 됨!
}
```

각 리스너에서 try-catch 필요:

```java
@EventListener
public void handle(Event event) {
    try {
        // 처리
    } catch (Exception e) {
        log.error("처리 실패", e);
    }
}
```

정리:
- 모듈 간 결합도 낮추기
- 트랜잭션 이후 처리
- 비동기 작업에 유용

---

### **Q81. Spring Batch (간단히)**

**면접관**: Spring Batch를 들어보셨나요?

**답변**:

Spring Batch는 대용량 데이터를 배치로 처리하는 프레임워크입니다.

BizSync에서 직접 쓰진 않았지만 개념은 알고 있습니다.

**사용 사례:**

- 매일 밤 통계 집계
- 대량 메일 발송
- 데이터 마이그레이션
- 정산 처리

**기본 구조:**

```
Job → Step → Reader → Processor → Writer
```

**예시:**

```java
@Bean
public Job userStatisticsJob() {
    return jobBuilderFactory.get("userStats")
        .start(calculateStep())
        .build();
}

@Bean
public Step calculateStep() {
    return stepBuilderFactory.get("calculate")
        .<User, UserStatistics>chunk(1000)
        .reader(userReader())      // DB에서 읽기
        .processor(userProcessor()) // 통계 계산
        .writer(userWriter())      // DB에 쓰기
        .build();
}
```

1000개씩 끊어서 처리합니다.

**만약 BizSync에서 사용한다면:**

매일 자정에 프로젝트별 통계를 집계하는 배치 작업을 만들 것 같습니다.

- 완료된 Task 개수
- 평균 처리 시간
- 결재 승인율

Quartz나 Linux cron으로 스케줄링하면 되고요.

정리:
- 대용량 배치 처리
- Reader → Processor → Writer
- 청크 단위 처리

---

### **Q82. Spring Security Architecture**

**면접관**: Spring Security의 필터 체인을 설명해주세요.

**답변**:

Spring Security는 여러 필터가 체인으로 연결되어 동작합니다.

**요청 흐름:**

```
Client 요청
  ↓
DelegatingFilterProxy
  ↓
FilterChainProxy
  ↓
SecurityFilterChain
  - SecurityContextPersistenceFilter
  - LogoutFilter
  - UsernamePasswordAuthenticationFilter
  - JwtAuthenticationFilter (커스텀)
  - ExceptionTranslationFilter
  - FilterSecurityInterceptor
  ↓
Controller
```

**BizSync에서 추가한 JWT 필터:**

```java
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {
        
        // 1. 토큰 추출
        String token = extractToken(request);
        
        // 2. 토큰 검증
        if (token != null && jwtProvider.validateToken(token)) {
            // 3. SecurityContext에 인증 정보 설정
            Authentication auth = getAuthentication(token);
            SecurityContextHolder.getContext()
                .setAuthentication(auth);
        }
        
        // 4. 다음 필터로
        filterChain.doFilter(request, response);
    }
}
```

**SecurityConfig에 등록:**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
            );
        
        return http.build();
    }
}
```

**인증 vs 인가:**

- 인증(Authentication): 너 누구야?
- 인가(Authorization): 이거 할 수 있어?

**SecurityContext:**

스레드마다 독립적으로 저장되는 인증 정보입니다.

```java
Authentication auth = 
    SecurityContextHolder.getContext()
        .getAuthentication();

Long userId = (Long) auth.getPrincipal();
```

**Controller에서 사용:**

```java
@GetMapping("/api/users/me")
public User getMyInfo(@AuthenticationPrincipal Long userId) {
    return userService.findById(userId);
}
```

정리:
- 필터 체인으로 인증/인가
- JWT 필터 커스텀 추가
- SecurityContext에 인증 정보 저장

---

### **Q83. @Valid vs @Validated**

**면접관**: @Valid와 @Validated의 차이는?

**답변**:

둘 다 유효성 검증인데 기능이 조금 다릅니다.

**@Valid (Java 표준):**
- 중첩 객체 검증 지원
- 그룹 검증 불가

**@Validated (Spring):**
- 그룹 검증 가능
- 중첩 객체 검증 불가
- 메서드 레벨 검증 가능

**기본 사용:**

```java
public class CreateProjectDTO {
    
    @NotBlank(message = "프로젝트명은 필수입니다")
    @Size(max = 50)
    private String name;
    
    @NotNull
    @Valid  // 중첩 객체 검증
    private LeaderDTO leader;
}
```

**Controller:**

```java
@PostMapping("/api/projects")
public Project create(@Valid @RequestBody CreateProjectDTO dto) {
    return projectService.create(dto);
}
```

검증 실패 시 MethodArgumentNotValidException 발생

**예외 처리:**

```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<ErrorResponse> handleValidation(
    MethodArgumentNotValidException e
) {
    List<String> errors = e.getBindingResult()
        .getFieldErrors()
        .stream()
        .map(error -> error.getField() + ": " + error.getDefaultMessage())
        .toList();
    
    return ResponseEntity.badRequest()
        .body(new ErrorResponse(errors));
}
```

**그룹 검증 (@Validated):**

```java
interface Create {}
interface Update {}

public class UserDTO {
    
    @Null(groups = Create.class)
    @NotNull(groups = Update.class)
    private Long userId;
    
    @NotBlank(groups = {Create.class, Update.class})
    private String name;
}
```

```java
@PostMapping
public User create(@Validated(Create.class) @RequestBody UserDTO dto) {
    // userId는 null이어야 함
}

@PutMapping
public User update(@Validated(Update.class) @RequestBody UserDTO dto) {
    // userId는 필수
}
```

**커스텀 Validator:**

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
public @interface ValidEmail {
    String message() default "올바른 이메일 형식이 아닙니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class EmailValidator implements ConstraintValidator<ValidEmail, String> {
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return value != null && value.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
}
```

사용:

```java
@ValidEmail
private String email;
```

정리:
- 기본: @Valid
- 그룹 검증: @Validated
- 중첩 객체: @Valid
- 커스텀 검증기 만들기 가능

---

### **Q84. @Async**

**면접관**: 비동기 처리는 어떻게 하나요?

**답변**:

@Async 애노테이션으로 메서드를 별도 스레드에서 실행할 수 있습니다.

**활성화:**

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

**사용:**

```java
@Service
public class NotificationService {
    
    @Async
    public void sendEmail(String to, String content) {
        // 별도 스레드에서 실행
        emailClient.send(to, content);
    }
}
```

**호출:**

```java
notificationService.sendEmail("user@example.com", "알림");
// 바로 리턴, 백그라운드에서 실행
```

**BizSync에서 사용:**

결재 승인 후 알림은 응답을 기다릴 필요 없으니까 비동기로:

```java
@Transactional
public void approve(Long docId) {
    doc.approve();
    
    // 비동기로 알림
    notificationService.sendApprovalNotification(docId);
    
    // 바로 리턴
}
```

**Future 반환:**

```java
@Async
public CompletableFuture<String> processAsync() {
    // 시간 걸리는 작업
    String result = heavyProcess();
    
    return CompletableFuture.completedFuture(result);
}

// 호출
CompletableFuture<String> future = service.processAsync();
String result = future.get();  // 완료될 때까지 대기
```

**주의사항:**

**1. public 메서드만 가능**

```java
@Async
private void process() { }  // 안 됨!
```

**2. 같은 클래스 내부 호출 안 됨**

```java
public void caller() {
    asyncMethod();  // 비동기 안 됨!
}

@Async
public void asyncMethod() { }
```

프록시를 거쳐야 하는데 self 호출은 프록시를 안 거치니까요.

**3. 예외 처리**

```java
@Async
public void process() {
    throw new RuntimeException();
    // 예외가 삼켜짐!
}
```

AsyncUncaughtExceptionHandler 구현 필요:

```java
@Override
public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
    return (ex, method, params) -> {
        log.error("비동기 실행 중 예외: {}", method.getName(), ex);
    };
}
```

정리:
- 오래 걸리는 작업 비동기 처리
- ThreadPool 설정 중요
- public 메서드만
- 예외 처리 주의

---

### **Q85. @Cacheable**

**면접관**: Spring Cache는 어떻게 사용하나요?

**답변**:

@Cacheable로 메서드 결과를 캐싱합니다.

**활성화:**

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("projects", "users");
    }
}
```

**사용:**

```java
@Service
public class ProjectService {
    
    @Cacheable(value = "projects", key = "#id")
    public Project findById(Long id) {
        // 첫 호출: DB 조회 후 캐싱
        // 이후 호출: 캐시에서 바로 반환
        return projectRepository.findById(id).orElseThrow();
    }
}
```

**동작:**

```java
// 첫 번째 호출
Project p1 = service.findById(1L);  // DB 조회
// 두 번째 호출
Project p2 = service.findById(1L);  // 캐시 반환 (빠름!)
```

**캐시 갱신:**

```java
@CachePut(value = "projects", key = "#project.projectId")
public Project update(Project project) {
    Project updated = projectRepository.save(project);
    return updated;  // 캐시 업데이트
}
```

**캐시 삭제:**

```java
@CacheEvict(value = "projects", key = "#id")
public void delete(Long id) {
    projectRepository.deleteById(id);
    // 캐시에서도 삭제
}
```

**전체 캐시 삭제:**

```java
@CacheEvict(value = "projects", allEntries = true)
public void deleteAll() {
    projectRepository.deleteAll();
}
```

**조건부 캐싱:**

```java
@Cacheable(
    value = "projects",
    key = "#id",
    condition = "#id > 0",
    unless = "#result == null"
)
public Project findById(Long id) {
    // id가 양수이고 결과가 null이 아닐 때만 캐싱
}
```

**Redis 사용:**

의존성:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

설정:

```java
@Bean
public CacheManager cacheManager(RedisConnectionFactory factory) {
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofMinutes(10));  // 10분 후 만료
    
    return RedisCacheManager.builder(factory)
        .cacheDefaults(config)
        .build();
}
```

**BizSync에서 사용했다면:**

자주 조회되는 프로젝트 정보를 캐싱해서 DB 부하를 줄였을 겁니다.

```java
@Cacheable("projects")
public Project findById(Long id) {
    // 1000번 조회해도 DB는 1번만
}
```

**주의사항:**

캐시 무효화를 잊으면 오래된 데이터를 보게 됩니다.

수정/삭제 시 반드시 @CachePut이나 @CacheEvict 사용해야 합니다.

정리:
- 자주 조회되는 데이터 캐싱
- DB 부하 감소
- Redis로 분산 캐시 가능
- 무효화 전략 중요

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]