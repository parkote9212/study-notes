---
tags: teck-interview
---
네, 계속 진행하겠습니다!

---

### **Q49. 정렬 알고리즘**

**면접관**: 주요 정렬 알고리즘의 시간 복잡도를 비교해주세요.

**답변**:

```
네, 주요 정렬 알고리즘을 시간 복잡도로 비교해드리겠습니다.

먼저 O(n²) 알고리즘들이 있습니다.

버블 정렬은 인접한 원소끼리 비교하면서 정렬하는데요,
가장 단순하지만 느립니다.

for (int i = 0; i < n; i++) {
  for (int j = 0; j < n-1; j++) {
    if (arr[j] > arr[j+1]) {
      swap(arr[j], arr[j+1]);
    }
  }
}

선택 정렬은 매번 최솟값을 찾아서 앞으로 보내는 방식이고,
삽입 정렬은 카드 정렬하듯이 하나씩 적절한 위치에 삽입합니다.

그 다음 O(n log n) 알고리즘들입니다.

병합 정렬(Merge Sort)은 분할 정복 방식인데,
배열을 반으로 나누고 각각 정렬한 후 합칩니다.
안정 정렬이고 추가 메모리가 필요합니다.

퀵 정렬(Quick Sort)은 피벗을 기준으로
작은 것은 왼쪽, 큰 것은 오른쪽으로 보내는데요,
평균은 O(n log n)이지만 최악은 O(n²)입니다.

힙 정렬(Heap Sort)은 힙 자료구조를 이용하고,
추가 메모리가 필요 없습니다.

BizSync에서 실제로 쓸 때는
Java Collections.sort()를 쓰는데요,

List<Task> tasks = getTasks();
Collections.sort(tasks, 
  Comparator.comparing(Task::getDeadline));

이게 내부적으로 Tim Sort를 씁니다.
병합 정렬과 삽입 정렬을 섞은 건데
실제 데이터에서 가장 빠릅니다.

혹은 Stream으로:

tasks.stream()
  .sorted(Comparator.comparing(Task::getSequence))
  .collect(Collectors.toList());

직접 구현할 일은 거의 없지만,
면접에서는 퀵 정렬 정도는
손코딩할 수 있어야 한다고 들었습니다.

정리하면,
- O(n²): 버블, 선택, 삽입 (작은 데이터)
- O(n log n): 병합, 퀵, 힙 (일반적)
- 실무: Collections.sort() (Tim Sort)
```

---

### **Q50. 이진 탐색**

**면접관**: 이진 탐색을 설명하고 구현해보세요.

**답변**:

```
이진 탐색은 정렬된 배열에서
중간값과 비교하며 범위를 반씩 줄여가는 방법입니다.

시간 복잡도가 O(log n)이라서
데이터가 백만 개여도 20번 정도면 찾습니다.

동작 과정을 설명드리면,

[1, 3, 5, 7, 9, 11, 13]에서 7 찾기:

1. 중간(7) 확인 → 7 == 7 → 찾음!

9를 찾는다면:

1. 중간(7) → 9 > 7 → 오른쪽으로
2. [9, 11, 13] 중간(11) → 9 < 11 → 왼쪽으로
3. [9] → 찾음!

코드로 구현하면 이렇습니다.

int binarySearch(int[] arr, int target) {
  int left = 0;
  int right = arr.length - 1;
  
  while (left <= right) {
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
      return mid;  // 찾음
    } else if (arr[mid] < target) {
      left = mid + 1;  // 오른쪽
    } else {
      right = mid - 1;  // 왼쪽
    }
  }
  
  return -1;  // 못 찾음
}

mid를 (left + right) / 2로 안 하고
left + (right - left) / 2로 하는 이유는
오버플로우 방지입니다.

BizSync에서 실제로 쓸 때는
Collections.binarySearch()를 씁니다.

List<Integer> sequences = Arrays.asList(1, 3, 5, 7, 9);
int index = Collections.binarySearch(sequences, 7);

단, 배열이 정렬되어 있어야 합니다!
안 되어 있으면 결과가 이상하게 나옵니다.

DB에서 인덱스도 비슷한 원리입니다.
B-Tree 인덱스가 이진 탐색 트리처럼
반씩 줄여가며 찾으니까요.

정리:
- 전제 조건: 정렬된 배열
- 시간 복잡도: O(log n)
- 중간값 비교 후 범위 반으로
```

---

## **Part 9: Git/협업 (10개)**

### **Q51. Git 기본 명령어**

**면접관**: Git의 기본 워크플로우를 설명해주세요.

**답변**:

```
Git 워크플로우는 크게 세 단계입니다.

Working Directory → Staging Area → Repository

1. 파일 수정 (Working Directory)
2. git add (Staging Area로)
3. git commit (Repository에 저장)

BizSync 개발할 때 실제로 하는 과정은 이렇습니다.

// 1. 새 기능 브랜치 생성
git checkout -b feature/approval-system

// 2. 코드 작성
// ApprovalService.java 수정

// 3. 상태 확인
git status
# modified: ApprovalService.java
# untracked: ApprovalController.java

// 4. 스테이징
git add ApprovalService.java ApprovalController.java
// 또는
git add .  // 전체

// 5. 커밋
git commit -m "feat: 결재 시스템 구현

- ApprovalService 로직 추가
- ApprovalController API 구현
- 단위 테스트 작성"

// 6. 원격 저장소에 푸시
git push origin feature/approval-system

커밋 메시지 컨벤션은 이렇게 씁니다.

feat: 새 기능
fix: 버그 수정
docs: 문서 수정
refactor: 리팩토링
test: 테스트 추가
chore: 빌드, 설정 변경

예시:
feat: JWT 인증 구현
fix: N+1 문제 해결
refactor: Service 레이어 분리

자주 쓰는 명령어들:

git log --oneline        # 커밋 히스토리
git diff                 # 변경사항 확인
git reset HEAD~1         # 마지막 커밋 취소
git stash                # 임시 저장
git stash pop            # 임시 저장 복원

실수로 잘못 커밋했을 때:

// 커밋 메시지만 수정
git commit --amend -m "올바른 메시지"

// 파일 추가하고 다시 커밋
git add forgotten-file.java
git commit --amend --no-edit

정리:
add → commit → push가 기본 흐름이고
커밋 메시지는 명확하게 작성해야 합니다.
```

---

### **Q52. Git Branch 전략**

**면접관**: Git Flow나 GitHub Flow 같은 브랜치 전략을 설명해주세요.

**답변**:

```
BizSync에서는 GitHub Flow를 사용했습니다.
Git Flow보다 단순해서 소규모 팀에 적합하거든요.

GitHub Flow:

main 브랜치 하나만 유지하고
기능별로 브랜치 만들어서 작업합니다.

// 1. main에서 기능 브랜치 생성
git checkout main
git pull origin main
git checkout -b feature/websocket

// 2. 작업하고 커밋
git add .
git commit -m "feat: WebSocket 실시간 통신 구현"

// 3. 푸시
git push origin feature/websocket

// 4. GitHub에서 Pull Request 생성
// 5. 코드 리뷰 받기
// 6. main에 머지
// 7. 브랜치 삭제

브랜치 네이밍:

feature/기능명    # 새 기능
fix/버그명        # 버그 수정
hotfix/긴급수정   # 긴급 패치
refactor/리팩토링 # 리팩토링

예시:
feature/approval-system
fix/login-error
hotfix/security-patch

Git Flow는 더 복잡한데요,

main: 운영 배포용
develop: 개발 통합
feature/*: 기능 개발
release/*: 릴리즈 준비
hotfix/*: 긴급 수정

큰 프로젝트나 정기 릴리즈가 있으면
Git Flow가 낫습니다.

BizSync는 계속 배포하는 구조라
GitHub Flow가 더 맞았습니다.

충돌 해결:

git pull origin main
# 충돌 발생!

# 파일 열어서 수동 해결
<<<<<<< HEAD
현재 브랜치 코드
=======
main 브랜치 코드
>>>>>>> main

# 해결 후
git add .
git commit -m "Merge conflict 해결"

정리:
- 소규모/지속 배포: GitHub Flow
- 대규모/정기 릴리즈: Git Flow
- 브랜치명은 명확하게
```

---

### **Q53. Pull Request와 Code Review**

**면접관**: PR을 어떻게 작성하고 리뷰는 어떻게 받으셨나요?

**답변**:

```
PR은 최대한 명확하게 작성하려고 했습니다.

제목:
[Feature] 결재 시스템 다단계 승인 구현

본문:
## 변경 사항
- ApprovalLine 엔티티 추가
- 순차/병렬 승인 로직 구현
- 알림 연동

## 왜 이렇게 했나요?
결재가 한 명만 하면 안 되고
팀장 → 부장 → 임원 순으로
거쳐야 하는 요구사항이 있었습니다.

## 테스트
- ApprovalServiceTest 추가
- 통합 테스트 통과 확인

## 스크린샷
(UI가 있으면 캡처 첨부)

## 체크리스트
- [ ] 테스트 작성
- [ ] 문서 업데이트
- [ ] 코드 리뷰 반영

리뷰어 지정은 팀원 1-2명에게 했고,
주로 이런 코멘트를 받았습니다.

1. 네이밍:
"approveDoc보다 approveDocument가 명확할 것 같아요"

2. 로직 개선:
"여기서 null 체크가 필요할 것 같습니다"

3. 성능:
"N+1 문제가 발생할 수 있어요. fetch join 고려해보세요"

리뷰 받으면 즉시 수정하고 커밋 추가했습니다.

git add .
git commit -m "refactor: 리뷰 반영 - null 체크 추가"
git push origin feature/approval

리뷰어가 Approve하면
Squash and Merge로 main에 머지했습니다.

Squash and Merge 쓴 이유는
중간 커밋들을 하나로 합쳐서
main 히스토리를 깔끔하게 유지하기 위해서입니다.

리뷰할 때 주의한 점:

1. 작은 단위로 PR
   - 500줄 넘으면 리뷰 힘듦
   - 기능별로 쪼개서

2. 테스트 필수
   - 테스트 없으면 Approve 안 함

3. 긍정적인 피드백
   - "여기 좋네요!"
   - "이렇게 하신 이유가 궁금합니다"

정리:
- PR은 명확하게 (변경사항, 이유, 테스트)
- 리뷰는 건설적으로
- 작은 단위로 자주
```

---

### **Q54. Git Merge vs Rebase**

**면접관**: Merge와 Rebase의 차이를 설명해주세요.

**답변**:

```
Merge는 히스토리를 보존하고,
Rebase는 히스토리를 깔끔하게 정리합니다.

Merge:

main:    A---B---C
               \
feature:        D---E
                     \
merge:                F (merge commit)

git merge feature
# 새로운 머지 커밋 생성

Rebase:

main:    A---B---C
feature:        D---E

git rebase main

결과:
main:    A---B---C
feature:            D'---E' (재배치)

feature 커밋들이 main 뒤로 붙습니다.

BizSync에서는 상황에 따라 다르게 썼습니다.

로컬 작업 정리: Rebase
git checkout feature/task-system
git rebase main  # main 변경사항 가져오기

장점:
- 히스토리 깔끔
- 직선 형태

단점:
- 커밋 해시 변경됨
- 푸시된 브랜치는 위험

공유 브랜치: Merge
git merge feature/approval
# PR 머지는 항상 Merge

주의사항:

이미 푸시한 브랜치는 rebase 금지!

// 나쁨
git push origin feature
git rebase main  # 커밋 해시 변경
git push origin feature  # 에러!
git push -f origin feature  # 강제 푸시 → 위험!

다른 사람이 그 브랜치 쓰고 있으면
충돌 날 수 있습니다.

Interactive Rebase:

git rebase -i HEAD~3
# 최근 3개 커밋 수정

pick abc feat: 기능 A
squash def fix: 오타 수정
squash ghi refactor: 정리

→ 3개를 1개로 합침

커밋 메시지 정리할 때 유용합니다.

정리:
- 로컬 정리: Rebase
- PR 머지: Merge
- 푸시한 브랜치: Rebase 금지
```

---

### **Q55. .gitignore**

**면접관**: .gitignore는 왜 필요하고 어떻게 작성하나요?

**답변**:

```
.gitignore는 Git이 추적하지 않을 파일을
지정하는 겁니다.

민감한 정보나 자동 생성 파일을
커밋하지 않기 위해서 필수입니다.

BizSync Backend .gitignore:

# 빌드 결과물
/build/
/target/
*.jar
*.war

# IDE 설정
.idea/
.vscode/
*.iml

# 환경 변수 (중요!)
.env
application-local.yml

# 로그
*.log

# OS 파일
.DS_Store
Thumbs.db

Frontend .gitignore:

# 의존성
node_modules/

# 빌드
/dist/
/build/

# 환경 변수
.env.local
.env.production

# 테스트 커버리지
/coverage/

왜 중요한가?

1. 보안:
.env 파일에 DB 비밀번호나
JWT Secret이 있으면
절대 커밋하면 안 됩니다.

실제로 .env 커밋했다가
GitHub에 올라가서
누군가 DB 접속한 사건도 있습니다.

2. 불필요한 파일:
node_modules는 수천 개 파일이라
커밋하면 저장소가 엄청 무거워집니다.

package.json만 있으면
npm install로 재생성 가능하니까요.

3. 충돌 방지:
IDE 설정은 사람마다 다르니까
.idea 같은 건 빼야 합니다.

이미 커밋된 파일 제거:

git rm --cached .env
git commit -m "Remove .env from tracking"

이후부터는 추적 안 합니다.

패턴:

*.log          # 모든 .log 파일
/logs/         # logs 폴더
temp*          # temp로 시작하는 파일
!important.log # 예외 (무시 안 함)

실수로 .env 커밋했다면:

1. git rm --cached .env
2. .gitignore에 .env 추가
3. 커밋 후 푸시
4. 환경 변수 값 변경 (노출됐으니까)

정리:
- 민감 정보, 빌드 결과물 제외 필수
- 프로젝트 시작 시 먼저 설정
- 이미 커밋된 건 --cached로 제거
```

---

[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]