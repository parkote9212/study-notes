---
tags:
  - teck-interview
---

## **Part 1: Java 기초 (20개)**

### **Q1. JDK, JRE, JVM의 차이**

**면접관**: JDK, JRE, JVM의 차이를 설명해주세요.

**답변**:

JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. .class 파일을 OS에 맞게 실행해줍니다.

JRE(Java Runtime Environment)는 JVM + 표준 라이브러리입니다. 자바 프로그램을 "실행만" 할 수 있습니다.

JDK(Java Development Kit)는 JRE + 개발 도구(javac, jar 등)입니다. 자바 프로그램을 "개발하고 실행"할 수 있습니다.

BizSync 배포 시:
- 개발: JDK 21 필요 (컴파일)
- 운영(Docker): JRE 21만 필요 (실행만)

그래서 Dockerfile을 멀티 스테이지로 만들었습니다:

```dockerfile
# 빌드 스테이지 - JDK 사용
FROM eclipse-temurin:21-jdk-alpine AS build
RUN ./gradlew bootJar

# 실행 스테이지 - JRE만 사용
FROM eclipse-temurin:21-jre-alpine
COPY --from=build /app/build/libs/*.jar app.jar
```

이렇게 하면 최종 이미지 크기가 300MB → 180MB로 줄어듭니다.

---

### **Q2. Call by Value vs Call by Reference**

**면접관**: Java는 Call by Value인가요, Call by Reference인가요?

**답변**:

Java는 항상 Call by Value입니다. 다만 객체를 넘길 때는 "참조값"을 복사해서 넘깁니다.

예시로 설명하면:

```java
// 기본형
void change(int x) {
    x = 100;
}

int a = 10;
change(a);
System.out.println(a);  // 10 (안 바뀜)
```

```java
// 객체
void change(User user) {
    user.setName("변경됨");  // 객체 내부는 바뀜
}

void change2(User user) {
    user = new User();  // 참조 자체는 안 바뀜
}

User u = new User("원본");
change(u);
System.out.println(u.getName());  // "변경됨"

change2(u);
System.out.println(u.getName());  // "변경됨" (그대로)
```

BizSync에서 실제 겪은 실수:

```java
public void updateTask(Task task) {
    task = taskRepository.findById(task.getId());
    task.setTitle("새 제목");
    // task 재할당해서 원본은 안 바뀜!
}
```

올바른 방법:

```java
public void updateTask(Long taskId) {
    Task task = taskRepository.findById(taskId);
    task.setTitle("새 제목");
    // 같은 객체를 수정해야 함
}
```

핵심은:
- 기본형: 값 복사
- 객체: 참조값 복사 (객체 자체는 복사 안 됨)

---

### **Q3. Checked vs Unchecked Exception**

**면접관**: Checked Exception과 Unchecked Exception의 차이는?

**답변**:

Checked Exception은 컴파일 시점에 체크되는 예외입니다. 반드시 try-catch나 throws를 써야 합니다.

Unchecked Exception은 Runtime Exception을 상속받아서 처리를 강제하지 않습니다.

예시:

```java
// Checked Exception
public void readFile() throws IOException {
    FileReader fr = new FileReader("file.txt");
    // IOException 처리 필수!
}

// Unchecked Exception  
public void divide(int a, int b) {
    return a / b;  // ArithmeticException 처리 안 해도 됨
}
```

BizSync에서는 비즈니스 예외를 Unchecked로 만들었습니다:

```java
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(ErrorCode code) {
        super(code.getMessage());
    }
}
```

이유는:
1. Service 레이어에서 throws 남발 방지
2. @ControllerAdvice로 한 곳에서 처리
3. 코드가 깔끔해짐

사용 예시:

```java
public Project findProject(Long id) {
    return projectRepository.findById(id)
        .orElseThrow(() -> 
            new ResourceNotFoundException(PROJECT_NOT_FOUND)
        );
    // throws 안 써도 됨!
}
```

@ControllerAdvice에서:

```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorResponse> handleNotFound(
    ResourceNotFoundException e
) {
    return ResponseEntity
        .status(404)
        .body(new ErrorResponse(e.getMessage()));
}
```

정리:
- Checked: IOException, SQLException (복구 가능)
- Unchecked: NullPointerException, IllegalArgumentException (프로그램 오류)

---

### **Q4. final 키워드**

**면접관**: final 키워드의 용도를 설명해주세요.

**답변**:

final은 세 곳에 사용됩니다.

**1. 변수: 재할당 불가**

```java
final int MAX = 100;
MAX = 200;  // 컴파일 에러
```

**2. 메서드: 오버라이딩 불가**

```java
public final void calculate() {
    // 자식 클래스가 재정의 못 함
}
```

**3. 클래스: 상속 불가**

```java
public final class String {
    // 누구도 String 상속 못 함
}
```

BizSync에서 가장 많이 쓰는 건 final 변수입니다:

```java
@Service
@RequiredArgsConstructor
public class ApprovalService {
    private final ApprovalRepository repository;
    private final UserRepository userRepository;
    
    // final이라서 생성자에서만 초기화
    // 이후 변경 불가 → 안전
}
```

final의 장점:
1. 불변성 보장
2. 멀티스레드 안전
3. 의도 명확 ("이건 바꾸면 안 돼요")

주의할 점:

```java
final List<String> list = new ArrayList<>();
list.add("A");  // OK! 컬렉션 내용은 바뀜
list = new ArrayList<>();  // 에러! 재할당 불가
```

final은 참조 자체만 못 바꾸는 거지 객체 내부는 바꿀 수 있습니다.

진짜 불변 컬렉션은:

```java
List<String> immutableList = Collections.unmodifiableList(list);
immutableList.add("B");  // UnsupportedOperationException
```

---

### **Q5. static 키워드**

**면접관**: static의 용도와 주의사항을 설명해주세요.

**답변**:

static은 클래스 레벨에서 공유되는 멤버를 만들 때 사용합니다. 객체마다가 아니라 클래스에 딱 하나만 존재합니다.

사용 예시:

```java
// static 변수
public class User {
    private static int count = 0;  // 모든 User가 공유
    private String name;           // 각 User마다
    
    public User(String name) {
        this.name = name;
        count++;  // User 생성될 때마다 증가
    }
    
    public static int getCount() {
        return count;
    }
}

User u1 = new User("A");
User u2 = new User("B");
System.out.println(User.getCount());  // 2
```

BizSync에서 실제 사용:

```java
// SecurityUtil - static 메서드
public class SecurityUtil {
    public static Long getCurrentUserId() {
        Authentication auth = 
            SecurityContextHolder.getContext()
                .getAuthentication();
        return Long.parseLong(auth.getName());
    }
}

// Service에서 사용
Long userId = SecurityUtil.getCurrentUserId();
```

유틸리티 클래스는 객체 생성 없이 사용하니까 static으로 만듭니다.

주의사항:

**1. static은 메모리에 계속 남음**
→ 너무 많이 쓰면 메모리 낭비

**2. 멀티스레드 환경에서 동기화 문제**

```java
private static int count = 0;

public static void increment() {
    count++;  // Thread-unsafe!
}
```

해결:

```java
private static AtomicInteger count = new AtomicInteger(0);

public static void increment() {
    count.incrementAndGet();  // Thread-safe
}
```

**3. static은 객체 지향을 해침**
→ 꼭 필요한 곳에만 사용

언제 사용?
- 유틸 메서드 (Math.max, Collections.sort)
- 상수 (public static final)
- 싱글톤 패턴

---

### **Q6. 오버로딩 vs 오버라이딩**

**면접관**: 오버로딩과 오버라이딩의 차이를 설명해주세요.

**답변**:

오버로딩(Overloading)은 같은 이름의 메서드를 여러 개 만드는 겁니다. 매개변수가 달라야 합니다.

오버라이딩(Overriding)은 부모 메서드를 자식이 재정의하는 겁니다.

**오버로딩 예시:**

```java
public class TaskService {
    // 1. ID로 조회
    public Task findTask(Long id) {
        return repository.findById(id);
    }
    
    // 2. 제목으로 조회
    public Task findTask(String title) {
        return repository.findByTitle(title);
    }
    
    // 3. 여러 개 조회
    public List<Task> findTask(List<Long> ids) {
        return repository.findAllById(ids);
    }
}
```

같은 이름이지만 파라미터가 다릅니다.

**오버라이딩 예시:**

```java
public class BaseEntity {
    public void save() {
        System.out.println("기본 저장");
    }
}

public class User extends BaseEntity {
    @Override
    public void save() {
        // 부모 메서드 재정의
        validateEmail();
        super.save();  // 부모 메서드 호출
        sendWelcomeEmail();
    }
}
```

BizSync에서 실제로 사용한 오버라이딩:

```java
// UserRepository - JPA 제공 메서드 오버라이딩
public interface UserRepository extends JpaRepository<User, Long> {
    
    // findById 커스터마이징
    default User findByIdOrThrow(Long id) {
        return findById(id)
            .orElseThrow(() -> 
                new ResourceNotFoundException(USER_NOT_FOUND)
            );
    }
}
```

정리:
- 오버로딩: 같은 클래스, 다른 파라미터
- 오버라이딩: 상속 관계, 같은 시그니처

주의: 리턴 타입만 다른 건 오버로딩 안 됨!

```java
// 컴파일 에러!
public int calculate(int a) { }
public double calculate(int a) { }
```

---

### **Q7. Wrapper Class**

**면접관**: Integer와 int의 차이는 무엇인가요?

**답변**:

int는 기본형(primitive type)이고 Integer는 래퍼 클래스(Wrapper Class)입니다.

**차이점:**

**1. null 가능 여부**

```java
int a = null;      // 컴파일 에러
Integer b = null;  // OK
```

**2. 메모리**

- int: 4바이트 (스택)
- Integer: 16바이트 + 객체 오버헤드 (힙)

**3. 비교**

```java
int a = 100;
int b = 100;
a == b  // true (값 비교)

Integer c = 100;
Integer d = 100;
c == d  // true (캐싱 때문)

Integer e = 1000;
Integer f = 1000;
e == f  // false! (새 객체)
e.equals(f)  // true (값 비교)
```

Integer는 -128 ~ 127은 캐싱합니다.

BizSync에서 실제 사용:

```java
// Entity - null 가능해야 해서 Integer 사용
@Entity
public class Task {
    private Long taskId;      // null 가능
    private Integer sequence; // null 가능 (순서 미정)
}

// 로직 - int 사용
public int calculateTotal(List<Integer> numbers) {
    int sum = 0;  // 기본값 0
    for (Integer num : numbers) {
        sum += num;  // 자동 언박싱
    }
    return sum;
}
```

Auto-boxing / Unboxing:

```java
int x = 10;
Integer y = x;     // Auto-boxing
int z = y;         // Auto-unboxing
```

주의: NullPointerException

```java
Integer count = null;
int total = count;  // NPE 발생!
```

언제 뭘 쓸까?
- Entity, DTO: Integer (null 필요)
- 반복문, 계산: int (성능)
- Collection: Integer (제네릭은 객체만)

```java
List<int> list;     // 컴파일 에러!
List<Integer> list; // OK
```

---

### **Q8. String 불변성**

**면접관**: String이 불변인 이유는 무엇인가요?

**답변**:

String이 불변(immutable)이면 세 가지 장점이 있습니다.

1. 보안
2. 스레드 안전
3. String Pool 활용

예시로 설명하면:

```java
String password = "secret123";
changePassword(password);
System.out.println(password);  // 여전히 "secret123"
```

만약 String이 가변이면:

```java
void changePassword(String pwd) {
    pwd = "hacked!!!";  // 원본도 바뀜!
}
```

이건 위험하죠.

**String Pool:**

```java
String s1 = "hello";
String s2 = "hello";
s1 == s2  // true (같은 객체!)
```

String은 불변이라서 같은 문자열을 재사용할 수 있습니다.

```java
String s3 = new String("hello");
s1 == s3  // false (새 객체)
```

BizSync에서 겪은 실수:

```java
// 잘못된 코드
String sql = "SELECT * FROM task";
for (String condition : conditions) {
    sql += " AND " + condition;  // 매번 새 객체!
}
```

이러면 반복문 1000번이면 1000개의 String 객체가 생깁니다.

올바른 방법:

```java
StringBuilder sb = new StringBuilder("SELECT * FROM task");
for (String condition : conditions) {
    sb.append(" AND ").append(condition);  // 객체 1개
}
String sql = sb.toString();
```

불변의 장점:
1. 멀티스레드 안전 - 동기화 필요 없음
2. 캐싱 가능 - hashCode를 한 번만 계산
3. 안전 - 의도치 않은 변경 방지

단점:
- 문자열 조작 시 성능 저하 → StringBuilder 사용

---

## **Part 2: Spring 기초 (20개)**

### **Q9. IoC(제어의 역전)**

**면접관**: IoC가 무엇인가요?

**답변**:

IoC(Inversion of Control)는 객체 생성과 관리를 개발자가 아니라 프레임워크가 하는 겁니다.

**기존 방식:**

```java
public class ApprovalService {
    private ApprovalRepository repository;
    
    public ApprovalService() {
        this.repository = new ApprovalRepository();
        // 개발자가 직접 생성
    }
}
```

**Spring 방식:**

```java
@Service
public class ApprovalService {
    private final ApprovalRepository repository;
    
    public ApprovalService(ApprovalRepository repository) {
        this.repository = repository;
        // Spring이 주입해줌
    }
}
```

장점은:

**1. 결합도 낮아짐**
- Repository 구현체 바꿔도 Service 수정 안 함

**2. 테스트 쉬움**

```java
@Test
void test() {
    ApprovalRepository mock = mock(ApprovalRepository.class);
    ApprovalService service = new ApprovalService(mock);
    // Mock 주입 가능
}
```

**3. 객체 생명주기 관리**
- Spring이 싱글톤으로 관리

BizSync의 Bean 등록 방법:

```java
// 1. @Component 계열
@Service
@Repository  
@Controller
@Configuration

// 2. @Bean
@Configuration
public class AppConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

Spring이 관리하는 Bean들은 ApplicationContext에 저장되고 필요할 때 꺼내서 씁니다.

직접 생성하면:
- 매번 new
- 싱글톤 관리 직접
- 의존성 수동 주입

Spring이 관리하면:
- 자동 생성
- 자동 싱글톤
- 자동 주입

---

### **Q10. Bean Scope**

**면접관**: Bean Scope 종류를 설명해주세요.

**답변**:

Bean Scope는 Bean의 생명주기 범위입니다.

**1. singleton (기본값)**
- 스프링 컨테이너당 객체 1개

```java
@Service
public class UserService {
    // 애플리케이션 전체에서 1개만
}
```

**2. prototype**
- 요청할 때마다 새 객체

```java
@Component
@Scope("prototype")
public class TempData {
    // getBean()할 때마다 new
}
```

**3. request (웹 전용)**
- HTTP 요청당 1개

```java
@Component
@Scope("request")
public class RequestContext {
    // 각 HTTP 요청마다 새로 생성
}
```

**4. session (웹 전용)**
- HTTP 세션당 1개

BizSync는 대부분 singleton입니다:

```java
@Service  // singleton
public class ApprovalService {
    // 모든 요청이 이 객체를 공유
}
```

**주의사항:**

싱글톤 Bean에 상태를 넣으면 안 됩니다!

```java
// 잘못된 코드
@Service
public class UserService {
    private Long currentUserId;  // 공유됨!
    
    public void process(Long userId) {
        this.currentUserId = userId;
        // 멀티스레드 환경에서 꼬임!
    }
}
```

올바른 방법:

```java
@Service
public class UserService {
    public void process(Long userId) {
        // 지역 변수 사용
        User user = findUser(userId);
    }
}
```

BizSync에서 prototype을 쓴 경우:

```java
@Component
@Scope("prototype")
public class ExcelExporter {
    private Workbook workbook;
    
    // 요청마다 새 Workbook 필요
}
```

정리:
- 99%는 singleton
- 상태 가지면 안 됨
- 필요시 prototype

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]