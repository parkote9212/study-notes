---
tags: teck-interview
---
### **Q26. JOIN 종류**

**면접관**: INNER JOIN과 LEFT JOIN의 차이는?

**답변**:

INNER JOIN은 양쪽 모두 있는 데이터만 가져오고, LEFT JOIN은 왼쪽 테이블 전체 + 오른쪽 매칭되는 것만 가져옵니다.

**INNER JOIN:**

```sql
SELECT t.*, u.name
FROM task t
INNER JOIN users u ON t.worker_id = u.user_id;
-- worker가 할당된 task만 조회
```

**LEFT JOIN:**

```sql
SELECT t.*, u.name
FROM task t
LEFT JOIN users u ON t.worker_id = u.user_id;
-- worker 없는 task도 조회 (u.name은 NULL)
```

**BizSync 실제 사용:**

```sql
-- 칸반 보드 조회 (LEFT JOIN 필수)
SELECT c.*, t.*
FROM kanban_column c
LEFT JOIN task t ON c.column_id = t.column_id
WHERE c.project_id = 1;
-- Task 없는 빈 컬럼도 보여줘야 하니까
```

RIGHT JOIN은 잘 안 씁니다. LEFT JOIN으로 충분하니까요.

---

### **Q27. GROUP BY와 집계함수**

**면접관**: GROUP BY를 설명하고 HAVING과 WHERE의 차이는?

**답변**:

GROUP BY는 데이터를 그룹으로 묶어서 집계합니다.

```sql
-- 프로젝트별 Task 개수
SELECT project_id, COUNT(*) as task_count
FROM task
GROUP BY project_id;
```

**WHERE vs HAVING:**

```sql
-- WHERE: 그룹화 전 필터링
SELECT project_id, COUNT(*)
FROM task
WHERE deadline < NOW()  -- 먼저 필터링
GROUP BY project_id;

-- HAVING: 그룹화 후 필터링
SELECT project_id, COUNT(*) as cnt
FROM task
GROUP BY project_id
HAVING cnt > 10;  -- 집계 후 필터링
```

**BizSync 실제 쿼리:**

```sql
-- 멤버 3명 이상인 프로젝트만
SELECT project_id, COUNT(*) as member_count
FROM project_member
GROUP BY project_id
HAVING member_count >= 3;

-- 진행 중인 Task가 많은 컬럼
SELECT column_id, COUNT(*) 
FROM task
WHERE status = 'IN_PROGRESS'
GROUP BY column_id
ORDER BY COUNT(*) DESC;
```

---

### **Q28. 서브쿼리**

**면접관**: 서브쿼리는 언제 사용하나요?

**답변**:

서브쿼리는 쿼리 안에 또 다른 쿼리를 넣는 겁니다.

```sql
-- Task가 있는 프로젝트만 조회
SELECT * FROM project
WHERE project_id IN (
    SELECT DISTINCT project_id FROM task
);
```

**종류:**

**1. WHERE 절 서브쿼리**

```sql
SELECT * FROM task
WHERE worker_id = (SELECT user_id FROM users WHERE email = 'hong@...');
```

**2. FROM 절 서브쿼리 (인라인 뷰)**

```sql
SELECT p.*, stats.task_count
FROM project p
JOIN (
    SELECT project_id, COUNT(*) as task_count
    FROM task GROUP BY project_id
) stats ON p.project_id = stats.project_id;
```

**3. SELECT 절 서브쿼리 (스칼라)**

```sql
SELECT 
    project_id,
    name,
    (SELECT COUNT(*) FROM task WHERE project_id = p.project_id) as task_count
FROM project p;
```

BizSync에서는 JOIN이 더 효율적이라 서브쿼리는 최소화합니다.

```sql
-- 서브쿼리 (느림)
SELECT * FROM project
WHERE project_id IN (SELECT project_id FROM task);

-- JOIN (빠름)
SELECT DISTINCT p.*
FROM project p
JOIN task t ON p.project_id = t.project_id;
```

**EXISTS 사용:**

```sql
SELECT * FROM project p
WHERE EXISTS (
    SELECT 1 FROM task t WHERE t.project_id = p.project_id
);
-- IN보다 빠를 수 있음
```

---

## **Part 5: 네트워크 (10개)**

### **Q29. GET vs POST**

**면접관**: GET과 POST의 차이는?

**답변**:

GET은 조회, POST는 생성/수정에 사용합니다.

**차이점:**

**1. 데이터 위치**
- GET: URL에 포함 (?id=1&name=hong)
- POST: Body에 포함

**2. 캐싱**
- GET: 브라우저 캐싱 가능
- POST: 캐싱 안 됨

**3. 길이 제한**
- GET: URL 길이 제한 (약 2KB)
- POST: 제한 없음

**4. 보안**
- GET: URL에 노출 (로그에 남음)
- POST: Body에 숨김

**BizSync API 설계:**

```java
// GET - 조회
@GetMapping("/api/projects/{id}")
public Project getProject(@PathVariable Long id) { }

// POST - 생성
@PostMapping("/api/projects")
public Project createProject(@RequestBody ProjectDTO dto) { }

// PUT - 전체 수정
@PutMapping("/api/projects/{id}")
public Project updateProject(@PathVariable Long id, @RequestBody ProjectDTO dto) { }

// DELETE - 삭제
@DeleteMapping("/api/projects/{id}")
public void deleteProject(@PathVariable Long id) { }
```

**주의:**

로그인은 POST로! GET으로 하면 비밀번호가 URL에 노출됩니다.

```
// 나쁨
GET /api/login?email=hong@...&password=1234

// 좋음
POST /api/login
Body: {"email":"hong@...", "password":"1234"}
```

---

### **Q30. REST API**

**면접관**: RESTful API 설계 원칙은?

**답변**:

REST는 자원을 URI로 표현하고 HTTP 메서드로 행위를 표현합니다.

**원칙:**

**1. URI는 명사, 동사 X**

```
나쁨: /api/getProjects, /api/createProject
좋음: GET /api/projects, POST /api/projects
```

**2. 계층 구조**

```
/api/projects/{id}/tasks/{taskId}
```

**3. HTTP 상태코드 활용**

- 200: 성공
- 201: 생성 성공
- 204: 성공 (응답 없음)
- 400: 잘못된 요청
- 401: 인증 필요
- 403: 권한 없음
- 404: 없음
- 500: 서버 오류

**BizSync API 구조:**

```
// 프로젝트
GET    /api/projects           - 목록 조회
POST   /api/projects           - 생성
GET    /api/projects/{id}      - 상세 조회
PUT    /api/projects/{id}      - 수정
DELETE /api/projects/{id}      - 삭제

// Task (프로젝트 하위)
GET    /api/projects/{id}/tasks
POST   /api/projects/{id}/tasks
PUT    /api/tasks/{taskId}     - Task는 독립적으로도 수정
```

**응답 예시:**

```json
{
  "status": "success",
  "data": {
    "projectId": 1,
    "name": "BizSync"
  },
  "message": "프로젝트 생성 완료"
}
```

**페이징:**

```
GET /api/projects?page=0&size=20&sort=createdAt,desc
```

---

### **Q31. HTTP 상태코드**

**면접관**: 주요 HTTP 상태코드를 설명해주세요.

**답변**:

**2xx - 성공**
- 200 OK: 조회 성공
- 201 Created: 생성 성공
- 204 No Content: 성공했지만 응답 없음 (DELETE 등)

**3xx - 리다이렉션**
- 301 Moved Permanently: 영구 이동
- 302 Found: 임시 이동

**4xx - 클라이언트 오류**
- 400 Bad Request: 잘못된 요청
- 401 Unauthorized: 인증 필요
- 403 Forbidden: 권한 없음
- 404 Not Found: 리소스 없음

**5xx - 서버 오류**
- 500 Internal Server Error: 서버 에러
- 503 Service Unavailable: 서비스 불가

**BizSync 실제 사용:**

```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException e) {
    return ResponseEntity
        .status(404)  // 404 Not Found
        .body(new ErrorResponse(e.getMessage()));
}

@ExceptionHandler(ForbiddenException.class)
public ResponseEntity<ErrorResponse> handleForbidden(ForbiddenException e) {
    return ResponseEntity
        .status(403)  // 403 Forbidden
        .body(new ErrorResponse("권한이 없습니다"));
}

@PostMapping("/api/projects")
public ResponseEntity<Project> createProject(@RequestBody ProjectDTO dto) {
    Project project = projectService.create(dto);
    return ResponseEntity
        .status(201)  // 201 Created
        .body(project);
}
```

**401 vs 403:**
- 401: "로그인 안 했어요"
- 403: "로그인은 했는데 권한이 없어요"

---

### **Q32. CORS**

**면접관**: CORS가 무엇이고 어떻게 해결하나요?

**답변**:

CORS(Cross-Origin Resource Sharing)는 다른 출처의 리소스 접근을 제한하는 정책입니다.

**문제 상황:**

```
Frontend: http://localhost:5173
Backend:  http://localhost:8080

fetch('http://localhost:8080/api/projects')
// CORS 에러!
```

브라우저가 보안상 차단합니다.

**BizSync 해결:**

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        
        // 허용할 Origin
        config.setAllowedOrigins(List.of(
            "http://localhost:5173",
            "https://bizsync.com"
        ));
        
        // 허용할 HTTP 메서드
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
        
        // 허용할 헤더
        config.setAllowedHeaders(List.of("Authorization", "Content-Type"));
        
        // 쿠키 전송 허용
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
```

**Preflight Request:**

복잡한 요청 전에 브라우저가 먼저 OPTIONS 요청을 보냅니다.

```
OPTIONS /api/projects
Origin: http://localhost:5173

서버 응답:
Access-Control-Allow-Origin: http://localhost:5173
Access-Control-Allow-Methods: GET, POST, PUT, DELETE

그 다음 실제 요청:
POST /api/projects
```

**주의:**

운영 환경에서는 setAllowedOrigins("*") 쓰면 안 됩니다! 구체적인 도메인만 허용해야 합니다.

---

### **Q33. 쿠키 vs 세션 vs 토큰**

**면접관**: 셋의 차이를 설명해주세요.

**답변**:

- 쿠키: 클라이언트에 저장
- 세션: 서버에 저장
- 토큰: 서명된 데이터

**쿠키:**
- 브라우저에 저장 (4KB 제한)
- 자동으로 요청에 포함
- 보안 취약

**세션:**
- 서버 메모리에 저장
- 쿠키에 Session ID만 저장
- 서버 부담

**토큰 (JWT):**
- 서명된 JSON
- 서버 저장소 불필요
- Stateless

**BizSync는 JWT 사용:**

로그인:

```
POST /api/auth/login
→ 응답: { "accessToken": "eyJhbGc...", "refreshToken": "..." }
```

클라이언트 저장:

```javascript
localStorage.setItem('accessToken', token);
```

API 호출:

```javascript
fetch('/api/projects', {
  headers: {
    'Authorization': 'Bearer ' + accessToken
  }
});
```

서버 검증:
1. 토큰 파싱
2. 서명 검증
3. 만료 시간 체크
4. userId 추출

**JWT 구조:**

```
eyJhbGc... (Header)
.eyJ1c2Vy... (Payload: userId, role 등)
.SflKxwR... (Signature)
```

**장점:**
- Stateless (서버 확장 쉬움)
- 세션 저장소 불필요

**단점:**
- 토큰 크기 큼
- 탈취 시 무효화 어려움 → Refresh Token으로 보완

---

### **Q34. TCP vs UDP**

**면접관**: TCP와 UDP의 차이는?

**답변**:

- TCP: 연결 지향, 신뢰성
- UDP: 비연결, 빠름

**TCP:**
- 3-way handshake로 연결
- 데이터 순서 보장
- 에러 검출 및 재전송
- 느림

**UDP:**
- 연결 없이 바로 전송
- 순서 보장 안 함
- 에러 검출만 (재전송 X)
- 빠름

**사용 사례:**

**TCP:**
- HTTP/HTTPS
- 파일 전송
- 이메일
- 데이터 무결성 중요

**UDP:**
- 실시간 스트리밍
- 온라인 게임
- DNS
- 속도 중요

BizSync는 HTTP를 쓰니까 TCP 기반입니다.

WebSocket도 TCP 위에서 동작:
1. HTTP로 핸드셰이크 (TCP)
2. 프로토콜 업그레이드
3. WebSocket 연결 유지 (TCP)

**3-way handshake:**

```
Client: SYN (접속 요청)
Server: SYN-ACK (요청 수락)
Client: ACK (확인)
→ 연결 성립
```

**4-way handshake (종료):**

```
Client: FIN
Server: ACK
Server: FIN
Client: ACK
→ 연결 종료
```

---

### **Q35. DNS**

**면접관**: DNS가 무엇인가요?

**답변**:

DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환합니다.

```
www.bizsync.com → 13.125.123.45
```

**동작 과정:**

1. 브라우저 캐시 확인
2. OS 캐시 확인
3. 로컬 DNS 서버 질의
4. 루트 DNS 서버
5. .com DNS 서버
6. bizsync.com DNS 서버
7. IP 주소 반환

**BizSync 배포 시:**

1. Route 53에서 도메인 등록
2. A 레코드 설정
   - bizsync.com → 13.125.123.45 (ALB IP)
3. CNAME 설정
   - www.bizsync.com → bizsync.com

**레코드 타입:**

- A: 도메인 → IPv4
- AAAA: 도메인 → IPv6
- CNAME: 도메인 → 다른 도메인
- MX: 메일 서버
- TXT: 텍스트 (인증 등)

**확인:**

```bash
nslookup bizsync.com
dig bizsync.com
```

**TTL (Time To Live):**

캐싱 시간 설정

```
300 = 5분 동안 캐시
```

**배포 시 주의:**

TTL을 짧게 설정 → 변경사항 빨리 반영

---

## **Part 6: Frontend 기초 (10개)**

### **Q36. var vs let vs const**

**면접관**: 셋의 차이는?

**답변**:

- var: 함수 스코프, 재선언 가능
- let: 블록 스코프, 재할당 가능
- const: 블록 스코프, 재할당 불가

**var (쓰지 말 것):**

```javascript
function test() {
  var x = 1;
  if (true) {
    var x = 2;  // 같은 변수!
  }
  console.log(x);  // 2
}
```

**let:**

```javascript
function test() {
  let x = 1;
  if (true) {
    let x = 2;  // 다른 변수
  }
  console.log(x);  // 1
}
```

**const:**

```javascript
const user = { name: 'hong' };
user.name = 'kim';  // OK (객체 내용 변경)
user = {};  // 에러! (재할당 불가)
```

**BizSync는 const 우선:**

```javascript
// 기본
const userId = getCurrentUserId();

// 재할당 필요하면 let
let count = 0;
count++;

// var는 절대 쓰지 않음
```

정리:
- 기본: const
- 재할당 필요: let
- var: 레거시 코드에만 존재

---

### **Q37. Promise vs async/await**

**면접관**: 비동기 처리 방식을 설명해주세요.

**답변**:

**Promise:**

```javascript
api.getProject(1)
  .then(project => {
    return api.getTasks(project.id);
  })
  .then(tasks => {
    console.log(tasks);
  })
  .catch(error => {
    console.error(error);
  });
```

**async/await (더 직관적):**

```javascript
async function loadProject() {
  try {
    const project = await api.getProject(1);
    const tasks = await api.getTasks(project.id);
    console.log(tasks);
  } catch (error) {
    console.error(error);
  }
}
```

**BizSync 실제 코드:**

```javascript
// Kanban 보드 조회
const loadBoard = async () => {
  setLoading(true);
  try {
    const response = await api.get(`/api/projects/${projectId}/board`);
    setBoard(response.data);
  } catch (error) {
    toast.error('보드 조회 실패');
  } finally {
    setLoading(false);
  }
};
```

**병렬 처리:**

```javascript
// 순차 (느림)
const user = await api.getUser(id);
const projects = await api.getProjects(id);

// 병렬 (빠름)
const [user, projects] = await Promise.all([
  api.getUser(id),
  api.getProjects(id)
]);
```

정리:
- Promise: 콜백 지옥 해결
- async/await: Promise를 더 깔끔하게

---

### **Q38. Virtual DOM**

**면접관**: React의 Virtual DOM이 무엇인가요?

**답변**:

Virtual DOM은 실제 DOM의 복사본을 메모리에 유지하는 겁니다.

**동작:**

1. 상태 변경
2. Virtual DOM 업데이트
3. 이전 Virtual DOM과 비교 (Diffing)
4. 변경된 부분만 실제 DOM 업데이트

**왜 빠른가?**

실제 DOM 조작은 느립니다:

```javascript
document.getElementById('task-1').innerText = '변경';
// 브라우저 리플로우/리페인트
```

Virtual DOM:

```javascript
{
  type: 'div',
  props: { id: 'task-1', children: '변경' }
}
// 메모리상 객체 비교만
```

**BizSync 예시:**

```javascript
const TaskCard = ({ task }) => {
  const [title, setTitle] = useState(task.title);
  
  // title 변경 시
  setTitle('새 제목');
  
  // React가 알아서:
  // 1. Virtual DOM 업데이트
  // 2. 변경 감지
  // 3. 실제 DOM에 반영
  
  return <div>{title}</div>;
};
```

**장점:**
- 개발자는 선언적 코드만
- React가 최적화 담당

**단점:**
- 메모리 사용
- 작은 변경도 비교 필요

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]