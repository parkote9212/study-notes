---
tags: teck-interview
---
좋습니다! 계속 진행하겠습니다.

---

### **Q86. MVC vs MVP 패턴**

**면접관**: MVC와 MVP 패턴의 차이를 설명하고, 각각 언제 사용하나요?

**답변**:

```
MVC와 MVP는 둘 다 UI와 비즈니스 로직을
분리하는 아키텍처 패턴입니다.

MVC (Model-View-Controller):

Model: 데이터와 비즈니스 로직
View: 화면 표시
Controller: 사용자 입력 처리, Model과 View 연결

흐름:
사용자 입력 → Controller → Model 업데이트 → View 갱신

Spring MVC가 대표적인데요,

@Controller
public class ProjectController {
    
    @GetMapping("/projects/{id}")
    public String getProject(@PathVariable Long id, Model model) {
        // Controller가 Model 가져와서
        Project project = projectService.findById(id);
        
        // View에 전달
        model.addAttribute("project", project);
        
        return "project/detail";  // View 이름 반환
    }
}

View는 Model을 직접 참조할 수 있습니다.

<!-- project/detail.html -->
<h1>${project.name}</h1>

장점:
- 구조가 단순
- 빠르게 개발 가능
- Spring에서 기본 제공

단점:
- View와 Model이 결합됨
- 테스트 어려움 (View 의존)
- View가 복잡해지면 Controller도 복잡

주요 사용처:
- 서버 사이드 렌더링 (Thymeleaf, JSP)
- 전통적인 웹 애플리케이션
- Spring MVC

MVP (Model-View-Presenter):

Model: 데이터와 비즈니스 로직
View: 화면 표시만 (수동적)
Presenter: View와 Model 중재

흐름:
사용자 입력 → View → Presenter → Model → Presenter → View

View는 인터페이스로 정의:

public interface ProjectView {
    void showProject(Project project);
    void showError(String message);
}

Presenter가 View 인터페이스만 의존:

public class ProjectPresenter {
    private final ProjectView view;
    private final ProjectService service;
    
    public ProjectPresenter(ProjectView view, ProjectService service) {
        this.view = view;
        this.service = service;
    }
    
    public void loadProject(Long id) {
        try {
            Project project = service.findById(id);
            view.showProject(project);
        } catch (Exception e) {
            view.showError("프로젝트를 찾을 수 없습니다");
        }
    }
}

View 구현:

public class ProjectActivity implements ProjectView {
    private ProjectPresenter presenter;
    
    @Override
    public void showProject(Project project) {
        titleTextView.setText(project.getName());
    }
    
    @Override
    public void showError(String message) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }
    
    public void onLoadButtonClick() {
        presenter.loadProject(projectId);
    }
}

장점:
- View와 Model 완전 분리
- 테스트 쉬움 (View Mock 가능)
- UI 로직과 비즈니스 로직 명확히 분리

단점:
- 코드량 증가 (인터페이스, Presenter)
- 작은 프로젝트엔 오버엔지니어링
- 초기 구조 설계 복잡

주요 사용처:
- Android 앱 (전통적으로)
- 복잡한 UI 로직
- 테스트 커버리지 중요할 때

비교 표:

| 항목 | MVC | MVP |
|------|-----|-----|
| View-Model | View가 Model 직접 참조 | Presenter가 중재 |
| 테스트 | 어려움 | 쉬움 |
| 결합도 | 높음 | 낮음 |
| 코드량 | 적음 | 많음 |
| 사용처 | 웹(서버 렌더링) | 모바일 앱 |

BizSync는 React + Spring 구조라서
엄밀히는 MVC도 MVP도 아니고,
백엔드는 REST API로 데이터만 제공하고
프론트엔드가 렌더링을 담당하는
SPA 패턴입니다.

만약 Spring MVC로 만들었다면:

Controller → Service → Repository → View

이런 MVC 패턴이었겠지만,

현재는:
Frontend (React) ↔ Backend (REST API)

프론트는 컴포넌트 기반이고,
백엔드는 API만 제공하는 구조입니다.

정리:
- MVC: View가 Model 참조, 웹에 적합
- MVP: Presenter가 중재, 테스트 쉬움, 모바일 적합
- 실무: 프로젝트 특성에 맞게 선택
```

---

### **Q87. DAO vs Repository**

**면접관**: DAO 패턴과 Repository 패턴의 차이는?

**답변**:

```
둘 다 데이터 접근 계층이지만
개념적으로 차이가 있습니다.

DAO (Data Access Object):

데이터베이스 테이블에 직접 매핑되는
저수준 접근 패턴입니다.

public interface UserDAO {
    void insert(User user);
    void update(User user);
    void delete(Long id);
    User selectById(Long id);
    List<User> selectAll();
}

테이블 중심적이고,
CRUD 작업에 집중합니다.

Repository:

도메인 중심의 고수준 패턴입니다.
컬렉션처럼 동작합니다.

public interface UserRepository {
    User save(User user);
    Optional<User> findById(Long id);
    List<User> findByEmail(String email);
    void delete(User user);
}

도메인 객체를 다루는 느낌입니다.

BizSync에서는 Repository 패턴:

public interface ProjectRepository extends JpaRepository<Project, Long> {
    
    // 도메인 의미가 명확
    List<Project> findByLeaderUserId(Long userId);
    
    @Query("SELECT p FROM Project p WHERE p.status = 'ACTIVE'")
    List<Project> findActiveProjects();
}

차이점:

DAO:
- 테이블 = DAO
- users 테이블 → UserDAO
- SQL 중심
- 저수준 (SELECT, INSERT, UPDATE, DELETE)

Repository:
- 도메인 = Repository
- User 엔티티 → UserRepository
- 도메인 중심
- 고수준 (findActiveUsers, findByEmail)

예시:

// DAO 스타일
userDAO.selectByEmail("hong@...");
userDAO.insert(user);

// Repository 스타일
userRepository.findByEmail("hong@...");
userRepository.save(user);

Repository는 내부적으로
여러 DAO를 사용할 수도 있습니다.

public class ProjectRepositoryImpl implements ProjectRepository {
    private final ProjectDAO projectDAO;
    private final MemberDAO memberDAO;
    
    public Project save(Project project) {
        // 여러 DAO 조합
        projectDAO.insert(project);
        for (Member m : project.getMembers()) {
            memberDAO.insert(m);
        }
        return project;
    }
}

Spring Data JPA는 Repository 패턴:

사용자 입장에서는
데이터베이스가 아니라
컬렉션을 다루는 느낌입니다.

List<Project> projects = projectRepository.findAll();
projectRepository.save(newProject);

마치 List처럼 사용합니다.

정리:
- DAO: 테이블 중심, SQL 중심
- Repository: 도메인 중심, 컬렉션 느낌
- JPA는 Repository 패턴 권장
```

---

### **Q88. SOLID 원칙**

**면접관**: SOLID 원칙을 설명하고 실제 적용 경험을 말씀해주세요.

**답변**:

```
SOLID는 객체지향 설계 5가지 원칙입니다.

S - Single Responsibility (단일 책임):
하나의 클래스는 하나의 책임만

나쁨:
public class UserService {
    public void createUser(User user) { }
    public void sendEmail(String to) { }  // 이메일은 다른 책임
    public void generateReport() { }       // 보고서도 다른 책임
}

좋음:
public class UserService {
    public void createUser(User user) { }
}

public class EmailService {
    public void send(String to) { }
}

public class ReportService {
    public void generate() { }
}

BizSync에서 적용:
ApprovalService는 결재 로직만,
NotificationService는 알림만 담당합니다.

O - Open/Closed (개방-폐쇄):
확장에는 열려있고, 수정에는 닫혀있다

나쁨:
public class PaymentService {
    public void pay(String type) {
        if (type.equals("card")) {
            // 카드 결제
        } else if (type.equals("cash")) {
            // 현금 결제
        }
        // 새 결제 수단 추가하려면 이 코드 수정!
    }
}

좋음:
public interface PaymentMethod {
    void pay();
}

public class CardPayment implements PaymentMethod {
    public void pay() { /* 카드 결제 */ }
}

public class CashPayment implements PaymentMethod {
    public void pay() { /* 현금 결제 */ }
}

// 새 결제 수단 추가해도 기존 코드 수정 안 함
public class CryptoPayment implements PaymentMethod {
    public void pay() { /* 암호화폐 결제 */ }
}

L - Liskov Substitution (리스코프 치환):
자식 클래스는 부모 클래스를 대체 가능해야

나쁨:
public class Rectangle {
    protected int width, height;
    
    public void setWidth(int width) {
        this.width = width;
    }
    
    public void setHeight(int height) {
        this.height = height;
    }
}

public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;  // 정사각형은 width=height
    }
}

// 문제 발생
Rectangle r = new Square();
r.setWidth(5);
r.setHeight(10);
// 기대: 5x10, 실제: 10x10

좋음:
별도 클래스로 분리하거나
인터페이스 사용

I - Interface Segregation (인터페이스 분리):
클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야

나쁨:
public interface Worker {
    void work();
    void eat();
    void sleep();
}

public class Robot implements Worker {
    public void work() { }
    public void eat() { }    // 로봇은 안 먹음!
    public void sleep() { }  // 로봇은 안 잠!
}

좋음:
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public class Human implements Workable, Eatable {
    public void work() { }
    public void eat() { }
}

public class Robot implements Workable {
    public void work() { }
}

BizSync에서 적용:
JpaRepository를 상속받지만
필요한 메서드만 사용합니다.

D - Dependency Inversion (의존 역전):
고수준 모듈이 저수준 모듈에 의존하지 않고
추상화에 의존해야

나쁨:
public class ApprovalService {
    private final MariaDBRepository repository;  // 구체 클래스 의존
    
    public ApprovalService() {
        this.repository = new MariaDBRepository();
    }
}

좋음:
public class ApprovalService {
    private final ApprovalRepository repository;  // 인터페이스 의존
    
    public ApprovalService(ApprovalRepository repository) {
        this.repository = repository;
    }
}

이렇게 하면 DB를 바꿔도
ApprovalService는 수정 안 해도 됩니다.

BizSync 전체적으로:

- Service는 Repository 인터페이스만 의존
- 구현체는 Spring이 주입
- 테스트 시 Mock으로 교체 가능

정리:
- S: 한 클래스 한 책임
- O: 확장 가능, 수정 불필요
- L: 부모-자식 대체 가능
- I: 인터페이스 작게
- D: 추상화 의존
```

---

### **Q89. DTO vs Entity**

**면접관**: DTO와 Entity를 분리하는 이유는?

**답변**:

```
Entity는 DB 테이블과 매핑되고,
DTO는 계층 간 데이터 전달용입니다.

분리하지 않으면:

@RestController
public class ProjectController {
    
    @GetMapping("/api/projects/{id}")
    public Project getProject(@PathVariable Long id) {
        return projectService.findById(id);
        // Entity를 직접 반환!
    }
}

문제점:

1. 순환 참조

@Entity
public class Project {
    @OneToMany(mappedBy = "project")
    private List<Member> members;
}

@Entity
public class Member {
    @ManyToOne
    private Project project;
}

JSON 직렬화 시 무한 루프!

2. 민감 정보 노출

@Entity
public class User {
    private String email;
    private String password;  // 노출되면 안 됨!
}

3. API 스펙이 DB에 종속

Entity 필드명 바꾸면
API 응답도 바뀝니다.

4. 불필요한 데이터 전송

전체 Entity를 보내면
안 쓰는 필드도 다 전송됩니다.

해결: DTO 사용

@Getter
@AllArgsConstructor
public class ProjectDTO {
    private Long projectId;
    private String name;
    private String leaderName;
    
    public static ProjectDTO from(Project project) {
        return new ProjectDTO(
            project.getProjectId(),
            project.getName(),
            project.getLeader().getName()
        );
    }
}

Controller:

@GetMapping("/api/projects/{id}")
public ProjectDTO getProject(@PathVariable Long id) {
    Project project = projectService.findById(id);
    return ProjectDTO.from(project);
}

BizSync 실제 구조:

요청 DTO:
public class CreateProjectDTO {
    @NotBlank
    private String name;
    
    @NotNull
    private Long leaderId;
    
    public Project toEntity(User leader) {
        return Project.builder()
            .name(name)
            .leader(leader)
            .build();
    }
}

응답 DTO:
public class ProjectResponseDTO {
    private Long projectId;
    private String name;
    private LocalDateTime createdAt;
    
    public static ProjectResponseDTO from(Project project) {
        return new ProjectResponseDTO(
            project.getProjectId(),
            project.getName(),
            project.getCreatedAt()
        );
    }
}

Service 레이어:

@Transactional(readOnly = true)
public ProjectResponseDTO findProject(Long id) {
    Project project = projectRepository.findById(id)
        .orElseThrow(() -> new NotFoundException());
    
    return ProjectResponseDTO.from(project);
}

계층 간 데이터 흐름:

Controller ← DTO ← Service ← Entity ← Repository

각 계층이 적절한 형태로 데이터를 다룹니다.

장점:

1. 순환 참조 방지
2. 보안 (필요한 데이터만)
3. API 스펙 독립적
4. 유효성 검증 편리
5. 성능 (필요한 데이터만)

단점:

1. 코드량 증가
2. 변환 로직 필요
3. 중복 코드 발생 가능

정리:
- Entity: DB 매핑
- DTO: API 통신
- 반드시 분리해야 함
- 변환은 정적 팩토리 메서드
```

---

### **Q90. 예외 처리 전략**

**면접관**: 예외는 어떻게 처리하시나요?

**답변**:

```
예외 처리는 세 가지 전략이 있습니다.

첫 번째, 계층별 예외 변환입니다.

저수준 예외를 고수준 예외로 변환:

// Repository 레이어
try {
    return jdbcTemplate.query(...);
} catch (SQLException e) {
    throw new DataAccessException("DB 조회 실패", e);
}

// Service 레이어
try {
    return repository.findById(id);
} catch (DataAccessException e) {
    throw new BusinessException("프로젝트를 찾을 수 없습니다", e);
}

두 번째, 커스텀 예외 정의입니다.

BizSync 예외 구조:

public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
    
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

public enum ErrorCode {
    PROJECT_NOT_FOUND(404, "프로젝트를 찾을 수 없습니다"),
    UNAUTHORIZED(401, "인증이 필요합니다"),
    FORBIDDEN(403, "권한이 없습니다"),
    INVALID_INPUT(400, "잘못된 입력입니다");
    
    private final int status;
    private final String message;
}

public class ProjectNotFoundException extends BusinessException {
    public ProjectNotFoundException() {
        super(ErrorCode.PROJECT_NOT_FOUND);
    }
}

Service에서 사용:

public Project findById(Long id) {
    return projectRepository.findById(id)
        .orElseThrow(() -> new ProjectNotFoundException());
}

세 번째, 전역 예외 처리입니다.

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ProjectNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(
        ProjectNotFoundException e
    ) {
        ErrorResponse response = new ErrorResponse(
            e.getErrorCode().getStatus(),
            e.getMessage()
        );
        return ResponseEntity
            .status(404)
            .body(response);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
        MethodArgumentNotValidException e
    ) {
        List<String> errors = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .toList();
        
        ErrorResponse response = new ErrorResponse(400, "입력값 검증 실패", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        log.error("예상치 못한 에러", e);
        
        ErrorResponse response = new ErrorResponse(
            500,
            "서버 오류가 발생했습니다"
        );
        return ResponseEntity
            .status(500)
            .body(response);
    }
}

응답 형식:

{
  "status": 404,
  "message": "프로젝트를 찾을 수 없습니다",
  "timestamp": "2025-02-03T10:30:00",
  "errors": []
}

Checked vs Unchecked:

BizSync는 모두 RuntimeException 상속:

장점:
- throws 선언 불필요
- 코드 깔끔
- 예외를 강제하지 않음

단점:
- 컴파일러가 체크 안 함
- 문서화 중요

언제 예외를 던질까?

1. 복구 불가능한 상황
   - 데이터 없음
   - 권한 없음
   - 검증 실패

2. 비즈니스 규칙 위반
   - 이미 승인된 결재 재승인
   - 마감된 프로젝트 수정

언제 예외를 잡을까?

1. 대안이 있을 때
try {
    project = repository.findById(id);
} catch (NotFoundException e) {
    project = createDefaultProject();
}

2. 리소스 정리
try {
    file.write(...);
} finally {
    file.close();
}

3. 로깅
try {
    process();
} catch (Exception e) {
    log.error("처리 실패", e);
    throw e;  // 다시 던지기
}

정리:
- 계층별 예외 변환
- 커스텀 예외 정의
- @RestControllerAdvice로 전역 처리
- Unchecked Exception 선호
```

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]