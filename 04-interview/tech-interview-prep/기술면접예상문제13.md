### **Q101. 보안 - CSRF**

**면접관**: CSRF(Cross-Site Request Forgery) 공격과 방어 방법은?

**답변**:

CSRF는 사용자가 의도하지 않은 요청을 강제로 실행시키는 공격입니다.

**공격 시나리오:**

1. 사용자가 은행 사이트에 로그인
2. 쿠키에 인증 정보 저장됨
3. 악성 사이트 방문
4. 악성 사이트에 숨겨진 폼:

```html
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000000">
</form>
<script>
  document.forms[0].submit();
</script>
```

5. 브라우저가 자동으로 쿠키를 포함해서 요청
6. 은행 서버는 정상 요청으로 인식
7. 돈이 공격자에게 이체됨!

**방어 방법:**

**1. CSRF 토큰 (가장 중요)**

서버가 토큰 생성:

```html
<form action="/transfer" method="POST">
  <input type="hidden" name="_csrf" value="랜덤토큰">
  <input name="amount" value="100">
</form>
```

서버에서 검증:

```java
if (request.getParameter("_csrf") != session.getAttribute("_csrf")) {
    throw new CsrfException();
}
```

Spring Security는 자동:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            .csrf(csrf -> csrf.enable())  // 기본 활성화
            .authorizeHttpRequests(...);
        
        return http.build();
    }
}
```

Thymeleaf에서 자동 삽입:

```html
<form th:action="@{/transfer}" method="post">
  <!-- _csrf 토큰 자동 추가 -->
  <input name="amount">
</form>
```

**2. SameSite 쿠키**

```java
Cookie cookie = new Cookie("JSESSIONID", sessionId);
cookie.setSameSite("Strict");
```

- SameSite=Strict: 다른 사이트에서 쿠키 전송 안 함
- SameSite=Lax: GET은 허용, POST는 차단
- SameSite=None: 모두 허용 (위험)

**3. Referer 검증**

```java
String referer = request.getHeader("Referer");
if (!referer.startsWith("https://mysite.com")) {
    throw new ForbiddenException();
}
```

하지만 Referer는 조작 가능하니까 보조 수단으로만 사용.

**4. Custom Header (REST API)**

```javascript
axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
```

서버에서 검증:

```java
if (request.getHeader("X-Requested-With") == null) {
    throw new CsrfException();
}
```

**BizSync 적용:**

JWT 사용하니까 CSRF 위험 낮음:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            .csrf(csrf -> csrf.disable())  // JWT라서 비활성화
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            );
        
        return http.build();
    }
}
```

**왜 JWT는 안전한가?**

1. **쿠키 자동 전송 없음**  
   Authorization 헤더에 명시적으로 포함

2. **JavaScript에서 직접 추가**

```javascript
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
```

3. **악성 사이트에서 접근 불가**  
   Same-Origin Policy로 localStorage 접근 차단

하지만 JWT를 쿠키에 저장하면 CSRF 위험 있음:

```java
// 위험
response.addCookie(new Cookie("token", jwt));

// 이럴 땐 CSRF 토큰 필수
http.csrf(csrf -> csrf.enable());
```

정리:
- CSRF 토큰이 기본 방어
- SameSite 쿠키 설정
- JWT Bearer 방식은 안전
- JWT를 쿠키에 넣으면 CSRF 토큰 필요

---

### **Q102. 로깅과 모니터링**

**면접관**: 로깅은 어떻게 하시나요?

**답변**:

로깅은 애플리케이션의 상태를 기록하는 겁니다.

**로그 레벨:**

- ERROR: 오류 발생
- WARN: 잠재적 문제
- INFO: 중요한 정보
- DEBUG: 디버깅 정보
- TRACE: 상세한 추적

**Logback 설정:**

```xml
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
    
    <logger name="com.bizsync" level="DEBUG" />
</configuration>
```

**사용:**

```java
@Service
@Slf4j
public class ApprovalService {
    
    public void approve(Long docId) {
        log.info("결재 승인 시작: docId={}", docId);
        
        try {
            ApprovalDocument doc = repository.findById(docId)
                .orElseThrow(() -> new NotFoundException());
            
            doc.approve();
            
            log.info("결재 승인 완료: docId={}", docId);
        } catch (Exception e) {
            log.error("결재 승인 실패: docId={}", docId, e);
            throw e;
        }
    }
}
```

**좋은 로그:**

**1. 구조화된 로그**

```java
// 나쁨
log.info("사용자 로그인 성공");

// 좋음
log.info("사용자 로그인 성공: userId={}, ip={}", userId, ip);
```

**2. 비즈니스 이벤트 로깅**

```java
log.info("결재 승인: docId={}, approver={}, status={}", 
    docId, approverId, status);
```

**3. 성능 측정**

```java
long start = System.currentTimeMillis();
processTask();
long elapsed = System.currentTimeMillis() - start;
log.info("Task 처리 완료: elapsed={}ms", elapsed);
```

**주의사항:**

**1. 민감 정보 로깅 금지**

```java
// 위험!
log.info("로그인: email={}, password={}", email, password);

// 안전
log.info("로그인 시도: email={}", email);
```

**2. 과도한 로깅**

```java
// 나쁨
for (Task task : tasks) {
    log.debug("Task: {}", task);  // 1000번!
}

// 좋음
log.debug("Task 조회 완료: count={}", tasks.size());
```

**MDC (Mapped Diagnostic Context):**

요청마다 고유 ID 부여:

```java
@Component
public class LoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) {
        String requestId = UUID.randomUUID().toString();
        MDC.put("requestId", requestId);
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
```

로그 패턴:

```xml
<pattern>%d [%X{requestId}] %-5level - %msg%n</pattern>
```

결과:

```
2025-02-03 10:30:00 [abc-123] INFO - 결재 승인 시작
2025-02-03 10:30:01 [abc-123] INFO - 결재 승인 완료
```

같은 requestId로 요청 전체를 추적!

**ELK Stack (운영 환경):**

- Elasticsearch: 로그 저장
- Logstash: 로그 수집
- Kibana: 로그 검색/시각화

application.yml:

```yaml
logging:
  file:
    name: /var/log/application.log
```

Logstash가 수집:

```
input {
  file {
    path => "/var/log/application.log"
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
  }
}
```

Kibana에서 검색:

```
level:ERROR AND userId:123
```

정리:
- Slf4j + Logback
- 구조화된 로그 (key=value)
- 민감 정보 제외
- MDC로 요청 추적
- 운영: ELK Stack

---

### **Q103. CI/CD**

**면접관**: CI/CD 파이프라인 구축 경험을 말씀해주세요.

**답변**:

CI/CD는 지속적 통합/배포로 코드 변경을 자동으로 테스트하고 배포하는 자동화 프로세스입니다.

**BizSync GitHub Actions 파이프라인:**

.github/workflows/deploy.yml:

```yaml
name: Deploy to AWS

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v3
    
    - name: JDK 17 설정
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: 빌드 및 테스트
      run: |
        chmod +x ./mvnw
        ./mvnw clean package
    
    - name: Docker 이미지 빌드
      run: |
        docker build -t bizsync-backend .
    
    - name: AWS ECR 로그인
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        aws ecr get-login-password --region ap-northeast-2 | \
        docker login --username AWS --password-stdin \
        123456789.dkr.ecr.ap-northeast-2.amazonaws.com
    
    - name: 이미지 태그 & 푸시
      run: |
        docker tag bizsync-backend:latest \
        123456789.dkr.ecr.ap-northeast-2.amazonaws.com/bizsync:latest
        
        docker push \
        123456789.dkr.ecr.ap-northeast-2.amazonaws.com/bizsync:latest
    
    - name: EC2 배포
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ubuntu
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          docker pull 123456789.dkr.ecr.ap-northeast-2.amazonaws.com/bizsync:latest
          docker stop bizsync || true
          docker rm bizsync || true
          docker run -d --name bizsync \
            -p 8080:8080 \
            -e SPRING_PROFILES_ACTIVE=prod \
            -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
            123456789.dkr.ecr.ap-northeast-2.amazonaws.com/bizsync:latest
```

**CI (Continuous Integration):**

코드 푸시 → 자동 빌드 → 자동 테스트

장점:
- 버그 조기 발견
- 통합 문제 빠르게 해결
- 코드 품질 유지

**CD (Continuous Deployment):**

테스트 통과 → 자동 배포

장점:
- 빠른 배포
- 수동 작업 최소화
- 일관된 배포 프로세스

**파이프라인 단계:**

1. **코드 체크아웃**  
   Git에서 코드 가져오기

2. **빌드**  
   ./mvnw clean package  
   target/app.jar 생성

3. **테스트**  
   ./mvnw test  
   실패 시 파이프라인 중단

4. **정적 분석 (선택)**  
   SonarQube로 코드 품질 검사

5. **Docker 이미지 빌드**  
   Dockerfile로 이미지 생성

6. **이미지 레지스트리에 푸시**  
   ECR, Docker Hub 등

7. **배포**  
   EC2에 SSH 접속  
   컨테이너 교체

**환경 분리:**

- develop 브랜치 → 개발 서버
- main 브랜치 → 운영 서버

```yaml
on:
  push:
    branches:
      - main      # 운영 배포
      - develop   # 개발 배포
```

**Secrets 관리:**

GitHub Settings → Secrets and Variables

- AWS_ACCESS_KEY_ID
- AWS_SECRET_ACCESS_KEY
- DB_PASSWORD
- EC2_SSH_KEY

코드에는 절대 노출 안 됨!

**Blue-Green 배포:**

```bash
script: |
  # Green 환경 시작
  docker run -d --name bizsync-green \
    -p 8081:8080 new-image
  
  # Health Check
  sleep 10
  curl http://localhost:8081/health
  
  # 성공하면 Blue → Green 전환
  docker stop bizsync-blue
  docker rm bizsync-blue
  docker rename bizsync-green bizsync-blue
```

무중단 배포!

**테스트 커버리지 체크:**

```yaml
- name: 테스트 커버리지 확인
  run: |
    ./mvnw test jacoco:report
    
    # 커버리지 70% 미만이면 실패
    ./mvnw jacoco:check
```

**Slack 알림:**

```yaml
- name: Slack 알림
  if: always()
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: '배포가 ${{ job.status }} 되었습니다'
    webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

정리:
- GitHub Actions로 자동화
- 코드 푸시 → 자동 빌드/테스트/배포
- Secrets로 민감 정보 관리
- 브랜치별 환경 분리
- 실패 시 알림

---

### **Q104. 클라우드 - AWS 기본**

**면접관**: AWS 주요 서비스를 설명해주세요.

**답변**:

BizSync 배포에 사용한 AWS 서비스입니다.

**EC2 (Elastic Compute Cloud):**

가상 서버입니다.

인스턴스 타입:
- t2.micro: 1 vCPU, 1GB RAM (프리티어)
- t3.medium: 2 vCPU, 4GB RAM

BizSync는 t3.small 사용:
- 2 vCPU, 2GB RAM
- 월 20달러 정도

보안 그룹:

```
Type      Protocol  Port  Source
SSH       TCP       22    내 IP
HTTP      TCP       80    0.0.0.0/0
HTTPS     TCP       443   0.0.0.0/0
Custom    TCP       8080  0.0.0.0/0
```

**RDS (Relational Database Service):**

관리형 데이터베이스입니다.

장점:
- 자동 백업
- 자동 패치
- 모니터링
- Multi-AZ 고가용성

BizSync는 MariaDB 사용:
- db.t3.micro
- 20GB 스토리지
- 자동 백업 7일 보관

**S3 (Simple Storage Service):**

객체 스토리지입니다.

사용처:
- 정적 파일 (이미지, CSS, JS)
- 로그 저장
- 백업 파일

버킷 생성:
- bizsync-uploads
- bizsync-logs

퍼블릭 액세스 차단: 민감 파일은 private로 설정

**CloudFront (CDN):**

전 세계에 콘텐츠 배포합니다.

```
S3 → CloudFront → 사용자
```

장점:
- 빠른 속도
- 트래픽 분산
- HTTPS 무료 (ACM 인증서)

**Route 53 (DNS):**

도메인 관리입니다.

```
bizsync.com → CloudFront
api.bizsync.com → ALB
```

레코드 타입:
- A: 도메인 → IP
- CNAME: 도메인 → 도메인

**ALB (Application Load Balancer):**

트래픽을 여러 EC2에 분산합니다.

```
         ALB
        /   \
    EC2-1   EC2-2
```

헬스체크:  
/health 엔드포인트에 주기적 요청  
실패하면 트래픽 안 보냄

**ECR (Elastic Container Registry):**

Docker 이미지 저장소입니다.

```
docker push → ECR → EC2에서 pull
```

**VPC (Virtual Private Cloud):**

가상 네트워크입니다.

- Public Subnet: 인터넷 접근 가능 (EC2, ALB)
- Private Subnet: 내부만 (RDS)

**BizSync 구조:**

```
Internet
   ↓
CloudFront (CDN)
   ↓
ALB (Load Balancer)
   ↓
EC2 (Backend)
   ↓
RDS (Database)
```

**보안:**

1. **IAM (Identity and Access Management)**  
   사용자/권한 관리, 최소 권한 원칙

2. **Security Group**  
   방화벽

3. **ACM (Certificate Manager)**  
   HTTPS 인증서 무료

4. **Secrets Manager**  
   DB 비밀번호 안전 보관

**비용:**

- EC2 t3.small: $15/월
- RDS db.t3.micro: $15/월
- S3: 사용량 기준
- CloudFront: 트래픽 기준
- Route 53: $0.5/월

총 $35/월 정도

정리:
- EC2: 서버
- RDS: DB
- S3: 파일 저장
- CloudFront: CDN
- Route 53: DNS
- ALB: 로드 밸런서

---

### **Q105. Docker 심화**

**면접관**: Docker Compose는 어떻게 사용하나요?

**답변**:

Docker Compose는 여러 컨테이너를 한 번에 관리하는 도구입니다.

**BizSync docker-compose.yml:**

```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:mariadb://db:3306/bizsync
      - SPRING_DATASOURCE_USERNAME=root
      - SPRING_DATASOURCE_PASSWORD=${DB_PASSWORD}
    depends_on:
      - db
    networks:
      - bizsync-network
    restart: unless-stopped
  
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - bizsync-network
    restart: unless-stopped
  
  db:
    image: mariadb:10.11
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
      - MYSQL_DATABASE=bizsync
    volumes:
      - db-data:/var/lib/mysql
    networks:
      - bizsync-network
    restart: unless-stopped

networks:
  bizsync-network:
    driver: bridge

volumes:
  db-data:
```

**명령어:**

```bash
# 전체 시작
docker-compose up -d

# 전체 중지
docker-compose down

# 로그 확인
docker-compose logs -f backend

# 특정 서비스만 재시작
docker-compose restart backend

# 빌드 후 시작
docker-compose up -d --build
```

**환경 변수 파일 (.env):**

```
DB_PASSWORD=my_secret_password
```

compose에서 자동으로 읽음: `${DB_PASSWORD}`

**네트워크:**

같은 네트워크 안에서는 서비스 이름으로 통신 가능!

backend에서:

```
jdbc:mariadb://db:3306/bizsync
-- "db"가 컨테이너 이름
```

**볼륨:**

db-data 볼륨으로 데이터 유지:
- 컨테이너 삭제해도 데이터 남음
- 재시작해도 데이터 그대로

**헬스체크:**

```yaml
services:
  backend:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

**의존성 순서:**

```yaml
depends_on:
  - db
```

db 시작 → backend 시작

하지만 주의!  
db 컨테이너가 시작되어도 MariaDB 준비 안 될 수 있음

wait-for-it.sh 사용:

```yaml
services:
  backend:
    command: >
      sh -c "
        ./wait-for-it.sh db:3306 --timeout=60 --
        java -jar app.jar
      "
```

**리소스 제한:**

```yaml
services:
  backend:
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          memory: 256M
```

**스케일링:**

```bash
docker-compose up -d --scale backend=3
```

backend 컨테이너 3개 실행!

**개발 vs 운영:**

- docker-compose.yml (기본)
- docker-compose.prod.yml (운영)

```bash
docker-compose -f docker-compose.yml \
  -f docker-compose.prod.yml up -d
```

운영에서 추가 설정 오버라이드

정리:
- 여러 컨테이너 한 번에 관리
- 네트워크 자동 생성
- 볼륨으로 데이터 유지
- 환경 변수 파일 분리
- 의존성 순서 지정

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]