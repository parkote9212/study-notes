### **Q106. RESTful API 설계 원칙**

**면접관**: RESTful API 설계 시 지켜야 할 원칙은?

**답변**:

RESTful API는 자원(Resource) 중심으로 설계해야 합니다.

**1. URI는 명사, 행위는 HTTP 메서드**

나쁨:
```
POST /getProject
POST /createProject
POST /deleteProject
```

좋음:
```
GET    /api/projects/{id}     # 조회
POST   /api/projects           # 생성
PUT    /api/projects/{id}      # 수정
DELETE /api/projects/{id}      # 삭제
```

**2. 계층 구조 표현**

```
GET /api/projects/{id}/tasks
GET /api/projects/{id}/members
```

프로젝트 하위의 태스크, 멤버

**3. 복수형 사용**

좋음:
```
/api/projects
/api/tasks
```

나쁨:
```
/api/project
/api/task
```

**4. 소문자, 하이픈 사용**

좋음:
```
/api/approval-documents
```

나쁨:
```
/api/approvalDocuments
/api/approval_documents
```

**5. 버전 관리**

```
/api/v1/projects
/api/v2/projects
```

API 변경 시 하위 호환성 유지

**BizSync 실제 API 설계:**

**프로젝트:**
```
GET    /api/v1/projects           # 목록
GET    /api/v1/projects/{id}      # 상세
POST   /api/v1/projects           # 생성
PUT    /api/v1/projects/{id}      # 수정
DELETE /api/v1/projects/{id}      # 삭제
```

**칸반 보드:**
```
GET    /api/v1/projects/{id}/board
```

**태스크:**
```
GET    /api/v1/tasks/{id}
POST   /api/v1/columns/{columnId}/tasks
PUT    /api/v1/tasks/{id}
PATCH  /api/v1/tasks/{id}/move
```

**결재:**
```
GET    /api/v1/approvals
POST   /api/v1/approvals/{id}/approve
POST   /api/v1/approvals/{id}/reject
```

**필터링, 정렬, 페이징:**

```
GET /api/v1/projects?status=ACTIVE&sort=createdAt,desc&page=0&size=20
```

쿼리 파라미터:
- status: 필터
- sort: 정렬
- page, size: 페이징

**검색:**

```
GET /api/v1/projects/search?keyword=협업
```

또는

```
POST /api/v1/projects/search
```

```json
{
  "keyword": "협업",
  "status": ["ACTIVE", "PENDING"]
}
```

**응답 형식:**

성공:
```json
{
  "status": 200,
  "data": {
    "projectId": 1,
    "name": "BizSync"
  }
}
```

목록:
```json
{
  "status": 200,
  "data": {
    "content": [...],
    "page": 0,
    "size": 20,
    "totalElements": 100,
    "totalPages": 5
  }
}
```

에러:
```json
{
  "status": 404,
  "error": "NOT_FOUND",
  "message": "프로젝트를 찾을 수 없습니다",
  "timestamp": "2025-02-03T10:30:00"
}
```

**HTTP 상태코드:**

- 200 OK: 성공
- 201 Created: 생성 성공
- 204 No Content: 성공했지만 응답 없음
- 400 Bad Request: 잘못된 요청
- 401 Unauthorized: 인증 필요
- 403 Forbidden: 권한 없음
- 404 Not Found: 리소스 없음
- 409 Conflict: 충돌 (중복 등)
- 500 Internal Server Error: 서버 오류

**HATEOAS (선택):**

```json
{
  "projectId": 1,
  "name": "BizSync",
  "_links": {
    "self": "/api/v1/projects/1",
    "tasks": "/api/v1/projects/1/tasks",
    "members": "/api/v1/projects/1/members"
  }
}
```

관련 리소스 링크 포함

정리:
- 명사 URI, 동사는 HTTP 메서드
- 계층 구조 표현
- 일관된 응답 형식
- 적절한 HTTP 상태코드
- 버전 관리

---

### **Q107. API 문서화**

**면접관**: API 문서는 어떻게 작성하나요?

**답변**:

API 문서화는 Swagger(OpenAPI)를 많이 사용합니다.

**Swagger 설정:**

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
```

```java
@Configuration
public class SwaggerConfig {
    
    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("BizSync API")
                .version("v1.0")
                .description("프로젝트 협업 관리 시스템 API")
            )
            .addSecurityItem(new SecurityRequirement().addList("Bearer Authentication"))
            .components(new Components()
                .addSecuritySchemes("Bearer Authentication",
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            );
    }
}
```

**Controller 문서화:**

```java
@RestController
@RequestMapping("/api/v1/projects")
@Tag(name = "Project", description = "프로젝트 관리 API")
public class ProjectController {
    
    @Operation(
        summary = "프로젝트 생성",
        description = "새로운 프로젝트를 생성합니다"
    )
    @ApiResponses({
        @ApiResponse(responseCode = "201", description = "생성 성공"),
        @ApiResponse(responseCode = "400", description = "잘못된 요청"),
        @ApiResponse(responseCode = "401", description = "인증 필요")
    })
    @PostMapping
    public ResponseEntity<ProjectDTO> create(
        @Parameter(description = "프로젝트 생성 정보")
        @Valid @RequestBody CreateProjectDTO dto
    ) {
        Project project = projectService.create(dto);
        return ResponseEntity.status(201)
            .body(ProjectDTO.from(project));
    }
    
    @Operation(summary = "프로젝트 조회")
    @GetMapping("/{id}")
    public ProjectDTO getProject(
        @Parameter(description = "프로젝트 ID", example = "1")
        @PathVariable Long id
    ) {
        return projectService.findById(id);
    }
}
```

**DTO 문서화:**

```java
@Schema(description = "프로젝트 생성 요청")
public class CreateProjectDTO {
    
    @Schema(description = "프로젝트명", example = "BizSync")
    @NotBlank
    private String name;
    
    @Schema(description = "프로젝트 설명", example = "협업 관리 시스템")
    private String description;
    
    @Schema(description = "리더 ID", example = "1")
    @NotNull
    private Long leaderId;
}
```

**접속:**

```
http://localhost:8080/swagger-ui/index.html
```

Swagger UI에서:
- API 목록 확인
- Try it out으로 테스트 가능
- 요청/응답 예시 자동 생성

**Postman Collection:**

Swagger JSON 내보내기:
```
http://localhost:8080/v3/api-docs
```

Postman으로 Import:  
File → Import → Swagger JSON

자동으로 모든 API가 Postman에 추가됨!

**README 문서:**

```markdown
# BizSync API

## 인증

모든 API는 JWT 토큰 필요

Authorization: Bearer {token}

## 프로젝트 API

### 프로젝트 생성

POST /api/v1/projects
Content-Type: application/json

{
  "name": "새 프로젝트",
  "description": "설명",
  "leaderId": 1
}

Response:
```

```json
{
  "projectId": 1,
  "name": "새 프로젝트",
  "createdAt": "2025-02-03T10:30:00"
}
```

**API 버전 관리:**

- v1: 현재 버전
- v2: 새 기능 추가

```java
@RequestMapping("/api/v1/projects")  // 기존
@RequestMapping("/api/v2/projects")  // 신규
```

동시에 두 버전 지원 가능

**문서 자동화:**

CI/CD에서 자동으로 문서 생성:

```yaml
- name: Generate API Docs
  run: |
    ./mvnw springdoc-openapi:generate
    
    # Swagger JSON을 S3에 업로드
    aws s3 cp openapi.json s3://docs/api/
```

정리:
- Swagger로 자동 문서화
- @Operation, @Schema로 설명 추가
- Swagger UI에서 테스트 가능
- Postman Collection 생성
- README에 주요 API 정리

---

### **Q108. 대용량 데이터 처리**

**면접관**: 대용량 데이터는 어떻게 처리하나요?

**답변**:

대용량 데이터는 메모리를 고려해서 처리해야 합니다.

**문제 상황:**

```java
// 나쁨
List<Task> tasks = taskRepository.findAll();
// 10만 건을 한 번에 메모리에!
// OutOfMemoryError 위험
```

**해결 방법:**

**1. 페이징**

```java
Pageable pageable = PageRequest.of(0, 1000);
Page<Task> page = taskRepository.findAll(pageable);

while (page.hasContent()) {
    List<Task> tasks = page.getContent();
    
    // 1000개씩 처리
    processTasks(tasks);
    
    if (page.hasNext()) {
        pageable = page.nextPageable();
        page = taskRepository.findAll(pageable);
    } else {
        break;
    }
}
```

**2. Cursor 방식**

```java
Long lastId = 0L;
int batchSize = 1000;

while (true) {
    List<Task> tasks = taskRepository
        .findByTaskIdGreaterThan(lastId, PageRequest.of(0, batchSize));
    
    if (tasks.isEmpty()) break;
    
    processTasks(tasks);
    
    lastId = tasks.get(tasks.size() - 1).getTaskId();
}
```

페이징보다 성능 좋음 (OFFSET 없음)

**3. Stream API**

```java
try (Stream<Task> stream = taskRepository.streamAll()) {
    stream
        .filter(task -> task.getStatus() == PENDING)
        .forEach(this::processTask);
}
```

```java
@Query("SELECT t FROM Task t")
Stream<Task> streamAll();
```

하나씩 처리하니까 메모리 절약

**4. Batch Insert**

```java
// 나쁨
for (Task task : tasks) {
    taskRepository.save(task);  // 10만 번 INSERT!
}

// 좋음
@Transactional
public void batchInsert(List<Task> tasks) {
    int batchSize = 1000;
    
    for (int i = 0; i < tasks.size(); i++) {
        entityManager.persist(tasks.get(i));
        
        if (i % batchSize == 0 && i > 0) {
            entityManager.flush();
            entityManager.clear();
        }
    }
}
```

application.yml:
```yaml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 1000
```

1000개씩 모아서 한 번에 INSERT

**5. 비동기 처리**

```java
@Async
public CompletableFuture<Void> processLargeData() {
    List<Task> tasks = fetchTasks();
    
    // 별도 스레드에서 처리
    processTasks(tasks);
    
    return CompletableFuture.completedFuture(null);
}
```

사용자는 응답을 기다리지 않음

**6. Spring Batch**

```java
@Bean
public Job exportTasksJob() {
    return jobBuilderFactory.get("exportTasks")
        .start(exportStep())
        .build();
}

@Bean
public Step exportStep() {
    return stepBuilderFactory.get("export")
        .<Task, TaskDTO>chunk(1000)
        .reader(taskReader())
        .processor(taskProcessor())
        .writer(taskWriter())
        .build();
}
```

1000개씩 읽고 → 처리하고 → 쓰기

**BizSync 적용 예:**

**월말 통계 생성 (10만 건)**

```java
@Service
public class StatisticsService {
    
    public void generateMonthlyStats() {
        Long lastId = 0L;
        int batchSize = 5000;
        
        while (true) {
            List<Task> tasks = taskRepository
                .findCompletedTasksAfter(lastId, batchSize);
            
            if (tasks.isEmpty()) break;
            
            // 통계 계산
            Statistics stats = calculateStats(tasks);
            statsRepository.save(stats);
            
            lastId = tasks.get(tasks.size() - 1).getTaskId();
            
            // 메모리 정리
            entityManager.clear();
        }
    }
}
```

**CSV 내보내기 (대용량)**

```java
@GetMapping("/api/tasks/export")
public void exportTasks(HttpServletResponse response) {
    response.setContentType("text/csv");
    response.setHeader("Content-Disposition", 
        "attachment; filename=tasks.csv");
    
    try (
        PrintWriter writer = response.getWriter();
        Stream<Task> stream = taskRepository.streamAll()
    ) {
        writer.println("ID,Title,Status");
        
        stream.forEach(task -> {
            writer.println(String.format("%d,%s,%s",
                task.getTaskId(),
                task.getTitle(),
                task.getStatus()
            ));
        });
    }
}
```

스트리밍으로 바로 출력  
메모리에 안 쌓임

정리:
- 페이징으로 나눠서 처리
- Cursor 방식이 더 빠름
- Stream API로 메모리 절약
- Batch Insert로 성능 향상
- 비동기 처리
- Spring Batch 활용

---

### **Q109. 동시성 제어**

**면접관**: 동시성 문제를 어떻게 해결하나요?

**답변**:

동시성 문제는 여러 스레드가 같은 데이터를 동시에 수정할 때 발생합니다.

**문제 상황:**

재고 차감:

초기 재고: 10개

- 사용자 A: 재고 조회 (10개) → 5개 구매 → 재고 5개로 저장
- 사용자 B: 재고 조회 (10개) → 3개 구매 → 재고 7개로 저장

결과: 재고 7개  
예상: 재고 2개 (10 - 5 - 3)

Lost Update 문제!

**해결 방법:**

**1. 낙관적 락 (Optimistic Lock)**

```java
@Entity
public class Product {
    @Id
    private Long id;
    
    private int stock;
    
    @Version
    private Long version;  // 버전 관리
}
```

**동작:**

1. 조회: `SELECT stock, version FROM product`  
   stock=10, version=1

2. 재고 차감: stock = 5

3. 저장: `UPDATE product SET stock = 5, version = 2 WHERE id = 1 AND version = 1`

4. 만약 version이 바뀌었으면 실패 → OptimisticLockException

```java
@Service
public class ProductService {
    
    @Transactional
    public void purchase(Long productId, int quantity) {
        try {
            Product product = repository.findById(productId);
            product.decreaseStock(quantity);
            repository.save(product);
        } catch (OptimisticLockException e) {
            // 재시도
            throw new ConcurrentUpdateException("재고가 변경되었습니다. 다시 시도해주세요");
        }
    }
}
```

장점: 충돌 적음, 성능 좋음  
단점: 충돌 시 재시도 필요

**2. 비관적 락 (Pessimistic Lock)**

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Product findByIdWithLock(@Param("id") Long id);
```

```java
@Transactional
public void purchase(Long productId, int quantity) {
    Product product = repository.findByIdWithLock(productId);
    // 다른 트랜잭션은 대기
    
    product.decreaseStock(quantity);
    repository.save(product);
    // 커밋되면 락 해제
}
```

`SELECT ... FOR UPDATE`  
다른 트랜잭션이 읽기/쓰기 불가

장점: 확실한 동기화  
단점: 성능 저하, 데드락 위험

**3. 분산 락 (Redis)**

```java
@Component
public class RedisLockService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean tryLock(String key, long timeout) {
        return redisTemplate.opsForValue()
            .setIfAbsent(key, "locked", 
                Duration.ofSeconds(timeout));
    }
    
    public void unlock(String key) {
        redisTemplate.delete(key);
    }
}
```

```java
@Service
public class ProductService {
    
    @Autowired
    private RedisLockService lockService;
    
    public void purchase(Long productId, int quantity) {
        String lockKey = "product:" + productId;
        
        if (!lockService.tryLock(lockKey, 10)) {
            throw new ConcurrentUpdateException();
        }
        
        try {
            Product product = repository.findById(productId);
            product.decreaseStock(quantity);
            repository.save(product);
        } finally {
            lockService.unlock(lockKey);
        }
    }
}
```

여러 서버에서도 동작!

**4. Database 제약조건**

```sql
ALTER TABLE product 
ADD CONSTRAINT check_stock_positive 
CHECK (stock >= 0);
```

재고가 음수되면 자동으로 에러

**BizSync 적용 예:**

**결재 라인 순서 변경:**

```java
@Entity
public class ApprovalLine {
    @Id
    private Long id;
    
    private int sequence;
    
    @Version
    private Long version;  // 낙관적 락
}
```

```java
@Transactional
public void changeSequence(Long lineId, int newSequence) {
    ApprovalLine line = repository.findById(lineId);
    line.setSequence(newSequence);
    
    // version 불일치 시 예외
}
```

**칸반 Task 이동:**

동시에 같은 Task를 다른 컬럼으로 이동?

```java
@Transactional
public void moveTask(Long taskId, Long newColumnId) {
    Task task = taskRepository.findByIdWithLock(taskId);
    // 비관적 락으로 동시 수정 방지
    
    task.setColumnId(newColumnId);
}
```

**선택 기준:**

**낙관적 락:**
- 충돌이 적을 때
- 읽기가 많을 때
- 성능 중요

**비관적 락:**
- 충돌이 많을 때
- 쓰기가 많을 때
- 정합성 중요

**분산 락:**
- 여러 서버 환경
- 복잡한 비즈니스 로직

정리:
- 낙관적 락: @Version
- 비관적 락: FOR UPDATE
- 분산 락: Redis
- DB 제약조건 활용

---

### **Q110. 트랜잭션 전파**

**면접관**: 트랜잭션 전파(Propagation)를 설명해주세요.

**답변**:

트랜잭션 전파는 트랜잭션이 어떻게 전달되는지 정의합니다.

**상황:**

```java
@Transactional
public void methodA() {
    // 트랜잭션 A 시작
    
    methodB();  // 트랜잭션 B?
    
    // 트랜잭션 A 커밋
}

@Transactional
public void methodB() {
    // 새로운 트랜잭션? 기존 트랜잭션 참여?
}
```

**전파 타입:**

**1. REQUIRED (기본값)**

```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
}
```

- 트랜잭션 있으면 참여
- 없으면 새로 생성

methodA (트랜잭션 있음) → methodB: 같은 트랜잭션 사용

methodB만 호출 (트랜잭션 없음) → methodB: 새 트랜잭션 생성

**2. REQUIRES_NEW**

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
}
```

- 항상 새 트랜잭션 생성
- 기존 트랜잭션은 일시 중단

methodA (트랜잭션 A) → methodB: 새 트랜잭션 B 생성  
→ methodB 커밋/롤백은 독립적

**사용 예:**

```java
@Transactional
public void approveDocument(Long docId) {
    // 트랜잭션 A
    
    document.approve();
    
    // 알림은 별도 트랜잭션
    logService.saveLog("결재 승인");
    
    // 메인 작업 실패해도 로그는 저장됨
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void saveLog(String message) {
    // 트랜잭션 B (독립적)
    auditLog.save(message);
}
```

**3. MANDATORY**

```java
@Transactional(propagation = Propagation.MANDATORY)
public void methodB() {
}
```

- 트랜잭션 필수
- 없으면 예외

```java
// OK
@Transactional
public void methodA() {
    methodB();  // 트랜잭션 있음
}

// Exception!
public void methodA() {
    methodB();  // 트랜잭션 없음
}
```

**4. SUPPORTS**

```java
@Transactional(propagation = Propagation.SUPPORTS)
public void methodB() {
}
```

- 트랜잭션 있으면 참여
- 없어도 괜찮음 (트랜잭션 없이 실행)

**5. NOT_SUPPORTED**

```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void methodB() {
}
```

- 트랜잭션 없이 실행
- 기존 트랜잭션 있으면 일시 중단

**6. NEVER**

```java
@Transactional(propagation = Propagation.NEVER)
public void methodB() {
}
```

- 트랜잭션 있으면 예외
- 트랜잭션 없이만 실행 가능

**7. NESTED**

```java
@Transactional(propagation = Propagation.NESTED)
public void methodB() {
}
```

- 중첩 트랜잭션 생성
- 외부 커밋되면 함께 커밋
- 내부만 롤백 가능

**BizSync 적용:**

**결재 승인 + 알림:**

```java
@Transactional
public void approve(Long docId) {
    // 메인 트랜잭션
    
    ApprovalDocument doc = repository.findById(docId);
    doc.approve();
    repository.save(doc);
    
    // 알림 전송 (독립 트랜잭션)
    notificationService.send(docId);
    
    // 알림 실패해도 결재는 성공
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void send(Long docId) {
    // 별도 트랜잭션
    // 실패해도 메인 트랜잭션에 영향 없음
    
    try {
        emailService.sendEmail(...);
        slackService.sendMessage(...);
    } catch (Exception e) {
        log.error("알림 전송 실패", e);
        // 예외 삼킴 (메인에 영향 안 줌)
    }
}
```

**주의사항:**

**같은 클래스 내부 호출:**

```java
@Service
public class MyService {
    
    @Transactional
    public void methodA() {
        methodB();  // 전파 안 됨!
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // 새 트랜잭션 기대했지만
        // 실제로는 methodA 트랜잭션 사용
    }
}
```

프록시를 거쳐야 하는데 self 호출은 프록시 안 거침!

**해결:**

```java
@Autowired
private MyService self;  // 자기 자신 주입

@Transactional
public void methodA() {
    self.methodB();  // 프록시 거침!
}
```

정리:
- REQUIRED: 기본, 참여 또는 생성
- REQUIRES_NEW: 항상 새로 생성
- MANDATORY: 필수
- 독립적 처리: REQUIRES_NEW
- self 호출 주의

---
[[기술면접예상문제1]]
[[기술면접예상문제2]]
[[기술면접예상문제3]]
[[기술면접예상문제4]]
[[기술면접예상문제5]]
[[기술면접예상문제6]]
[[기술면접예상문제7]]
[[기술면접예상문제8]]
[[기술면접예상문제9]]
[[기술면접예상문제10]]
[[기술면접예상문제11]]
[[기술면접예상문제12]]
[[기술면접예상문제13]]
[[기술면접예상문제14]]
[[기술면접예상문제15]]