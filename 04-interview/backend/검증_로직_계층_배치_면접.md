---
tags: interview, Spring, Validation, Architecture
created: 2026-01-20
difficulty: 중
---

# 검증 로직을 어느 계층에 두는 것이 좋은가요?

## 질문
> DTO, Service, Entity 중 어디에 검증 로직을 배치하는 것이 좋으며, 그 이유는 무엇인가요?

## 핵심 답변 (3줄)
1. **DTO 검증(추천)**: Bean Validation으로 요청 데이터의 형식/필수 여부를 검증하고, 커스텀 메서드로 비즈니스 규칙 검증
2. **Controller에서 호출**: `@Valid`로 자동 검증 후 DTO의 커스텀 검증 메서드를 명시적으로 호출하여 DB 조회 전에 빠르게 실패 (Fail-Fast)
3. Entity 검증은 중복이므로 피하고, Service는 비즈니스 로직에만 집중하도록 역할 분리

## 상세 설명

### 검증 레이어별 특징

| 계층 | 시점 | 장점 | 단점 | 적합도 |
|------|------|------|------|-------|
| **DTO** | HTTP 요청 직후 | DB 부하 없이 빠른 실패 | - | ✅ 추천 |
| **Controller** | Service 호출 전 | 명확한 위치 | 코드 복잡 | △ |
| **Service** | 비즈니스 로직 중 | 로직과 가까움 | 늦은 검증 | △ |
| **Entity** | DB 저장 직전 | 무결성 보장 | DB까지 갔다가 실패 | ❌ 비추천 |

### 실무 적용: BizSync 비용 결재 검증

**요구사항:**
- 결재 타입이 EXPENSE(비용)일 때만 projectId, amount 필수
- 일반 결재(휴가, 업무)는 불필요

**DTO 검증 구현:**
```java
public record ApprovalCreateRequestDTO(
    @NotNull(message = "결재 유형은 필수입니다.")
    ApprovalType type,
    
    @DecimalMin(value = "0.01")
    BigDecimal amount,
    
    Long projectId,
    
    @NotBlank @Size(max = 100)
    String title,
    
    @NotEmpty
    List<Long> approverIds
) {
    // 커스텀 검증
    public void validateExpenseApproval() {
        if (type == ApprovalType.EXPENSE) {
            if (projectId == null) {
                throw new IllegalArgumentException(
                    "비용 결재는 프로젝트 ID가 필수입니다."
                );
            }
            if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                throw new IllegalArgumentException(
                    "비용 결재는 유효한 금액이 필수입니다."
                );
            }
        }
    }
}
```

**Controller에서 사용:**
```java
@PostMapping
public ResponseEntity<?> createApproval(
    @Valid @RequestBody ApprovalCreateRequestDTO dto  // 1. Bean Validation
) {
    dto.validateExpenseApproval();  // 2. 커스텀 검증
    
    Long id = approvalService.createApproval(dto);
    return ResponseEntity.ok(id);
}
```

**왜 이 방식이 좋은가?**
1. **Fail-Fast**: DB 조회 전에 검증 (성능 ↑)
2. **명확한 책임**: DTO는 데이터 검증, Service는 비즈니스 로직
3. **테스트 용이**: 단위 테스트가 쉬움
4. **재사용 가능**: 여러 Controller에서 같은 DTO 사용 가능

## 코드 예시 (필요시)
```java
// ❌ 안티패턴: Entity 검증 (DB 저장 직전)
@Entity
public class ApprovalDocument {
    public void validateBudget() {
        if (isExpenseApproval() && amount == null) {
            throw new IllegalStateException("비용 결재는 금액이 필수입니다.");
        }
    }
}

@Service
public class ApprovalService {
    public Long createApproval(DTO dto) {
        Project project = projectRepository.findById(dto.projectId())
            .orElseThrow();  // DB 조회 먼저
        
        ApprovalDocument doc = ApprovalDocument.builder()
            .project(project)
            .amount(dto.amount())
            .build();
        
        doc.validateBudget();  // ❌ 늦은 검증 (이미 DB 조회함)
        // ...
    }
}

// ✅ 권장 패턴: DTO 검증 (요청 직후)
@RestController
public class ApprovalController {
    @PostMapping
    public ResponseEntity<?> createApproval(
        @Valid @RequestBody ApprovalCreateRequestDTO dto
    ) {
        dto.validateExpenseApproval();  // ✅ DB 조회 전 검증
        
        approvalService.createApproval(dto);
        // ...
    }
}
```

## 꼬리 질문 예상
- **Q1: @Valid는 어떻게 동작하나요?**
  - A: Spring의 ArgumentResolver가 메서드 실행 전에 Bean Validation API를 호출하여 자동으로 검증합니다.

- **Q2: 커스텀 검증 메서드를 왜 DTO에 두나요?**
  - A: DTO는 데이터 전송 객체로, 자신이 받은 데이터의 유효성을 검증하는 것이 책임입니다.

- **Q3: Entity 검증을 아예 하지 말아야 하나요?**
  - A: DTO 검증으로 충분하다면 불필요하지만, 영속성 계층의 무결성을 위해 최소한의 제약조건(`@NotNull` 등)은 유지할 수 있습니다.

- **Q4: Service에서 검증하면 안 되나요?**
  - A: 가능하지만, Service는 비즈니스 로직에 집중하는 것이 단일 책임 원칙에 부합합니다.

## 참고
- [[DTO_검증_전략]]
- [[Bean_Validation]]
- [[레이어드_아키텍처]]
- [[Fail_Fast_원칙]]
