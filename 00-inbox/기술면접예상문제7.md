네, 계속 진행하겠습니다!

---

### **Q56. Git Conflict 해결**

**면접관**: Git 충돌이 발생했을 때 어떻게 해결하나요?

**답변**:

```
충돌은 같은 파일의 같은 부분을
두 브랜치에서 다르게 수정했을 때 발생합니다.

BizSync에서 실제로 겪은 상황을 예로 들면,

제가 feature 브랜치에서
ApprovalService.java를 수정하고 있었는데
그 사이에 다른 팀원이 같은 파일을
main에 머지했습니다.

git pull origin main
# CONFLICT (content): Merge conflict in ApprovalService.java

파일을 열어보면 이렇게 나옵니다.

public void approve(Long docId) {
<<<<<<< HEAD
    ApprovalDocument doc = repository.findById(docId);
    doc.setStatus(APPROVED);
=======
    ApprovalDocument doc = repository.findByIdOrThrow(docId);
    doc.approve();
>>>>>>> main
    notificationService.send(doc);
}

해설하면,
<<<<<<< HEAD: 내 변경사항
=======: 구분선
>>>>>>> main: main 브랜치 변경사항

해결 방법:

1. 둘 중 하나 선택하거나
2. 둘 다 반영하거나
3. 완전히 새로 작성

저는 이렇게 해결했습니다.

public void approve(Long docId) {
    // main의 코드가 더 나아서 채택
    ApprovalDocument doc = repository.findByIdOrThrow(docId);
    doc.approve();
    notificationService.send(doc);
}

마커 삭제하고 저장 후:

git add ApprovalService.java
git commit -m "Merge conflict 해결: findByIdOrThrow 사용"

IDE 도구 활용:

IntelliJ에서는 충돌 파일에
Accept Yours / Accept Theirs / Merge 버튼이 나옵니다.

시각적으로 보면서 선택할 수 있어서 편합니다.

충돌 예방:

1. 자주 pull 받기
git pull origin main  # 하루 한 번 이상

2. 작은 단위로 작업
큰 파일 통째로 수정하면 충돌 가능성 높아집니다.

3. 커뮤니케이션
"제가 ApprovalService 수정 중입니다"
같은 파일 동시 작업 피하기

충돌이 복잡하면:

git merge --abort  # 머지 취소
# 팀원과 상의 후 다시 시도

정리:
- 마커 찾아서 수동 해결
- IDE 도구 활용
- 자주 pull로 예방
- 복잡하면 abort 후 상의
```

---

### **Q57. Git Stash**

**면접관**: Git Stash는 언제 사용하나요?

**답변**:

```
Stash는 작업 중인 변경사항을 
임시로 저장할 때 씁니다.

상황을 예로 들면,

제가 feature 브랜치에서
Task 수정 기능을 개발하고 있었는데
갑자기 긴급 버그가 발생했습니다.

커밋하기엔 작업이 덜 됐고,
버리기는 아까운 상황이죠.

// 현재 변경사항 임시 저장
git stash save "Task 수정 기능 작업 중"

// 깨끗한 상태로 돌아감
git status
# nothing to commit, working tree clean

// 버그 수정 브랜치로 이동
git checkout main
git checkout -b hotfix/critical-bug

// 버그 수정 후
git add .
git commit -m "fix: 긴급 버그 수정"
git push origin hotfix/critical-bug

// 다시 feature 브랜치로
git checkout feature/task-edit

// 저장한 작업 복원
git stash pop

이제 작업하던 대로 계속할 수 있습니다.

Stash 명령어들:

// 저장
git stash
git stash save "설명"

// 목록 확인
git stash list
# stash@{0}: 작업 3
# stash@{1}: 작업 2
# stash@{2}: 작업 1

// 적용
git stash apply stash@{1}  # 특정 stash 적용 (유지)
git stash pop               # 최근 stash 적용 후 삭제

// 삭제
git stash drop stash@{0}    # 특정 stash 삭제
git stash clear             # 전체 삭제

BizSync에서 실제로 쓴 경우:

1. 브랜치 전환할 때
작업 중인데 다른 브랜치로 급하게 이동

2. Pull 받기 전
로컬 변경사항 있는데 pull 받아야 할 때

git stash
git pull origin main
git stash pop

3. 실험적인 코드
"이거 되나 한번 해보자"
안 되면 stash drop

주의사항:

충돌 가능:
git stash pop 했는데
그 사이 같은 부분 수정됐으면
충돌 발생합니다.

이럴 땐 수동으로 해결해야 합니다.

정리:
- 임시 저장: stash save
- 복원: stash pop
- 브랜치 전환 시 유용
```

---

### **Q58. Git Tag**

**면접관**: Git Tag는 언제 사용하고 어떻게 만드나요?

**답변**:

```
Tag는 특정 커밋을 표시하는 건데요,
주로 릴리즈 버전을 표시할 때 씁니다.

BizSync에서 실제로 사용한 방법입니다.

배포할 때마다 태그를 달았습니다.

// v1.0.0 릴리즈
git tag -a v1.0.0 -m "첫 번째 정식 릴리즈

- 프로젝트 관리 기능
- 칸반 보드
- 결재 시스템
- JWT 인증"

git push origin v1.0.0

// 버그 수정 릴리즈
git tag -a v1.0.1 -m "버그 수정

- 로그인 오류 해결
- N+1 문제 수정"

git push origin v1.0.1

Lightweight Tag vs Annotated Tag:

// Lightweight (간단한 포인터만)
git tag v1.0.0

// Annotated (메시지, 작성자, 날짜 포함)
git tag -a v1.0.0 -m "메시지"

실무에서는 항상 Annotated Tag를 씁니다.
정보가 더 많으니까요.

태그 확인:

git tag                    # 목록
git show v1.0.0           # 상세 정보
git checkout v1.0.0       # 특정 버전 체크아웃

버전 규칙 (Semantic Versioning):

v1.2.3
- 1: Major (큰 변경, 하위 호환 안 됨)
- 2: Minor (기능 추가, 하위 호환 됨)
- 3: Patch (버그 수정)

예시:
v1.0.0 → v1.1.0 (기능 추가)
v1.1.0 → v1.1.1 (버그 수정)
v1.1.1 → v2.0.0 (대규모 변경)

GitHub Release:

태그를 푸시하면 GitHub에서
Release를 만들 수 있습니다.

릴리즈 노트 작성하고
빌드된 jar 파일 첨부도 가능합니다.

Docker Image도 태그와 연결:

docker build -t bizsync-backend:v1.0.0 .
docker push bizsync-backend:v1.0.0

나중에 롤백할 때:

git checkout v1.0.0
docker pull bizsync-backend:v1.0.0

이전 버전으로 쉽게 돌아갈 수 있습니다.

태그 삭제:

git tag -d v1.0.0              # 로컬 삭제
git push origin :refs/tags/v1.0.0  # 원격 삭제

정리:
- 릴리즈 버전 표시
- Semantic Versioning 사용
- Annotated Tag 권장
- GitHub Release와 연동
```

---

### **Q59. Commit 메시지 작성법**

**면접관**: 좋은 커밋 메시지를 작성하는 방법은?

**답변**:

```
커밋 메시지는 다른 사람이 봤을 때
무슨 변경인지 바로 알 수 있게 써야 합니다.

BizSync에서 사용한 규칙입니다.

형식:

<타입>: <제목>

<본문>

<꼬리말>

타입:

feat: 새 기능
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅 (기능 변경 없음)
refactor: 리팩토링
test: 테스트 추가
chore: 빌드, 설정 변경

예시들:

나쁨:
git commit -m "수정"
git commit -m "버그 수정"
git commit -m "기능 추가"
# 뭘 수정했는지 모름!

좋음:
git commit -m "feat: 결재 시스템 다단계 승인 구현"
git commit -m "fix: 로그인 시 JWT 만료 체크 오류 수정"
git commit -m "refactor: ApprovalService 책임 분리"

본문이 필요한 경우:

git commit -m "feat: WebSocket 실시간 알림 구현

- STOMP 프로토콜 사용
- 프로젝트별 topic 구독
- 재연결 로직 추가

Closes #42"

본문에는:
- 무엇을 변경했는지
- 왜 변경했는지
- 어떻게 변경했는지

Issue 번호 연결:

Closes #42    # 이슈 닫기
Fixes #42     # 버그 수정
Ref #42       # 참조만

GitHub에서 자동으로 이슈와 연결됩니다.

제목 작성 규칙:

1. 50자 이내
2. 명령문 사용 ("추가했다" X, "추가" O)
3. 마침표 없음
4. 영문은 대문자 시작

예시:
feat: Add approval system
fix: Resolve login JWT error
docs: Update README installation guide

한글도 OK:
feat: 결재 시스템 추가
fix: 로그인 JWT 오류 해결

BizSync에서 실제 커밋:

feat: JWT 인증 구현

- JwtProvider 클래스 추가
- SecurityConfig에 JWT 필터 등록
- 로그인/회원가입 API 구현
- 테스트 코드 작성

Closes #15

이렇게 쓰면 나중에
git log 볼 때 변경 이력이 명확합니다.

Atomic Commit:

하나의 커밋에는 하나의 목적만!

나쁨:
git commit -m "로그인 기능 추가, 버그 수정, 리팩토링"

좋음:
git commit -m "feat: 로그인 기능 추가"
git commit -m "fix: 비밀번호 검증 오류 수정"
git commit -m "refactor: AuthService 메서드 분리"

정리:
- 타입: 제목 형식
- 제목 50자 이내
- 본문에 상세 설명
- 하나의 커밋, 하나의 목적
```

---

### **Q60. Git Reset vs Revert**

**면접관**: Reset과 Revert의 차이는?

**답변**:

```
Reset은 커밋을 없애고,
Revert는 커밋을 취소하는 새 커밋을 만듭니다.

Reset:

A - B - C - D (현재)

git reset --hard HEAD~2

A - B (현재)
# C, D가 완전히 사라짐

Revert:

A - B - C - D (현재)

git revert D

A - B - C - D - D' (현재)
# D를 취소하는 새 커밋 D' 생성

언제 뭘 쓰나?

Reset: 로컬에서만, 아직 안 푸시했을 때
git reset --hard HEAD~1
# 마지막 커밋 없던 일로

Revert: 이미 푸시했을 때
git revert abc123
# 안전하게 취소

BizSync에서 겪은 상황:

실수로 .env 파일을 커밋했는데
아직 푸시 안 했습니다.

git reset --soft HEAD~1
# 커밋만 취소, 파일은 유지

git reset --hard HEAD~1
# 커밋도 취소, 파일도 원복

이미 푸시한 경우:

git revert abc123
git push origin main
# 안전하게 취소 커밋 추가

Reset 옵션:

--soft: 커밋만 취소 (파일, staging 유지)
--mixed: 커밋, staging 취소 (파일 유지)
--hard: 전부 취소 (위험!)

예시:

git reset --soft HEAD~1
git status
# Changes to be committed:
#   modified: file.java

git reset --mixed HEAD~1
git status
# Changes not staged for commit:
#   modified: file.java

git reset --hard HEAD~1
git status
# nothing to commit

주의사항:

이미 푸시한 커밋을 reset하면
다른 사람과 히스토리가 꼬입니다!

// 절대 금지!
git reset --hard HEAD~3
git push -f origin main
# 다른 팀원들 작업 날아감

대신 revert 사용:

git revert HEAD~2..HEAD
git push origin main
# 안전하게 취소

여러 개 revert:

git revert --no-commit HEAD~3..HEAD
git commit -m "Revert 3개 커밋 일괄 취소"

정리:
- 로컬만: reset
- 푸시했으면: revert
- reset --hard는 조심
- 팀 작업은 항상 revert
```

---

## **Part 10: 면접 기본 질문 (10개)**

### **Q61. 자기소개**

**면접관**: 간단하게 자기소개 부탁드립니다.

**답변**:

```
안녕하세요. 웹 풀스택 개발자로 지원한 박지찬입니다.

저는 연세대 IT 교육원에서 6개월간
풀스택 개발 과정을 이수했고,
그 전에는 8년 동안 건설 현장에서
품질관리와 안전관리를 담당했습니다.

전공은 다르지만 개발자로 전향한 이유는,
현장에서 안전 관리를 하면서
수작업으로 하던 보고서 작성이나
데이터 관리를 자동화하면
효율이 엄청 올라갈 것 같다는 생각을 했고,
그 과정에서 개발에 흥미를 느꼈기 때문입니다.

교육 과정에서는 Java, Spring Boot를 중심으로
백엔드 개발을 배웠고,
프론트엔드는 React를 사용했습니다.

개인 프로젝트로는 BizSync라는
프로젝트 협업 관리 시스템을 만들었는데요,
칸반 보드, 결재 시스템, 실시간 알림 등의
기능을 구현했고,
Docker로 컨테이너화해서 AWS에 배포했습니다.

특히 이전 경력에서 쌓은
꼼꼼함과 문서화 역량이
개발에도 도움이 많이 됐습니다.
코드 리뷰나 문서 작성에 익숙하고,
QA 마인드로 버그를 찾는 데도 강점이 있습니다.

신입이지만 빠르게 배우고
팀에 기여할 수 있는 개발자가 되겠습니다.
감사합니다.
```

---

### **Q62. 왜 개발자가 되려고 하나요?**

**면접관**: 비전공자인데 왜 개발자로 전향하셨나요?

**답변**:

```
세 가지 이유가 있습니다.

첫 번째는 문제 해결의 즐거움입니다.

건설 현장에서 안전 점검 체크리스트를
엑셀로 관리했었는데,
매일 수작업으로 취합하고
보고서 만드는 게 비효율적이었습니다.

그래서 간단하게나마 매크로를 만들어봤는데,
3시간 걸리던 작업이 5분으로 줄더라고요.

이때 "코드로 문제를 해결한다"는 게
정말 매력적으로 느껴졌습니다.

두 번째는 계속 배울 수 있다는 점입니다.

건설은 경력이 쌓이면
비슷한 일의 반복이 많은데,
개발은 항상 새로운 기술이 나오고
배울 게 끝이 없잖아요.

BizSync 프로젝트하면서도
WebSocket, Docker, AWS 등
처음 배우는 기술들이 많았는데,
하나씩 익혀가는 과정이 재밌었습니다.

세 번째는 영향력입니다.

건설은 특정 현장에만 영향을 주지만,
개발한 서비스는 수많은 사람들에게
가치를 줄 수 있잖아요.

제가 만든 코드가 누군가의
생산성을 높이고 문제를 해결한다는 게
정말 의미 있다고 생각합니다.

물론 전공자보다 늦게 시작했지만,
8년간 현장에서 쌓은
커뮤니케이션 능력과 문제 해결 경험,
그리고 QA 마인드는
개발자로서도 충분히 강점이 될 거라 확신합니다.
```

---

### **Q63. 본인의 강점은?**

**면접관**: 본인의 강점을 말씀해주세요.

**답변**:

```
제 강점은 세 가지입니다.

첫 번째, 꼼꼼함입니다.

이전에 품질관리를 했었기 때문에
디테일을 놓치지 않는 습관이 있습니다.

BizSync 개발할 때도
단순히 기능이 동작하는 것에서 끝나지 않고,
예외 처리, 에러 메시지, 사용자 경험까지
세심하게 신경 썼습니다.

예를 들어 JWT 토큰 만료 시
"인증 실패"가 아니라
"로그인 세션이 만료되었습니다. 다시 로그인해주세요"
같은 명확한 메시지를 보여주도록 했습니다.

두 번째, 문서화 역량입니다.

건설 현장에서 보고서를 많이 작성했었는데,
이 경험이 개발에도 큰 도움이 됐습니다.

README 작성, API 문서화, 주석 작성 등
다른 사람이 봐도 이해할 수 있게
문서를 정리하는 데 익숙합니다.

BizSync 프로젝트 README를 보시면
설치 방법, 환경 설정, API 명세까지
상세하게 작성해뒀습니다.

세 번째, 빠른 학습 능력입니다.

6개월 교육 과정에서
Java, Spring, React, Docker, AWS까지
처음 접하는 기술들을 빠르게 습득했고,
실제 프로젝트에 바로 적용했습니다.

특히 WebSocket 실시간 통신은
교육 과정에 없었는데,
공식 문서와 Stack Overflow를 보면서
스스로 학습해서 구현했습니다.

신입이지만 이런 강점들을 살려서
팀에 빠르게 기여할 수 있을 것 같습니다.
```

---

### **Q64. 본인의 약점은?**

**면접관**: 본인의 약점이나 개선할 점은?

**답변**:

```
솔직하게 말씀드리면,
알고리즘 문제 풀이가 약점입니다.

교육 과정이 실무 중심이다 보니
코딩테스트 같은 알고리즘 문제는
많이 연습하지 못했습니다.

간단한 정렬이나 탐색은 구현할 수 있지만,
복잡한 DP나 그래프 알고리즘은
아직 익숙하지 않습니다.

하지만 이 부분은 개선하고 있습니다.

최근에 백준이랑 프로그래머스에서
하루에 1-2문제씩 풀면서 실력을 쌓고 있고,
기본적인 자료구조는 확실히 이해하려고
직접 구현도 해봤습니다.

또 하나는 대규모 트래픽 경험이 없다는 점입니다.

BizSync는 소규모 프로젝트라서
동시 접속자가 많지 않았는데,
실무에서는 성능 최적화나
대용량 데이터 처리가 중요하잖아요.

이 부분도 공부하고 있습니다.

캐싱 전략, DB 인덱싱, 쿼리 최적화 같은
성능 관련 서적을 읽고 있고,
나중에 실무에서 부하 테스트나
모니터링 툴 같은 것도 배워보고 싶습니다.

약점을 인지하고 있고
개선하려고 노력 중이라는 점,
그리고 부족한 부분을 빠르게 배울 수 있다는
자신감은 있습니다.
```

---

### **Q65. 마지막으로 하고 싶은 말**

**면접관**: 마지막으로 하고 싶은 말씀 있으신가요?

**답변**:

```
면접 기회 주셔서 감사합니다.

오늘 면접 준비하면서
귀사의 기술 블로그와 채용 공고를 보니까,
성장하는 개발자를 중요하게 생각하시는 것 같아서
더욱 지원하고 싶다는 생각이 들었습니다.

저는 비록 신입이고 전공자는 아니지만,
몇 가지 확실한 강점이 있습니다.

첫째, 이전 경력에서 쌓은
커뮤니케이션 능력과 협업 경험입니다.

현장에서 8년간 다양한 직군과 일하면서
의사소통의 중요성을 체감했고,
이게 개발팀에서도 큰 자산이 될 거라 생각합니다.

둘째, 문제를 끝까지 해결하는 끈기입니다.

BizSync 프로젝트 중에
WebSocket 재연결 이슈로
3일 동안 고생했던 적이 있는데,
공식 문서, Stack Overflow, GitHub Issue까지
다 뒤져서 결국 해결했습니다.

이런 태도로 실무에서도 맡은 일을
책임감 있게 완수하겠습니다.

셋째, 빠르게 배우고 성장하겠다는 의지입니다.

이미 6개월 만에
Java, Spring, React, Docker, AWS까지 익혔고,
입사 후에도 귀사에서 사용하는 기술 스택을
빠르게 습득해서 기여하겠습니다.

좋은 기회 주신다면
열심히 배우고 성장하면서
팀에 꼭 필요한 개발자가 되겠습니다.

감사합니다!
```

---

**현재 진행: 65/120**

잠시 쉬었다가 나머지 55개 계속 진행할까요? 아니면 여기서 마무리하고 실전 연습으로 넘어갈까요?