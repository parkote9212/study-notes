# [Spring Security 1/5] 기초 개념과 아키텍처

🏷️기술 카테고리: Security, Spring
💡핵심키워드: #AOP, #디자인패턴, #아키텍처
💼 면접 빈출도: 최상
⚖️ 의사결정(A vs B): No
날짜: 2026년 1월 16일 오후 8:23
📅 다음 복습일: 2026년 1월 21일

# 1. Abstract: 핵심 요약

> **Spring Security**는 Spring 기반 애플리케이션의 인증(Authentication)과 인가(Authorization)를 담당하는 강력한 보안 프레임워크입니다. **서블릿 필터 체인**을 기반으로 동작하며, 선언적 방식으로 보안 정책을 설정할 수 있습니다.
> 

**핵심 원칙**:

- 인증: "당신은 누구인가?" (로그인)
- 인가: "당신은 이 자원에 접근할 권한이 있는가?" (권한 검증)
- 필터 체인: 요청이 컨트롤러에 도달하기 전에 보안 검증

---

# 2. Technical Deep Dive: Spring Security 아키텍처

## 2.1 Spring Security의 핵심 구조

```
[HTTP Request]
    ↓
[Servlet Filter Chain]
    ↓
[DelegatingFilterProxy] ← Spring Security 진입점
    ↓
[FilterChainProxy]
    ↓
[Security Filter Chain]
    ├─ SecurityContextPersistenceFilter
    ├─ UsernamePasswordAuthenticationFilter
    ├─ ExceptionTranslationFilter
    └─ FilterSecurityInterceptor
    ↓
[DispatcherServlet] → Controller
```

### 주요 컴포넌트

**1. SecurityContext**

- 현재 인증된 사용자 정보를 저장하는 컨텍스트
- ThreadLocal에 저장되어 같은 스레드 내에서 어디서든 접근 가능

```java
// 현재 인증 정보 가져오기
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName();
```

**2. Authentication**

- 인증 정보를 담는 인터페이스
- Principal(주체), Credentials(비밀번호), Authorities(권한) 포함

```java
public interface Authentication extends Principal {
    Collection<? extends GrantedAuthority> getAuthorities();
    Object getCredentials();  // 보통 비밀번호
    Object getPrincipal();    // 보통 사용자 정보
    boolean isAuthenticated();
}
```

**3. AuthenticationManager**

- 인증을 처리하는 핵심 인터페이스
- 일반적으로 ProviderManager가 구현체로 사용됨

```java
public interface AuthenticationManager {
    Authentication authenticate(Authentication authentication)
        throws AuthenticationException;
}
```

**4. UserDetailsService**

- 사용자 정보를 DB에서 조회하는 인터페이스
- Spring Security가 사용자를 인증할 때 호출

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username)
        throws UsernameNotFoundException;
}
```

---

## 2.2 필터 체인 동작 순서

### 1. SecurityContextPersistenceFilter

- SecurityContext를 로드하고 저장
- 요청 시작 시 SecurityContext를 ThreadLocal에 설정
- 요청 종료 시 SecurityContext 정리

### 2. UsernamePasswordAuthenticationFilter

- `/login` 엔드포인트에서 POST 요청 처리
- username과 password를 추출하여 인증 시도

```java
// 내부 동작
1. HTTP 요청에서 username, password 추출
2. UsernamePasswordAuthenticationToken 생성
3. AuthenticationManager.authenticate() 호출
4. 성공 시 SecurityContext에 Authentication 저장
```

### 3. ExceptionTranslationFilter

- 인증/인가 예외를 처리
- AuthenticationException → 로그인 페이지로 리다이렉트
- AccessDeniedException → 403 Forbidden 응답

### 4. FilterSecurityInterceptor

- 최종 권한 검증 단계
- URL 패턴별로 필요한 권한 확인

```java
// SecurityConfig에서 설정한 규칙 적용
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/user/**").hasRole("USER")
    .anyRequest().authenticated()
)
```

---

# 3. 핵심 개념 이해하기

## 3.1 인증 (Authentication)

**정의**: 사용자가 주장하는 신원이 맞는지 확인하는 과정

**일반적인 인증 방식**:

| 방식 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| **폼 로그인** | ID/PW 입력 후 세션 생성 | 구현 단순 | 서버 메모리 사용, 확장성 낮음 |
| **JWT** | 토큰 기반 Stateless 인증 | 확장성 높음, RESTful | 토큰 관리 필요 |
| **OAuth 2.0** | 제3자 인증 (구글, 카카오) | 사용자 편의성 | 외부 의존성 |

---

## 3.2 인가 (Authorization)

**정의**: 인증된 사용자가 특정 자원에 접근할 권한이 있는지 확인하는 과정

**권한 체계**:

```java
// Role 기반 (역할)
.hasRole("ADMIN")         // ROLE_ADMIN 권한 필요
.hasAnyRole("ADMIN", "MANAGER")  // 둘 중 하나

// Authority 기반 (세밀한 권한)
.hasAuthority("READ_PRIVILEGE")
.hasAuthority("WRITE_PRIVILEGE")

// SpEL 표현식
.access("hasRole('ADMIN') and hasIpAddress('192.168.1.0/24')")
```

**권한 계층 구조**:

```java
@Bean
public RoleHierarchy roleHierarchy() {
    RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
    hierarchy.setHierarchy(
        "ROLE_ADMIN > ROLE_MANAGER\n" +
        "ROLE_MANAGER > ROLE_USER"
    );
    return hierarchy;
}
// ADMIN은 자동으로 MANAGER, USER 권한도 가짐
```

---

## 3.3 SecurityContext와 ThreadLocal

**왜 ThreadLocal인가?**

```java
// 동일 스레드 내에서 어디서든 접근 가능
@GetMapping("/user/profile")
public String getProfile() {
    Authentication auth = SecurityContextHolder
        .getContext()
        .getAuthentication();
    
    String username = auth.getName();
    // DB 조회 없이 현재 사용자 정보 획득
}
```

**주의사항**:

- 비동기 처리 시 SecurityContext 전파 필요
- `@Async` 사용 시 `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL` 설정

---

# 4. 기본 설정 예제

## 4.1 최소 설정

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) 
        throws Exception {
        
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults());
        
        return [http.build](http://http.build)();
    }
}
```

## 4.2 UserDetailsService 구현

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username)
        throws UsernameNotFoundException {
        
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> 
                new UsernameNotFoundException("User not found"));
        
        return [org.springframework.security](http://org.springframework.security).core.userdetails.User
            .withUsername(user.getUsername())
            .password(user.getPassword())
            .roles(user.getRole())
            .build();
    }
}
```

---

# 5. Interview Readiness: 면접 대비

## ▶ Q1: Spring Security는 어떻게 동작하나요?

**A**: Spring Security는 서블릿 필터 체인을 기반으로 동작합니다. HTTP 요청이 들어오면 DispatcherServlet에 도달하기 전에 여러 보안 필터를 거치게 됩니다. 주요 필터로는 SecurityContextPersistenceFilter(컨텍스트 관리), UsernamePasswordAuthenticationFilter(로그인 처리), FilterSecurityInterceptor(권한 검증) 등이 있습니다. 각 필터는 체인 패턴으로 연결되어 순차적으로 실행되며, 인증 실패 시 ExceptionTranslationFilter가 적절한 응답을 반환합니다.

---

## ▶ Q2: Authentication과 Authorization의 차이는?

**A**: 

- **Authentication(인증)**: "당신은 누구인가?"를 확인하는 과정입니다. 사용자가 제공한 자격증명(ID/PW, 토큰 등)이 유효한지 검증합니다.
- **Authorization(인가)**: "당신은 이 자원에 접근할 권한이 있는가?"를 확인하는 과정입니다. 인증된 사용자가 특정 URL이나 리소스에 접근할 수 있는 권한이 있는지 검증합니다.

예를 들어, 로그인(인증)에 성공했더라도 관리자 페이지에 접근하려면 ADMIN 역할(인가)이 필요합니다.

---

## ▶ Q3: SecurityContext는 왜 ThreadLocal에 저장되나요?

**A**: SecurityContext를 ThreadLocal에 저장하는 이유는 동일한 HTTP 요청을 처리하는 스레드 내에서 어디서든 인증 정보에 접근할 수 있도록 하기 위함입니다. 이를 통해 매번 파라미터로 인증 정보를 전달하지 않아도 되며, 서비스 계층이나 리포지토리에서도 현재 사용자 정보를 쉽게 가져올 수 있습니다. 단, 비동기 처리 시에는 자식 스레드로 SecurityContext가 전파되지 않으므로 MODE_INHERITABLETHREADLOCAL 모드를 사용해야 합니다.

---

## ▶ Q4: PasswordEncoder는 왜 필요한가요?

**A**: 비밀번호를 평문으로 저장하면 DB 유출 시 모든 사용자 계정이 위험에 노출됩니다. PasswordEncoder는 비밀번호를 안전하게 해시화하여 저장하고, 로그인 시 입력된 평문과 저장된 해시를 비교하여 검증합니다. Spring Security는 BCryptPasswordEncoder를 권장하는데, 이는 솔트를 자동으로 생성하고 해싱 속도를 의도적으로 느리게 하여 무차별 대입 공격을 방어합니다.

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

---

## ▶ Q5: 폼 로그인과 JWT 방식의 차이는?

**A**:

| 구분 | 폼 로그인 (세션 기반) | JWT (토큰 기반) |
| --- | --- | --- |
| **상태 관리** | Stateful (서버에 세션 저장) | Stateless (서버에 저장 안 함) |
| **확장성** | 낮음 (세션 동기화 필요) | 높음 (수평 확장 쉬움) |
| **보안** | CSRF 공격 취약 | XSS 공격 취약 |
| **사용 사례** | SSR 웹 애플리케이션 | REST API, SPA |

---

## 🔑 핵심 체크리스트

- [ ]  Spring Security는 필터 체인 기반으로 동작
- [ ]  Authentication(인증) vs Authorization(인가) 개념 구분
- [ ]  SecurityContext는 ThreadLocal에 저장
- [ ]  UserDetailsService로 사용자 정보 조회
- [ ]  PasswordEncoder로 비밀번호 암호화 필수
- [ ]  폼 로그인은 Stateful, JWT는 Stateless

---

**작성일**: 2026-01-16  

**면접 빈출도**: ⭐⭐⭐⭐⭐ (최상)