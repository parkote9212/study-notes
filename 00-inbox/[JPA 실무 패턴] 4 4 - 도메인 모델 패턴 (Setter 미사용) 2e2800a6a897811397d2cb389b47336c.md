# [JPA 실무 패턴] 4/4 - 도메인 모델 패턴 (Setter 미사용)

🏷️기술 카테고리: Design Pattern, JPA
💡핵심키워드: #JPA, #도메인주도설계, #캡슐화, #클린코드
💼 면접 빈출도: 상
⚖️ 의사결정(A vs B): Yes
날짜: 2026년 1월 8일 오후 11:56
📅 다음 복습일: 2026년 1월 21일

## 🧐 왜 Setter를 쓰면 안 되는가?

엔티티에 `Setter`를 금지하고 **의미 있는 비즈니스 메서드(Domain Method)**를 사용하는 것은 Modern JPA의 표준 관례입니다.

### 1. 수정의 "의도(Intent)"를 명확히 하기 위해서

`Setter`는 단순히 값을 변경할 뿐, **"왜"** 변경하는지 설명하지 못합니다.

```java
// ❌ Setter 방식
ticket.setStatus("EXP");
// → 기간이 지나서 만료? 관리자가 강제 정지? 알 수 없음

// ✅ 메서드 방식
ticket.expire(); // 또는 ticket.suspendByAdmin();
// → 코드 자체가 비즈니스 언어로 읽힐
```

### 2. 객체의 무결성(Integrity)과 캡슐화

`Setter`는 외부에서 아무나 필드 값을 바꿀 수 있게 "무방비 상태"로 객체를 노출시킵니다.

```java
// ❌ Setter를 쓸 경우 (위험)
int current = ticket.getRemainingCount();
ticket.setRemainingCount(current - 1); 
// 실수로 -100을 넣어도 막을 방법이 없음

// ✅ 비즈니스 메서드를 쓸 경우 (안전)
public void use() {
    if (this.remainingCount <= 0) {
        throw new IllegalStateException("잔여 횟수가 없습니다.");
    }
    this.remainingCount--;
    
    if (this.remainingCount == 0) {
        this.status = TicketStatus.EXHAUSTED;
    }
}
```

### 3. "도메인 모델 패턴"의 구현

데이터와 로직이 한곳에 모여 있는 것을 **도메인 모델 패턴**이라고 합니다.

**과거 방식:**

- 엔티티에 데이터만 담고(Getter/Setter)
- 서비스 클래스에서 모든 계산 로직 처리
- → 서비스 코드가 수천 줄, 중복 코드 발생

**현대 방식 (Rich Domain Model):**

- 엔티티가 스스로의 상태를 변경
- 서비스는 엔티티에게 일을 시키기만 함 (Thin Service)
- → 비즈니스 로직이 엔티티 단위로 격리, 단위 테스트 용이

---

## 💻 실무 적용 예시

### [Before] 서비스에 로직 (지양)

```java
@Transactional
public void useTicket(Long id) {
    MemberTicket ticket = repository.findById(id).orElseThrow();
    
    // ❌ 서비스가 엔티티의 내부 사정을 너무 많이 알음 (결합도 상승)
    if (ticket.getRemainingCount() <= 0) {
        throw new IllegalStateException("잔여 횟수 부족");
    }
    ticket.setRemainingCount(ticket.getRemainingCount() - 1);
}
```

### [After] 엔티티에 로직 (권장)

```java
// MemberTicket Entity 내부
public void use() {
    if (this.remainingCount <= 0) {
        throw new IllegalStateException("잔여 횟수가 없습니다.");
    }
    this.remainingCount--; // ✅ 스스로의 상태를 스스로 변경
}

// Service 내부
@Transactional
public void useTicket(Long id) {
    MemberTicket ticket = repository.findById(id).orElseThrow();
    ticket.use(); // ✅ 서비스는 "사용해라"라고 명령만 내림
}
```

---

## ⚠️ 주의: 엔티티에 넣으면 안 되는 로직

모든 것을 엔티티에 넣을 수는 없습니다. 아래는 **Service**에 두어야 합니다:

1. **Repository 호출:** 엔티티는 다른 엔티티를 조회하기 위해 Repository를 직접 부를 수 없음
2. **외부 API 호출:** 엔티티 내부에서 이메일 발송이나 결제 API 호출하면 안 됨
3. **여러 엔티티의 복합 조율:** 여러 도메인이 섮여서 순서를 제어해야 하는 로직은 서비스의 역할

---

## 💡 테크 리드의 최종 가이드

1. **Lombok `@Setter`는 엔티티에서 절대 쓰지 마세요.**
2. 수정이 필요한 필드는 반드시 **비즈니스 이름(Verb)**이 담긴 메서드를 만드세요.
3. 그 메서드 안에서 **값의 검증(Validation)** 로직을 함께 넣으세요.

이렇게 하면 서비스 계층의 코드가 매우 얘아지고(Thin Service), 엔티티가 스스로를 보호하는 견고한 시스템이 됩니다.

---

## 💡 면접 대비 핵심 포인트

**질문:** "엔티티에서 Setter 대신 비즈니스 메서드를 사용하는 이유가 무엇인가요?"

**모범 답변:**

"첫째, 변경의 의도를 명확히 하여 코드의 가독성을 높이기 위해서입니다. 둘째, 객체 내부에서 상태 변경 규칙을 강제함으로써 데이터 무결성을 유지하고 캡슐화를 지킬 수 있기 때문입니다. 마지막으로, 로직이 엔티티 내부에 응집되도록 하여 유지보수가 쉬운 도메인 모델 패턴을 지향하기 위해서입니다."

---

## 🔄 서비스 vs 엔티티 비교

| 항목 | 트랜잭션 스크립트 (Service 중심) | 도메인 모델 (Entity 중심) |
| --- | --- | --- |
| 엔티티 역할 | 단순 데이터 바구니(DTO) | 비즈니스 로직 포함 |
| 서비스 역할 | 모든 비즈니스 로직 수행 (Fat Service) | 엔티티에 명령만 전달 (Thin Service) |
| 단위 테스트 | 어려움 | 쉬움 |
| 코드 중복 | 발생 하기 쉬움 | 거의 없음 |