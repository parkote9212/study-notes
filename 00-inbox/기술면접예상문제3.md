
### **Q20. 양방향 연관관계**

**면접관**: 양방향 연관관계에서 주의할 점은 무엇인가요?

**답변**:

```
양방향 연관관계는 
양쪽에서 서로 참조하는 겁니다.

예시:

@Entity
public class Project {
    @OneToMany(mappedBy = "project")
    private List<KanbanColumn> columns = new ArrayList<>();
}

@Entity
public class KanbanColumn {
    @ManyToOne
    @JoinColumn(name = "project_id")
    private Project project;
}

주의사항:

1. 연관관계 주인 설정

mappedBy = "project"
→ KanbanColumn의 project 필드가 주인
→ 외래키는 kanban_column.project_id에

주인만 외래키를 관리합니다.

2. 양쪽 모두 설정

// 잘못된 코드
project.getColumns().add(column);
// project만 설정하고 column은 null

// DB에 반영 안 됨!
// 연관관계 주인이 아니라서

올바른 방법:

column.setProject(project);  // 주인 설정
project.getColumns().add(column);  // 편의상

BizSync 편의 메서드:

@Entity
public class Project {
    
    public void addColumn(KanbanColumn column) {
        columns.add(column);
        column.setProject(this);  // 양쪽 설정!
    }
    
    public void removeColumn(KanbanColumn column) {
        columns.remove(column);
        column.setProject(null);
    }
}

사용:

Project project = new Project();
KanbanColumn column = new KanbanColumn();

project.addColumn(column);  // 한 번만 호출
projectRepository.save(project);

3. toString() 주의

@Entity
public class Project {
    @OneToMany(mappedBy = "project")
    private List<KanbanColumn> columns;
    
    @Override
    public String toString() {
        return "Project: " + name + ", columns: " + columns;
        // columns.toString() 호출
        // → KanbanColumn.toString() 호출
        // → project.toString() 호출
        // → StackOverflowError!
    }
}

해결:

@Override
public String toString() {
    return "Project: " + name + ", columnCount: " + columns.size();
    // 컬렉션 내용 출력 안 함
}

또는 Lombok:

@ToString(exclude = "columns")
@Entity
public class Project {
    // ...
}

4. JSON 무한 순환

@RestController
public class ProjectController {
    
    @GetMapping("/api/projects/{id}")
    public Project getProject(@PathVariable Long id) {
        return projectService.findById(id);
        // JSON 직렬화 시 무한 루프!
    }
}

해결 1: DTO 사용

public class ProjectDTO {
    private Long projectId;
    private String name;
    private List<ColumnDTO> columns;
    
    public static ProjectDTO from(Project project) {
        return new ProjectDTO(
            project.getId(),
            project.getName(),
            project.getColumns().stream()
                .map(ColumnDTO::from)
                .toList()
        );
    }
}

해결 2: @JsonIgnore

@Entity
public class KanbanColumn {
    @ManyToOne
    @JsonIgnore  // JSON에서 제외
    private Project project;
}

BizSync는 모든 API에서 DTO 사용:

@GetMapping("/api/projects/{id}/board")
public ProjectBoardDTO getBoard(@PathVariable Long id) {
    Project project = projectService.findById(id);
    return ProjectBoardDTO.from(project);
    // Entity → DTO 변환
}

정리:
- mappedBy로 주인 지정
- 양쪽 모두 설정 (편의 메서드)
- toString, JSON 무한 참조 주의
- 실무: DTO 필수
```

---

### **Q21. JPQL vs QueryDSL**

**면접관**: JPQL과 QueryDSL의 차이를 설명해주세요.

**답변**:

```
JPQL은 문자열로 쿼리를 작성하고
QueryDSL은 Java 코드로 작성합니다.

JPQL:

@Query("SELECT t FROM Task t " +
       "WHERE t.deadline < :date " +
       "AND t.worker.userId = :userId")
List<Task> findOverdueTasks(
    @Param("date") LocalDate date,
    @Param("userId") Long userId
);

장점: 간단, 익숙함
단점: 
- 문자열이라 오타 → 런타임 에러
- 동적 쿼리 어려움
- IDE 지원 약함

QueryDSL:

QTask task = QTask.task;
QUser user = QUser.user;

List<Task> tasks = queryFactory
    .selectFrom(task)
    .join(task.worker, user)
    .where(
        task.deadline.lt(date),
        user.userId.eq(userId)
    )
    .fetch();

장점:
- 컴파일 타임 체크 (오타 방지)
- 동적 쿼리 쉬움
- IDE 자동완성

BizSync는 복잡한 조회는 MyBatis 사용:

복잡한 조인:

<select id="selectProjectBoard" resultMap="ProjectBoardMap">
    SELECT p.*, c.*, t.*, u.*
    FROM project p
    LEFT JOIN kanban_column c ON p.project_id = c.project_id
    LEFT JOIN task t ON c.column_id = t.column_id
    LEFT JOIN users u ON t.worker_id = u.user_id
    WHERE p.project_id = #{projectId}
    ORDER BY c.sequence, t.sequence
</select>

이런 건 MyBatis가 더 직관적입니다.

동적 쿼리 비교:

JPQL (어려움):

String jpql = "SELECT t FROM Task t WHERE 1=1";
if (workerId != null) {
    jpql += " AND t.worker.userId = :workerId";
}
if (deadline != null) {
    jpql += " AND t.deadline < :deadline";
}
// 문자열 조합... 지저분

QueryDSL (쉬움):

BooleanBuilder builder = new BooleanBuilder();

if (workerId != null) {
    builder.and(task.worker.userId.eq(workerId));
}
if (deadline != null) {
    builder.and(task.deadline.lt(deadline));
}

List<Task> tasks = queryFactory
    .selectFrom(task)
    .where(builder)
    .fetch();

Spring Data JPA 기본 메서드로 충분한 경우:

// 이런 간단한 건 메서드명으로
List<Task> findByWorkerUserIdAndDeadlineBefore(
    Long userId, 
    LocalDate deadline
);

정리:
- 간단한 조회: Spring Data JPA 메서드명
- 중간 복잡도: JPQL
- 복잡 + 동적 쿼리: QueryDSL
- 매우 복잡한 조인: MyBatis
```

---

## **Part 4: Database 기초 (15개)**

### **Q22. Primary Key vs Foreign Key**

**면접관**: PK와 FK의 역할을 설명해주세요.

**답변**:

```
Primary Key(기본키)는 
테이블에서 각 행을 고유하게 식별합니다.

Foreign Key(외래키)는 
다른 테이블의 PK를 참조합니다.

BizSync 예시:

-- users 테이블
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,  -- PK
    email VARCHAR(50) UNIQUE,
    name VARCHAR(20)
);

-- project_member 테이블
CREATE TABLE project_member (
    id BIGINT PRIMARY KEY,
    project_id BIGINT,  -- FK
    user_id BIGINT,     -- FK
    role VARCHAR(20),
    
    FOREIGN KEY (project_id) REFERENCES project(project_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

PK의 특징:

1. NOT NULL
2. UNIQUE
3. 테이블당 1개만
4. 자동으로 인덱스 생성

PK 선택 기준:

-- 자연키 (비추천)
email VARCHAR(50) PRIMARY KEY

문제: email 바뀌면?

-- 대리키 (추천)
user_id BIGINT AUTO_INCREMENT PRIMARY KEY

장점: 불변, 짧음, 빠름

FK의 역할:

1. 참조 무결성 보장

INSERT INTO project_member (user_id) VALUES (999);
-- 에러! users 테이블에 999 없음

2. CASCADE 옵션

FOREIGN KEY (project_id) 
    REFERENCES project(project_id)
    ON DELETE CASCADE

프로젝트 삭제하면 멤버도 자동 삭제

3. 연관관계 명시

BizSync의 FK 전략:

@Entity
public class ProjectMember {
    @ManyToOne
    @JoinColumn(name = "user_id")  // FK
    private User user;
    
    @ManyToOne
    @JoinColumn(name = "project_id")  // FK
    private Project project;
}

DB에서 FK 제약조건 확인:

SHOW CREATE TABLE project_member;

복합키 (사용 안 함):

-- 안 좋은 예
CREATE TABLE project_member (
    project_id BIGINT,
    user_id BIGINT,
    PRIMARY KEY (project_id, user_id)
);

BizSync는 단일 PK 사용:

CREATE TABLE project_member (
    id BIGINT PRIMARY KEY,  -- 단일 PK
    project_id BIGINT,
    user_id BIGINT,
    UNIQUE (project_id, user_id)  -- 복합 UNIQUE
);

정리:
- PK: 행 식별, AUTO_INCREMENT
- FK: 참조 무결성, JOIN
- 대리키 선호
```

---

### **Q23. 정규화**

**면접관**: 데이터베이스 정규화가 무엇인가요?

**답변**:

```
정규화는 중복을 제거하고 
데이터 무결성을 보장하는 과정입니다.

비정규화 예시 (나쁜 설계):

-- 주문 테이블
order_id | customer_name | customer_email | product_name | price
1        | 홍길동        | hong@...      | 노트북       | 1000
2        | 홍길동        | hong@...      | 마우스       | 50
3        | 김철수        | kim@...       | 노트북       | 1000

문제:
1. 홍길동 이메일 변경 → 여러 행 수정
2. 중복 데이터 (홍길동, 노트북)
3. 공간 낭비

제1정규형 (1NF):
- 원자값만 (쪼갤 수 없는 값)

-- 잘못됨
tags VARCHAR(100)  -- "Java, Spring, JPA"

-- 올바름
tag_id | task_id | tag_name
1      | 1       | Java
2      | 1       | Spring

제2정규형 (2NF):
- 부분 함수 종속 제거
- PK 일부만으로 다른 컬럼 결정 X

제3정규형 (3NF):
- 이행적 함수 종속 제거
- A→B, B→C면 A→C 제거

BizSync의 정규화:

-- 정규화 전 (나쁨)
task (
    task_id,
    title,
    worker_id,
    worker_name,      -- 중복!
    worker_email,     -- 중복!
    project_id,
    project_name      -- 중복!
)

-- 정규화 후 (좋음)
task (
    task_id,
    title,
    worker_id,    -- FK
    project_id    -- FK
)

users (
    user_id,
    name,
    email
)

project (
    project_id,
    name
)

정규화의 장점:

1. 중복 제거
2. 업데이트 이상 방지
3. 저장 공간 절약

단점:

1. JOIN 많아짐
2. 조회 성능 저하

실무에서는?

읽기가 많은 곳은 의도적 비정규화:

-- 통계 테이블 (비정규화 OK)
daily_stats (
    date,
    project_id,
    project_name,     -- 중복이지만 OK
    task_count,
    completed_count
)

매번 JOIN하지 않고 
한 번에 조회 가능

BizSync의 선택:

- 트랜잭션 데이터: 정규화 (3NF)
- 통계/보고서: 비정규화
- 자주 JOIN하는 데이터: 캐싱

정리:
- 정규화: 중복 제거, 무결성
- 3NF까지가 일반적
- 성능 위해 선택적 비정규화
```

---

### **Q24. 트랜잭션 ACID**

**면접관**: ACID 속성을 설명해주세요.

**답변**:

```
ACID는 트랜잭션의 4가지 속성입니다.

1. Atomicity (원자성)
   - All or Nothing
   - 전부 성공 또는 전부 실패

예시:

BEGIN;
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;
COMMIT;

중간에 실패하면 둘 다 ROLLBACK

BizSync 예시:

@Transactional
public void approveDocument(Long docId) {
    doc.approve();              // 1. 문서 승인
    line.setStatus(APPROVED);   // 2. 라인 상태 변경
    notification.send();        // 3. 알림 전송
    
    // 3에서 실패하면 1,2도 ROLLBACK
}

2. Consistency (일관성)
   - 트랜잭션 전후 데이터 무결성 유지

예시:

-- 체크 제약조건
ALTER TABLE task 
ADD CONSTRAINT check_sequence 
CHECK (sequence >= 0);

INSERT INTO task (sequence) VALUES (-1);
-- 에러! 일관성 위반

3. Isolation (격리성)
   - 동시 실행 트랜잭션 간 독립성

격리 수준:

READ UNCOMMITTED: Dirty Read 가능
READ COMMITTED:   Dirty Read 방지
REPEATABLE READ:  Non-Repeatable Read 방지 (MariaDB 기본)
SERIALIZABLE:     Phantom Read 방지

BizSync 예시:

-- Transaction 1
BEGIN;
SELECT used_budget FROM project WHERE id = 1;  -- 500
-- 여기서 멈춤

-- Transaction 2  
UPDATE project SET used_budget = 600 WHERE id = 1;
COMMIT;

-- Transaction 1 계속
SELECT used_budget FROM project WHERE id = 1;
-- REPEATABLE READ: 500 (같은 값)
-- READ COMMITTED: 600 (바뀐 값)

4. Durability (지속성)
   - COMMIT되면 영구 저장
   - 시스템 장애에도 보존

COMMIT;  -- 디스크에 기록
-- 이후 정전되어도 데이터 남음

BizSync의 트랜잭션:

@Transactional
public void createProject(ProjectDTO dto) {
    // Atomicity: 전부 성공 or 실패
    Project project = projectRepository.save(...);
    
    // Consistency: FK 제약조건 체크
    columnRepository.save(new Column(project.getId()));
    
    // Isolation: 다른 트랜잭션과 분리
    // Durability: COMMIT 시 영구 저장
}

주의사항:

@Transactional
public void process() {
    // 1. DB 작업
    userRepository.save(user);
    
    // 2. 외부 API 호출
    emailService.send();  // 실패 가능!
    
    // 실패하면 1도 ROLLBACK
}

외부 API는 트랜잭션 밖에서:

public void process() {
    User user = createUser();  // @Transactional
    
    try {
        emailService.send();  // 트랜잭션 외부
    } catch (Exception e) {
        // 이메일 실패해도 user는 저장됨
    }
}

정리:
- Atomicity: 원자적 실행
- Consistency: 무결성 유지
- Isolation: 격리 수준
- Durability: 영구 저장
```

---

### **Q25. 인덱스 타입**

**면접관**: B-Tree 외에 다른 인덱스는 어떤 게 있나요?

**답변**:

```
인덱스 타입:

1. B-Tree (가장 일반적)
   - 범위 검색 유리
   - ORDER BY 빠름

2. Hash
   - 등호(=) 검색만 가능
   - 범위 검색 불가

3. Full-Text
   - 텍스트 검색용
   - LIKE 대신 사용

4. Spatial
   - 지리 데이터
   - 좌표 검색

BizSync는 주로 B-Tree:

CREATE INDEX idx_task_deadline ON task(deadline);
-- 기본이 B-Tree

사용 예시:

-- B-Tree 인덱스
WHERE deadline BETWEEN '2025-01-01' AND '2025-12-31'  -- 빠름
WHERE deadline > '2025-01-01'                         -- 빠름
ORDER BY deadline                                     -- 빠름

-- Hash 인덱스 (MariaDB는 지원 안 함)
CREATE INDEX idx_email USING HASH ON users(email);

WHERE email = 'user@example.com'  -- 빠름
WHERE email LIKE 'user%'          -- 안 됨!

Full-Text 인덱스:

CREATE FULLTEXT INDEX idx_title ON task(title);

-- 사용
SELECT * FROM task 
WHERE MATCH(title) AGAINST('프로젝트 관리');

일반 LIKE보다 훨씬 빠름:

-- 느림
WHERE title LIKE '%관리%'

-- 빠름 (Full-Text)
WHERE MATCH(title) AGAINST('관리')

BizSync에서 고려했던 부분:

검색 기능:

-- 처음: LIKE 사용 (느림)
SELECT * FROM task 
WHERE title LIKE '%검색어%' 
   OR content LIKE '%검색어%';

-- 개선안: Full-Text 인덱스
CREATE FULLTEXT INDEX idx_search 
ON task(title, content);

SELECT * FROM task
WHERE MATCH(title, content) AGAINST('검색어');

복합 인덱스:

CREATE INDEX idx_task_column_seq 
ON task(column_id, sequence);

-- 둘 다 사용
WHERE column_id = 1 AND sequence < 10  -- 빠름

-- 앞쪽만 사용
WHERE column_id = 1  -- 빠름

-- 뒤쪽만 사용  
WHERE sequence < 10  -- 인덱스 안 탐!

인덱스 선택 기준:

- 등호(=) 검색 많음: B-Tree
- 범위 검색: B-Tree
- 텍스트 검색: Full-Text
- 지도 좌표: Spatial

정리:
- 기본: B-Tree
- 텍스트 검색: Full-Text
- 복합 인덱스: 컬럼 순서 중요
```

---

**현재 진행: 25/120**

계속 진행할까요? 속도가 괜찮으신가요?