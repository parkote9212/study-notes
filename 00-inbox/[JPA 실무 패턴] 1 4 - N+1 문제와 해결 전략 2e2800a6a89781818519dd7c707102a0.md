# [JPA 실무 패턴] 1/4 - N+1 문제와 해결 전략

🏷️기술 카테고리: DataBase, JPA
💡핵심키워드: #N+1, #성능최적화, #쿼리최적화, #패치조인
💼 면접 빈출도: 최상
⚖️ 의사결정(A vs B): No
날짜: 2026년 1월 8일 오후 11:52
📅 다음 복습일: 2026년 1월 21일

## 🧐 N+1 문제란?

N+1 문제는 1개의 쿼리로 리스트를 가져왔을 때, 해당 리스트에 포함된 **N개의 연관 엔티티**를 가져오기 위해 **N번의 추가 쿼리**가 나가는 현상입니다. 총 **1 + N**번의 쿼리가 실행되어 성능 저하를 일으킵니다.

### 발생 원인

JPA의 기본 전략인 **지연 로딩(Lazy Loading, FetchType.LAZY)** 때문에 발생합니다.

- JPA는 Entity의 연관 관계를 기본적으로 **프록시(Proxy) 객체**로 감싸둡니다
- 1번 쿼리 실행 시, 연관 객체는 프록시 상태로 남아있습니다
- 반복문에서 프록시에 최초로 접근하는 순간, JPA는 실제 데이터를 로드하기 위해 **추가적인 DB 쿼리(N번)**를 실행합니다

### 예시

```sql
-- 1번 쿼리: 게시글 100개 조회
SELECT * FROM Post WHERE ...

-- N번 쿼리: 각 게시글의 작성자 조회 (100번 실행)
SELECT * FROM Member WHERE id = ?
SELECT * FROM Member WHERE id = ?
...(100번 반복)
```

총 **101번의 쿼리**가 실행되어 대량 트래픽 환경에서 DB 부하 폭증의 주범이 됩니다.

---

## 🛠️ 해결 방법

### 1. Fetch Join (가장 강력한 방법)

JPQL을 사용하여 명시적으로 **JOIN**을 수행하고, 연관 엔티티를 한 번에 가져옵니다.

```java
@Query("""
    SELECT p 
    FROM Post p 
    JOIN FETCH p.member 
    WHERE p.title LIKE :titleKeyword
""")
List<Post> findAllWithMemberByTitle(@Param("titleKeyword") String titleKeyword);
```

**장점:** 가장 직관적이고 강력하게 N+1 문제 해결

**단점:** `@OneToMany` 관계에서 데이터 중복(Cartesian Product) 발생, 페이징 복잡

### 2. Entity Graph (선언적 방식)

`@EntityGraph` 애너테이션으로 선언적으로 연관 엔티티 로드를 지정합니다.

```java
@EntityGraph(attributePaths = {"member"})
List<Post> findAll();
```

**장점:** 코드 간결, 쿼리 수정 없이 로딩 전략 유연 변경

**단점:** 다중 컬렉션 Fetch 불가

### 3. @BatchSize (차선책)

N번의 쿼리를 M번의 쿼리로 최적화합니다.

```java
@BatchSize(size = 10)
@OneToMany(mappedBy = "post")
private List<Comment> comments;
```

**원리:** N개의 연관 엔티티를 하나씩 조회하는 대신, `IN` 절을 사용하여 한 번에 조회

**예시:** 게시글 100개 / BatchSize = 10 → 10번의 쿼리로 100개 조회 (총 11번)

---

## 🏗️ 해결 전략 가이드

| 상황 | 추천 해결책 | 이유 |
| --- | --- | --- |
| 가장 빈번한 조회 경로 | **Fetch Join** | 성능 최고, `ManyToOne`에 최적 |
| 특정 API에서만 다른 전략 필요 | **Entity Graph** | 선언적 관리, 복잡한 환경 유리 |
| 두 개 이상 `@OneToMany` 동시 로딩 | **@BatchSize** | Fetch Join 한계 극복 |
| 단순 데이터만 필요 | **Projection (Record)** | 불필요한 연관관계 로딩 방지 |

---

## 💡 면접 대비 핵심 포인트

**질문:** "Fetch Join이 N+1의 가장 좋은 해결책인데, Fetch Join을 사용하기 어려운 상황에서는 어떻게 하시겠습니까?"

**모범 답변:**

1. **Fetch Join의 한계 언급:** "`@OneToMany` 관계에서 Fetch Join을 사용하면 데이터 중복이 발생하고, 특히 두 개 이상의 컬렉션을 Fetch Join 하거나 페이징을 적용하기 어렵습니다."
2. **대안 제시:** "이러한 경우 **`@BatchSize`** 설정을 사용합니다. `IN` 쿼리 방식을 통해 N번의 쿼리를 M번으로 줄여서 최적화합니다."
3. **최후의 수단:** "만약 BatchSize마저 사용이 어렵다면, 연관 엔티티를 조회하는 로직을 분리하여 **Service Layer**나 **DAO**에서 별도의 쿼리로 필요한 데이터만 미리 캐싱하거나, 필요한 시점에 명시적으로 가져오도록 코드를 수정해야 합니다."