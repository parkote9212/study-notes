
### **Q39. useEffect**

**면접관**: useEffect가 뭐고 언제 사용하나요?

**답변**:

```
useEffect는 컴포넌트가 렌더링된 후에 
특정 작업을 실행하는 Hook입니다.

주로 세 가지 경우에 씁니다.

첫 번째, 데이터 가져오기입니다.

const KanbanBoard = ({ projectId }) => {
  const [board, setBoard] = useState(null);
  
  useEffect(() => {
    fetchBoard(projectId).then(setBoard);
  }, [projectId]);
  // projectId 바뀔 때마다 실행
};

두 번째, 구독이나 이벤트 리스너 등록입니다.

useEffect(() => {
  const client = new WebSocketClient();
  client.connect();
  
  return () => {
    client.disconnect();  // cleanup
  };
}, []);  // 빈 배열이면 마운트/언마운트 시에만

세 번째, DOM 직접 조작이 필요할 때입니다.

useEffect(() => {
  document.title = `${project.name} - BizSync`;
}, [project.name]);

BizSync에서 실제로 사용한 예를 들면,
WebSocket 연결할 때 이렇게 했습니다.

useEffect(() => {
  const client = new Client({
    brokerURL: WS_URL,
    onConnect: () => {
      client.subscribe(`/topic/projects/${projectId}`, (msg) => {
        if (msg.body === 'BOARD_UPDATE') {
          refreshBoard();
        }
      });
    }
  });
  
  client.activate();
  
  return () => {
    client.deactivate();
  };
}, [projectId]);

의존성 배열이 중요한데요,
projectId가 바뀌면 이전 연결을 끊고 
새로 연결해야 하니까 배열에 넣었습니다.

주의할 점은 무한 루프입니다.

// 나쁨
useEffect(() => {
  setCount(count + 1);  // state 변경
});  // 의존성 배열 없음 → 무한 루프!

// 좋음
useEffect(() => {
  setCount(count + 1);
}, []);  // 한 번만 실행
```

---

### **Q40. Props vs State**

**면접관**: Props와 State의 차이는 뭔가요?

**답변**:

```
Props는 부모에게서 받는 읽기 전용 데이터고,
State는 컴포넌트가 직접 관리하는 변경 가능한 데이터입니다.

Props 예시:

// 부모
<TaskCard task={task} onUpdate={handleUpdate} />

// 자식
const TaskCard = ({ task, onUpdate }) => {
  // task는 읽기만 가능
  // task.title = '변경';  // 이러면 안 됨!
  
  return <div>{task.title}</div>;
};

State 예시:

const TaskCard = ({ task }) => {
  const [isEditing, setIsEditing] = useState(false);
  
  // isEditing은 이 컴포넌트가 관리
  const handleClick = () => {
    setIsEditing(true);
  };
  
  return (
    <div onClick={handleClick}>
      {isEditing ? <input /> : task.title}
    </div>
  );
};

BizSync에서 실제로 사용한 패턴은 이렇습니다.

부모(KanbanBoard)가 전체 보드 데이터를 관리하고,
자식(TaskCard)은 UI 상태만 관리합니다.

// 부모 - 데이터 관리
const KanbanBoard = () => {
  const { board, updateTask } = useKanbanStore();
  
  return (
    <Column>
      {board.tasks.map(task => (
        <TaskCard 
          task={task}           // Props로 전달
          onUpdate={updateTask} // Props로 전달
        />
      ))}
    </Column>
  );
};

// 자식 - UI 상태만 관리
const TaskCard = ({ task, onUpdate }) => {
  const [showMenu, setShowMenu] = useState(false);
  
  return (
    <div>
      {task.title}
      <button onClick={() => setShowMenu(!showMenu)}>
        메뉴
      </button>
    </div>
  );
};

정리하면,
- Props: 부모 → 자식 단방향, 변경 불가
- State: 컴포넌트 내부, 변경 가능
```

---

## **Part 7: Docker 기초 (10개)**

### **Q41. 컨테이너 vs 가상머신**

**면접관**: Docker 컨테이너와 가상머신의 차이는?

**답변**:

```
가상머신은 OS를 통째로 가상화하고,
컨테이너는 프로세스만 격리합니다.

가상머신:
Hardware
→ Host OS
→ Hypervisor
→ Guest OS (전체) ← 무거움
→ App

컨테이너:
Hardware
→ Host OS
→ Docker Engine
→ Container (프로세스만) ← 가벼움
→ App

차이점을 표로 정리하면,

| 항목 | 가상머신 | 컨테이너 |
|------|---------|----------|
| 크기 | GB 단위 | MB 단위 |
| 시작 | 분 단위 | 초 단위 |
| 격리 | OS 수준 | 프로세스 수준 |
| 성능 | 오버헤드 큼 | 거의 Native |

BizSync를 예로 들면,

가상머신이었다면:
- Ubuntu 이미지: 2GB
- Java 설치: 500MB
- 애플리케이션: 100MB
- 총 2.6GB, 시작 1분

Docker 컨테이너:
- JRE 이미지: 180MB
- 애플리케이션: 100MB
- 총 280MB, 시작 5초

실제 배포할 때,
EC2 하나에 가상머신이면 1-2개만 돌리지만
Docker면 10개 이상 돌릴 수 있습니다.

다만 보안 격리 수준은 
가상머신이 더 강력합니다.
그래서 멀티테넌시 환경이면 VM을 쓰는 경우도 있죠.
```

---

### **Q42. Docker Image vs Container**

**면접관**: Image와 Container의 차이는?

**답변**:

```
Image는 실행 파일이고,
Container는 실행 중인 프로세스입니다.

비유하자면,
- Image = 클래스
- Container = 인스턴스

Image 만들기:

docker build -t bizsync-backend .
# Dockerfile을 읽어서 이미지 생성

Image 확인:

docker images
REPOSITORY          TAG       SIZE
bizsync-backend    latest    280MB
bizsync-frontend   latest     40MB

Container 실행:

docker run -d -p 8080:8080 bizsync-backend
# 이미지로부터 컨테이너 생성 및 실행

Container 확인:

docker ps
CONTAINER ID   IMAGE              STATUS
abc123         bizsync-backend   Up 5 minutes

BizSync에서는 하나의 이미지로 
여러 개의 컨테이너를 띄울 수 있습니다.

docker run -d -p 8080:8080 bizsync-backend  # Container 1
docker run -d -p 8081:8080 bizsync-backend  # Container 2
docker run -d -p 8082:8080 bizsync-backend  # Container 3

같은 이미지지만 독립적인 컨테이너 3개입니다.

Image는 읽기 전용이고,
Container에서 변경한 내용은 
해당 Container에만 남습니다.

# Container 안에서 파일 생성
docker exec abc123 touch /tmp/test.txt

# 이 파일은 abc123 컨테이너에만 있음
# 다른 Container나 Image에는 없음

정리하면,
- Image: 불변, 템플릿, 배포 단위
- Container: 가변, 실행 인스턴스
```

---

### **Q43. Dockerfile 명령어**

**면접관**: 주요 Dockerfile 명령어를 설명해주세요.

**답변**:

```
자주 쓰는 명령어는 이 정도입니다.

FROM: 베이스 이미지 지정
FROM eclipse-temurin:21-jre-alpine

WORKDIR: 작업 디렉토리 설정
WORKDIR /app

COPY: 파일 복사
COPY build/libs/*.jar app.jar

RUN: 빌드 시 명령 실행
RUN npm install

CMD: 컨테이너 실행 시 기본 명령
CMD ["java", "-jar", "app.jar"]

ENTRYPOINT: 컨테이너를 실행 파일처럼
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]

EXPOSE: 포트 문서화 (실제 열리진 않음)
EXPOSE 8080

ENV: 환경 변수 설정
ENV SPRING_PROFILES_ACTIVE=prod

BizSync Backend Dockerfile을 보면:

# 빌드 스테이지
FROM eclipse-temurin:21-jdk-alpine AS build
WORKDIR /app
COPY . .
RUN ./gradlew bootJar

# 실행 스테이지
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY --from=build /app/build/libs/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]

CMD vs ENTRYPOINT 차이는,

CMD만 쓰면:
docker run my-image some-command
→ CMD 전체가 덮어써짐

ENTRYPOINT + CMD:
docker run my-image some-arg
→ ENTRYPOINT는 유지되고 CMD만 바뀜

예를 들어,
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]

docker run my-image other.jar
→ java -jar other.jar 실행

레이어 캐싱 최적화:
자주 안 바뀌는 것 먼저 COPY해야 합니다.

# 나쁨
COPY . .
RUN npm install

# 좋음
COPY package*.json .
RUN npm install  # 캐시됨
COPY . .         # 소스만 바뀜
```

---

### **Q44. Docker Compose**

**면접관**: Docker Compose는 언제 사용하나요?

**답변**:

```
Docker Compose는 여러 컨테이너를 
한 번에 관리할 때 사용합니다.

단일 컨테이너:

docker run -d -p 8080:8080 \
  -e DB_HOST=localhost \
  -e DB_PASSWORD=1234 \
  bizsync-backend

이걸 3개 띄우려면 명령어 3번 쳐야 하죠.

Docker Compose:

version: '3.8'
services:
  backend:
    image: bizsync-backend
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=db
      - DB_PASSWORD=1234
  
  frontend:
    image: bizsync-frontend
    ports:
      - "80:80"
    depends_on:
      - backend

실행:
docker-compose up -d
# 한 번에 backend, frontend 모두 실행

BizSync 실제 구성:

services:
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_DATASOURCE_URL=${DB_URL}
    depends_on:
      - db
    networks:
      - bizsync-network
  
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
  
  db:
    image: mariadb:10.11
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
    volumes:
      - db-data:/var/lib/mysql

volumes:
  db-data:

networks:
  bizsync-network:

장점:

1. 한 파일에 전체 구성 정의
2. 한 명령으로 전체 실행/중지
3. 환경 변수 관리 쉬움 (.env)
4. 네트워크 자동 생성
5. 볼륨 관리 편리

명령어:

docker-compose up -d     # 시작
docker-compose down      # 중지 및 삭제
docker-compose logs -f   # 로그
docker-compose restart   # 재시작

개발 환경에서 특히 유용합니다.
backend + frontend + db를 
한 번에 띄울 수 있으니까요.
```

---

### **Q45. Docker 네트워크**

**면접관**: Docker 컨테이너 간 통신은 어떻게 하나요?

**답변**:

```
Docker는 자체 네트워크를 만들어서
컨테이너끼리 통신합니다.

네트워크 종류:

1. bridge (기본)
   - 같은 호스트 내 통신
   - 컨테이너 이름으로 통신

2. host
   - 호스트 네트워크 직접 사용
   - 포트 충돌 주의

3. none
   - 네트워크 없음
   - 완전 격리

BizSync 구성:

docker-compose.yml:
networks:
  bizsync-network:

services:
  backend:
    networks:
      - bizsync-network
  
  frontend:
    networks:
      - bizsync-network

이렇게 하면 frontend에서 backend를 
컨테이너 이름으로 접근할 수 있습니다.

// Frontend nginx.conf
location /api {
  proxy_pass http://backend:8080;
  # 'backend'가 컨테이너 이름
}

외부에서 접근:

localhost:80 → frontend container
localhost:8080 → backend container

컨테이너 간 통신:

frontend → http://backend:8080
# localhost가 아니라 컨테이너 이름!

DB 접근:

Backend 설정:
spring:
  datasource:
    url: jdbc:mariadb://db:3306/bizsync
    # 'db'가 DB 컨테이너 이름

포트 매핑:

ports:
  - "8080:8080"
  # 호스트:컨테이너

외부(브라우저) → 8080 → 컨테이너 8080

내부 통신은 포트 매핑 없어도 됩니다.
같은 네트워크면 직접 통신 가능하니까요.

네트워크 명령어:

docker network ls          # 네트워크 목록
docker network inspect     # 상세 정보
docker network create      # 네트워크 생성
```

---

## **Part 8: 자료구조 (10개)**

### **Q46. 배열 vs 링크드 리스트**

**면접관**: 배열과 링크드 리스트의 차이는?

**답변**:

```
배열은 연속된 메모리 공간에 저장하고,
링크드 리스트는 노드가 포인터로 연결됩니다.

배열:
[1][2][3][4][5]
메모리에 연속 배치

링크드 리스트:
[1|→] → [2|→] → [3|→] → [4|→] → [5|null]

시간 복잡도 비교:

| 연산 | 배열 | 링크드 리스트 |
|------|------|--------------|
| 조회 | O(1) | O(n) |
| 삽입(앞) | O(n) | O(1) |
| 삽입(뒤) | O(1) | O(1) |
| 삭제(앞) | O(n) | O(1) |
| 삭제(뒤) | O(1) | O(n) |

Java에서:

// 배열 기반
List<Task> tasks = new ArrayList<>();
tasks.get(5);  // O(1) 빠름!

// 링크드 리스트
List<Task> tasks = new LinkedList<>();
tasks.get(5);  // O(n) 느림!

BizSync에서는 거의 ArrayList만 씁니다.
조회가 훨씬 많으니까요.

@Entity
public class Project {
  @OneToMany
  private List<ProjectMember> members = new ArrayList<>();
  // ArrayList가 기본
}

LinkedList를 쓸 때:
- 앞/뒤 삽입/삭제가 빈번
- 조회는 거의 없음
- 큐 구현

실제로는 ArrayDeque나 PriorityQueue를
더 많이 씁니다.

정리:
- 일반적: ArrayList
- 앞/뒤 삽입 많음: LinkedList
- 조회 많음: 무조건 ArrayList
```

---

### **Q47. Stack vs Queue**

**면접관**: Stack과 Queue를 설명해주세요.

**답변**:

```
Stack은 LIFO(Last In First Out),
Queue는 FIFO(First In First Out)입니다.

Stack:
push(1) → [1]
push(2) → [1,2]
push(3) → [1,2,3]
pop()   → 3 (마지막 거)

Queue:
offer(1) → [1]
offer(2) → [1,2]
offer(3) → [1,2,3]
poll()   → 1 (첫 번째 거)

Java 구현:

// Stack
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.pop();
stack.peek();  // 확인만

// Queue (Deque 권장)
Queue<Integer> queue = new ArrayDeque<>();
queue.offer(1);
queue.poll();
queue.peek();

BizSync에서 실제로 쓴 건 아니지만,
사용 사례를 말씀드리면,

Stack:
- 브라우저 뒤로가기
- 함수 호출 스택
- Undo 기능

DFS (깊이 우선 탐색):
Stack<Node> stack = new Stack<>();
stack.push(root);
while (!stack.isEmpty()) {
  Node node = stack.pop();
  visit(node);
  for (Node child : node.children) {
    stack.push(child);
  }
}

Queue:
- 작업 큐
- BFS (너비 우선 탐색)
- 프린터 대기열

BFS:
Queue<Node> queue = new ArrayDeque<>();
queue.offer(root);
while (!queue.isEmpty()) {
  Node node = queue.poll();
  visit(node);
  for (Node child : node.children) {
    queue.offer(child);
  }
}

만약 BizSync에서 Task 의존성을
트리 구조로 표현했다면
BFS로 순회했을 것 같습니다.
```

---

### **Q48. Hash Table**

**면접관**: Hash Table의 동작 원리는?

**답변**:

```
Hash Table은 키를 해시 함수에 넣어서
배열 인덱스를 얻고 값을 저장합니다.

key → hash(key) → index → value

예시:
hash("hong") = 3
→ array[3]에 저장

장점: O(1) 조회/삽입/삭제

충돌 해결:

1. Chaining (Java HashMap 방식)
   array[3] → [("hong", 1), ("kim", 2)]
   같은 인덱스에 LinkedList로 연결

2. Open Addressing
   충돌 시 다음 빈 자리 찾기

Java에서:

Map<String, User> users = new HashMap<>();
users.put("hong@...", user);     // O(1)
User user = users.get("hong@..."); // O(1)

BizSync 실제 사용:

// 캐시로 사용
private Map<Long, Project> projectCache = new HashMap<>();

public Project findProject(Long id) {
  if (projectCache.containsKey(id)) {
    return projectCache.get(id);  // 캐시 히트
  }
  
  Project project = repository.findById(id);
  projectCache.put(id, project);
  return project;
}

HashMap vs HashTable:
- HashMap: thread-unsafe, null 허용
- HashTable: thread-safe, null 불허 (레거시)
- ConcurrentHashMap: thread-safe (권장)

주의사항:

Key로 쓸 객체는 equals()와 hashCode() 구현 필수!

@Override
public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof User)) return false;
  User user = (User) o;
  return Objects.equals(userId, user.userId);
}

@Override
public int hashCode() {
  return Objects.hash(userId);
}

안 하면 제대로 안 찾아집니다.

정리:
- 평균 O(1) 성능
- 충돌 시 성능 저하
- Key 객체는 equals/hashCode 필수
```

---

**현재 진행: 48/120**

계속 이어서 진행할까요?